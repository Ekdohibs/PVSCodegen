(preprocess
 (release_set_TCC1 0
  (release_set_TCC1-1 nil 3655095779
   ("" (grind :rewrites "card_remove") nil nil)
   ((ccard const-decl "nat" preprocess nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (card_remove formula-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (release_set_TCC2 0
  (release_set_TCC2-1 nil 3655095779 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   nil))
 (vars_release_set 0
  (vars_release_set-1 nil 3656129143
   ("" (induct "X" :name "finite_set_induction")
    (("1" (grind-with-ext) nil nil)
     ("2" (grind :if-match nil)
      (("2" (expand "release_set" +)
        (("2" (lift-if)
          (("2" (ground)
            (("1" (inst?) nil nil)
             ("2" (inst? -5)
              (("2" (replace -5)
                (("2" (expand "vars" + 1)
                  (("2" (grind-with-ext) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (choose const-decl "(p)" sets nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (x!3 skolem-const-decl "nat" preprocess nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (union const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (refs_release_set 0
  (refs_release_set-1 nil 3693115772
   ("" (induct "X" :name "finite_set_induction")
    (("1" (grind) nil nil)
     ("2" (grind :if-match nil)
      (("1" (expand "release_set" -7)
        (("1" (ground) (("1" (inst? -7) (("1" (grind) nil nil)) nil))
          nil))
        nil)
       ("2" (expand "release_set" +)
        (("2" (ground)
          (("2" (inst? -6)
            (("2" (replace -6)
              (("2" (hide-all-but (-7 2))
                (("2" (grind)
                  (("2" (expand "refs" +) (("2" (postpone) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (release_set def-decl "IExpression" preprocess nil)
    (refs def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (top_releases_TCC1 0
  (top_releases_TCC1-1 nil 3698775181 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (releaset_set_top 0
  (releaset_set_top-1 nil 3698775280
   ("" (induct "X" :name "finite_set_induction")
    (("1" (grind)
      (("1" (grind)
        (("1" (use card_emptyset) (("1" (grind) nil nil)) nil)) nil))
      nil)
     ("2" (skeep*)
      (("2" (expand release_set 1)
        (("2" (assert)
          (("2" (lift-if)
            (("2" (split)
              (("1" (grind) nil nil)
               ("2" (ground)
                (("2"
                  (inst -2 "release(variable(choose(X_1), TRUE), A)")
                  (("2" (rewrite -2)
                    (("2" (expand top_releases 2 1)
                      (("2" (expand ccard)
                        (("2" (use card_remove) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nonempty? const-decl "bool" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (choose const-decl "(p)" sets nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (card_remove formula-decl nil finite_sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (card_emptyset formula-decl nil finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (ccard const-decl "nat" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (release_set def-decl "IExpression" preprocess nil)
    (top_releases def-decl "nat" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (eq_release_set 0
  (eq_release_set-1 nil 3698774797
   ("" (skeep*)
    (("" (use releaset_set_top)
      (("" (rewrite -2)
        (("" (simplify)
          (("" (use empty_card) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((releaset_set_top formula-decl nil preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (ccard const-decl "nat" preprocess nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (empty_card formula-decl nil finite_sets nil))
   shostak))
 (markvar_TCC1 0
  (markvar_TCC1-1 nil 3655327556 ("" (subtype-tcc) nil nil) nil nil))
 (markvar_TCC2 0
  (markvar_TCC2-1 nil 3698774796 ("" (subtype-tcc) nil nil) nil nil))
 (markvars_TCC1 0
  (markvars_TCC1-1 nil 3655327556 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (length def-decl "nat" list_props nil))
   nil))
 (markvars_TCC2 0
  (markvars_TCC2-1 nil 3655327556 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (injective? const-decl "bool" functions nil)
    (in_varlist const-decl "finite_set[nat]" IL nil))
   nil))
 (markvars_TCC3 0
  (markvars_TCC3-1 nil 3655523103 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (injective? const-decl "bool" functions nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (length def-decl "nat" list_props nil))
   nil))
 (markvars_TCC4 0
  (markvars_TCC4-1 nil 3655523103 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (injective? const-decl "bool" functions nil)
    (in_varlist const-decl "finite_set[nat]" IL nil))
   nil))
 (markvars_TCC5 0
  (markvars_TCC5-1 nil 3655523103 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (injective? const-decl "bool" functions nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (length def-decl "nat" list_props nil))
   nil))
 (markvars_index_TCC1 0
  (markvars_index_TCC1-1 nil 3655520141 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil))
   nil))
 (markvars_index 0
  (markvars_index-1 nil 3655520143
   ("" (induct "L")
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (case "i = 0")
          (("1" (grind) nil nil)
           ("2" (inst - "X" "i - 1")
            (("1" (grind) nil nil)
             ("2" (grind)
              (("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (grind) nil nil)) nil))
    nil)
   ((injective? const-decl "bool" functions nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (i skolem-const-decl "below(length(cons(cons1_var, cons2_var)))"
       preprocess nil)
    (cons2_var skolem-const-decl "list[(variable?)]" preprocess nil)
    (cons1_var skolem-const-decl "(variable?)" preprocess nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil))
   shostak))
 (markvars_mark_TCC1 0
  (markvars_mark_TCC1-1 nil 3683255315 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (markvars_mark 0
  (markvars_mark-1 nil 3683246771
   ("" (induct "L")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (case "i = 0")
        (("1" (grind :if-match nil)
          (("1"
            (case "some(lambda (v: (variable?)):
                                        index(v) = index(cons1_var))
                                     (cons2_var)")
            (("1" (assert)
              (("1" (rewrite "some_nth")
                (("1" (skeep)
                  (("1" (inst - "X" "i!1")
                    (("1" (ground)
                      (("1" (skeep)
                        (("1" (inst + "j + 1") (("1" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (inst + 0)
              (("1" (grind) nil nil) ("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (inst - "X" "i - 1")
          (("1" (grind :if-match nil)
            (("1" (inst + "j!1 + 1") (("1" (grind) nil nil)) nil)) nil)
           ("2" (ground)
            (("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (grind) nil nil)) nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cons1_var skolem-const-decl "(variable?)" preprocess nil)
    (i skolem-const-decl "below(length(cons(cons1_var, cons2_var)))"
       preprocess nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (cons2_var skolem-const-decl "list[(variable?)]" preprocess nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (some adt-def-decl "boolean" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil))
   shostak))
 (markvars_markX 0
  (markvars_markX-1 nil 3693198805
   ("" (induct "L")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand "markvars")
        (("2" (lift-if)
          (("2" (ground)
            (("1" (case "j = 0")
              (("1" (grind) nil nil)
               ("2" (inst - "X" "j - 1")
                (("1" (grind) nil nil)
                 ("2" (grind)
                  (("2" (typepred "j") (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (case "j = 0")
              (("1" (grind) nil nil)
               ("2" (inst - "X" "j - 1")
                (("1" (grind) nil nil)
                 ("2" (typepred "j") (("2" (grind) nil nil)) nil))
                nil))
              nil)
             ("3" (case "j = 0")
              (("1" (grind) nil nil)
               ("2" (inst - "X" "j - 1")
                (("1" (grind) nil nil)
                 ("2" (typepred "j") (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (grind) nil nil)) nil))
    nil)
   ((some adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (j skolem-const-decl "below(length(cons(cons1_var, cons2_var)))"
     preprocess nil)
    (cons2_var skolem-const-decl "list[(variable?)]" preprocess nil)
    (cons1_var skolem-const-decl "(variable?)" preprocess nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil))
   shostak))
 (markvars_idem 0
  (markvars_idem-1 nil 3655518488
   (""
    (induct-and-simplify "L" :rewrites ("some_nth" "markvars_index"))
    nil nil)
   ((markvars_index formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (markvars_varlist 0
  (markvars_varlist-1 nil 3699196365
   ("" (skeep*)
    (("" (expand in_varlist)
      (("" (apply-extensionality)
        (("" (delete 2)
          (("" (rewrite some_nth)
            (("" (rewrite some_nth)
              (("" (lemma markvars_index) (("" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (markvars_index formula-decl nil preprocess nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (some adt-def-decl "boolean" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (length def-decl "nat" list_props nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (markvars_repeat 0
  (markvars_repeat-1 nil 3699195931
   ("" (induct L)
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand markvars 1 (2 3))
        (("2" (expand markvars 1 (1 3))
          (("2" (lift-if)
            (("2" (expand markvar)
              (("2" (expand unmarkvar)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (split 1)
                      (("1" (flatten)
                        (("1" (inst? -3)
                          (("1" (split -3)
                            (("1" (grind) nil nil)
                             ("2" (hide-all-but (1 -3))
                              (("2"
                                (skeep*)
                                (("2" (grind) nil nil))
                                nil))
                              nil)
                             ("3" (propax) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (hide-all-but (-1 -4 1 2))
                          (("2" (rewrite markvars_varlist)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split 3)
                      (("1" (flatten)
                        (("1" (rewrite markvars_varlist)
                          (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (flatten)
                        (("2" (inst? -1) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((markvar const-decl "(variable?)" preprocess nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (markvars_varlist formula-decl nil preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (some adt-def-decl "boolean" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (markvars_bump 0
  (markvars_bump-1 nil 3699206885
   ("" (induct L)
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand markvars 1 1)
        (("2" (expand map 1)
          (("2" (expand markvars 1 3)
            (("2" (lift-if)
              (("2" (lift-if)
                (("2" (lift-if)
                  (("2" (split 1)
                    (("1" (flatten)
                      (("1" (split 1)
                        (("1" (grind-with-ext) nil nil)
                         ("2" (flatten)
                          (("2" (delete -2 3)
                            (("2" (expand bump)
                              (("2"
                                (expand bumpn)
                                (("2"
                                  (expand in_varlist)
                                  (("2"
                                    (rewrite some_map)
                                    (("2"
                                      (expand o)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split 3)
                        (("1" (flatten)
                          (("1" (delete 1 -2)
                            (("1" (expand bump)
                              (("1"
                                (expand bumpn)
                                (("1"
                                  (expand in_varlist)
                                  (("1"
                                    (rewrite some_map)
                                    (("1"
                                      (expand o)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind-with-ext) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((markvar const-decl "(variable?)" preprocess nil)
    (O const-decl "T3" function_props nil)
    (some_map formula-decl nil finseq_theorems nil)
    (TRUE const-decl "bool" booleans nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (length def-decl "nat" list_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (markv_idem 0
  (markv_idem-1 nil 3699190320 ("" (grind) nil nil)
   ((markv const-decl "(variable?)" preprocess nil)) shostak))
 (mark_TCC1 0
  (mark_TCC1-1 nil 3655095779
   ("" (skeep)
    (("" (rewrite "every_nth")
      (("" (skeep)
        (("" (expand "<<")
          (("" (assert)
            (("" (rewrite "some_nth")
              (("" (inst + "i")
                (("1" (grind) nil nil)
                 ("2" (grind)
                  (("2" (typepred "i") (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (mark_TCC2 0
  (mark_TCC2-1 nil 3655095779 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (injective? const-decl "bool" functions nil)
    (bump const-decl "finite_set[nat]" IL nil))
   nil))
 (mark_TCC3 0
  (mark_TCC3-1 nil 3655095779
   ("" (skeep :preds? t)
    (("" (grind :if-match nil)
      (("" (inst + "N!1" "(LAMBDA (i | i > 0 AND X(i-1)):  f!1(i-1))")
        (("1" (skeep)
          (("1" (forward-chain -2) (("1" (ground) nil nil)) nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (mark_TCC4 0
  (mark_TCC4-1 nil 3655095779 ("" (grind) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (mark_TCC5 0
  (mark_TCC5-1 nil 3655095779 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (injective? const-decl "bool" functions nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   nil))
 (mark_TCC6 0
  (mark_TCC6-1 nil 3655095779 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (injective? const-decl "bool" functions nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   nil))
 (mark_TCC7 0
  (mark_TCC7-1 nil 3655095779 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (vars_mark 0
  (vars_mark-1 nil 3656126421
   ("" (induct-and-simplify "B")
    (("1" (grind-with-ext) nil nil)
     ("2" (grind-with-ext :rewrites "markvars_index")
      (("1" (rewrite "some_nth")
        (("1" (rewrite "some_nth") (("1" (lazy-grind) nil nil)) nil))
        nil)
       ("2" (rewrite "some_nth")
        (("2" (rewrite "some_nth") (("2" (lazy-grind) nil nil)) nil))
        nil))
      nil)
     ("3" (grind) (("3" (apply-extensionality) nil nil)) nil)
     ("4" (grind)
      (("4" (rewrite "vars_release_set")
        (("4" (rewrite "vars_release_set")
          (("4" (replace -1 :hide? t)
            (("4" (replace -1 :hide? t)
              (("4" (apply-extensionality) (("4" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil))
    nil)
   ((vars_release_set formula-decl nil preprocess nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (length def-decl "nat" list_props nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (markvars_index formula-decl nil preprocess nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (markv const-decl "(variable?)" preprocess nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (vars_mark_type 0
  (vars_mark_type-1 nil 3656867445 ("" (use "vars_mark") nil nil)
   ((vars_mark formula-decl nil preprocess nil)) nil))
 (mark_release_set 0
  (mark_release_set-1 nil 3656260905
   ("" (induct "Y" :name "finite_set_induction")
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "release_set" +)
          (("2" (lift-if)
            (("2" (ground)
              (("2" (inst?)
                (("2" (ground)
                  (("1" (replace -1 :hide? t)
                    (("1" (rewrite "mark") (("1" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (hide 3)
                    (("2" (expand "disjoint?")
                      (("2" (expand "empty?")
                        (("2" (lazy-grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (markv const-decl "(variable?)" preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_intersection2 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (release_set def-decl "IExpression" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (mark_idem 0
  (mark_idem-1 nil 3655518427
   ("" (induct "A")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep*)
      (("4" (expand mark 1) (("4" (rewrite markvars_idem) nil nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (expand mark 1)
        (("5" (decompose-equality 1)
          (("1" (rewrite vars_mark)
            (("1" (expand vars 1 3)
              (("1" (rewrite vars_mark)
                (("1" (expand drop)
                  (("1" (expand add)
                    (("1" (expand member) (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand vars 1 3)
            (("2" (expand add 1 1)
              (("2" (rewrite vars_mark)
                (("2" (simplify)
                  (("2" (lift-if)
                    (("2" (expand mark 1 4)
                      (("2" (expand markv 1)
                        (("2" (rewrite vars_mark)
                          (("2" (expand union)
                            (("2" (expand bump)
                              (("2"
                                (expand member)
                                (("2"
                                  (expand bumpn 1 4)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (expand mark 1)
        (("6" (decompose-equality)
          (("1" (rewrite vars_release_set)
            (("1" (rewrite vars_release_set)
              (("1" (rewrite vars_mark)
                (("1" (rewrite vars_mark)
                  (("1"
                    (case-replace "union(union(vars(ift2_var),
                        difference(vars(ift3_var),
                                   union(vars(ift2_var), X))),
                  union(union(vars(ift3_var),
                              difference(vars(ift2_var),
                                         union(vars(ift3_var), X))),
                        X)) = union(vars(ift2_var), union(vars(ift3_var), X))")
                    (("1" (grind) nil nil)
                     ("2" (delete 2)
                      (("2" (expand union)
                        (("2" (expand difference)
                          (("2" (expand member)
                            (("2" (grind-with-ext) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2"
            (case-replace
             "difference(vars(release_set(mark(X)(ift3_var),
                                              difference
                                              (vars(ift2_var),
                                               union(vars(ift3_var), X)))),
                             union(vars(release_set
                                        (mark(X)(ift2_var),
                                         difference
                                         (vars(ift3_var),
                                          union(vars(ift2_var), X)))),
                                   X)) = emptyset")
            (("1" (simplify)
              (("1" (expand release_set 1 1)
                (("1" (expand empty?)
                  (("1" (expand emptyset 1)
                    (("1" (expand member 1)
                      (("1" (rewrite mark_release_set)
                        (("1" (rewrite -3) nil nil)
                         ("2" (expand disjoint?)
                          (("2" (expand empty?)
                            (("2" (expand intersection)
                              (("2"
                                (expand difference)
                                (("2"
                                  (rewrite vars_mark)
                                  (("2"
                                    (expand union)
                                    (("2"
                                      (expand member)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2" (rewrite vars_release_set)
                (("2" (rewrite vars_release_set)
                  (("2" (rewrite vars_mark)
                    (("2" (rewrite vars_mark)
                      (("2" (grind-with-ext) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3"
            (case-replace
             "difference(vars(release_set(mark(X)(ift2_var),
                                              difference
                                              (vars(ift3_var),
                                               union(vars(ift2_var), X)))),
                             union(vars(release_set
                                        (mark(X)(ift3_var),
                                         difference
                                         (vars(ift2_var),
                                          union(vars(ift3_var), X)))),
                                   X)) = emptyset")
            (("1" (rewrite mark_release_set)
              (("1" (rewrite -4) (("1" (grind) nil nil)) nil)
               ("2" (rewrite vars_mark) (("2" (grind) nil nil)) nil))
              nil)
             ("2" (delete 2)
              (("2" (rewrite vars_release_set)
                (("2" (rewrite vars_release_set)
                  (("2" (rewrite vars_mark)
                    (("2" (rewrite vars_mark)
                      (("2" (grind-with-ext) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (markvars_idem formula-decl nil preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (vars_mark formula-decl nil preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (member const-decl "bool" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (union const-decl "set" sets nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (emptyset const-decl "set" sets nil)
    (mark_release_set formula-decl nil preprocess nil)
    (intersection const-decl "set" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (finite_intersection2 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_release_set formula-decl nil preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (difference const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (mark_repeat 0
  (mark_repeat-1 nil 3699193091
   ("" (induct A)
    (("1" (skeep*)
      (("1" (expand mark 1 (2 3))
        (("1" (expand markv)
          (("1" (expand mark)
            (("1" (expand markv)
              (("1" (lift-if) (("1" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep*)
      (("4" (expand mark 1)
        (("4" (decompose-equality 1)
          (("4" (use markvars_repeat) (("4" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (expand mark 1)
        (("5" (rewrite vars_mark)
          (("5" (expand vars 1 3)
            (("5" (rewrite vars_mark)
              (("5" (decompose-equality)
                (("1" (rewrite -1)
                  (("1" (hide-all-but (-3 -4 1))
                    (("1" (skeep*)
                      (("1" (typepred i)
                        (("1" (expand union)
                          (("1" (expand drop)
                            (("1" (expand add)
                              (("1"
                                (expand member)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but (1 -3 -4))
                    (("2" (skeep*)
                      (("2" (typepred i)
                        (("2" (expand union)
                          (("2" (expand drop)
                            (("2" (expand add)
                              (("2"
                                (expand member)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lift-if)
                  (("2" (lift-if)
                    (("2" (ground)
                      (("1" (rewrite -3)
                        (("1" (hide-all-but (-1 -4 -5 1))
                          (("1" (skeep*)
                            (("1" (typepred i)
                              (("1"
                                (expand bump)
                                (("1"
                                  (expand bumpn)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skeep*)
                          (("2" (typepred i)
                            (("2" (hide-all-but (-1 -2 -5 -6 1))
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand mark 1 1)
                        (("2" (decompose-equality)
                          (("1" (expand markv)
                            (("1" (lift-if)
                              (("1"
                                (ground)
                                (("1"
                                  (hide-all-but (-1 -5 -6))
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (rewrite -3)
                            (("1" (hide-all-but (-4 -5 1))
                              (("1"
                                (skeep*)
                                (("1"
                                  (typepred i)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but (1 -4 -5))
                              (("2"
                                (skeep*)
                                (("2"
                                  (typepred i)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (expand mark 1)
        (("6" (decompose-equality)
          (("1" (rewrite vars_release_set)
            (("1" (rewrite vars_mark)
              (("1" (rewrite vars_release_set)
                (("1" (rewrite vars_mark)
                  (("1" (expand markv)
                    (("1" (lift-if)
                      (("1" (lift-if)
                        (("1" (lift-if)
                          (("1" (ground)
                            (("1" (delete -2 -3 -4)
                              (("1" (grind) nil nil)) nil)
                             ("2" (delete -2 -3 -4)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rewrite mark_release_set)
            (("1" (rewrite -2)
              (("1" (rewrite vars_release_set)
                (("1" (rewrite vars_release_set)
                  (("1" (rewrite vars_mark)
                    (("1" (rewrite vars_mark)
                      (("1" (expand difference)
                        (("1" (expand union)
                          (("1" (expand member)
                            (("1"
                              (case-replace "{x_1: nat |
                     (vars(ift3_var)(x_1) OR
                       vars(ift2_var)(x_1) AND
                        NOT (vars(ift3_var)(x_1) OR Y(x_1)))
                      AND
                      NOT ((vars(ift2_var)(x_1) OR
                             vars(ift3_var)(x_1) AND
                              NOT (vars(ift2_var)(x_1) OR Y(x_1)))
                            OR X(x_1))} = emptyset")
                              (("1"
                                (expand release_set 1 1)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (delete 2)
                                (("2"
                                  (hide-all-but (1 -4 -5))
                                  (("2" (grind-with-ext) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide-all-but (1 -4 -5))
                (("2" (skeep*)
                  (("2" (inst -2 i)
                    (("2" (split -2)
                      (("1" (propax) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2" (expand disjoint?)
                (("2" (expand intersection)
                  (("2" (expand difference)
                    (("2" (expand union)
                      (("2" (expand member)
                        (("2" (expand empty?)
                          (("2" (skeep*)
                            (("2" (expand member)
                              (("2"
                                (hide-all-but (-1 -5 -6))
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (rewrite mark_release_set)
            (("1" (rewrite vars_release_set)
              (("1" (rewrite vars_release_set)
                (("1" (rewrite vars_mark)
                  (("1" (rewrite vars_mark)
                    (("1" (rewrite -3)
                      (("1"
                        (case-replace "difference(union(vars(ift2_var),
                                   difference(vars(ift3_var),
                                              union(vars(ift2_var), Y))),
                             union(union(vars(ift3_var),
                                         difference
                                         (vars(ift2_var),
                                          union(vars(ift3_var), Y))),
                                   X)) = emptyset")
                        (("1" (expand release_set 1 1)
                          (("1" (grind) nil nil)) nil)
                         ("2" (delete 2)
                          (("2" (hide-all-but (1 -4 -5))
                            (("2" (grind-with-ext) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (hide-all-but (1 -4 -5))
                        (("2" (skeep*)
                          (("2" (inst -2 i) (("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but (1 -4 -5))
              (("2" (rewrite vars_mark)
                (("2" (expand disjoint?)
                  (("2" (expand empty?)
                    (("2" (expand intersection)
                      (("2" (expand difference)
                        (("2" (expand union)
                          (("2" (expand member)
                            (("2" (skeep*)
                              (("2"
                                (ground)
                                (("2"
                                  (inst -3 x)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep*)
      (("7" (expand mark 1)
        (("7" (decompose-equality)
          (("1" (expand markv)
            (("1" (lift-if)
              (("1" (lift-if)
                (("1" (lift-if)
                  (("1" (lift-if)
                    (("1" (ground)
                      (("1" (hide-all-but (-1 -5 -6 1))
                        (("1" (grind) nil nil)) nil)
                       ("2" (hide-all-but (-1 -5 -6 2))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand markv)
            (("2" (lift-if)
              (("2" (lift-if)
                (("2" (lift-if)
                  (("2" (lift-if)
                    (("2" (ground)
                      (("1" (hide-all-but (-1 -5 -6 1))
                        (("1" (grind) nil nil)) nil)
                       ("2" (hide-all-but (-1 -5 -6 2))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (expand markv)
            (("3" (lift-if)
              (("3" (lift-if)
                (("3" (lift-if)
                  (("3" (ground)
                    (("1" (hide-all-but (-1 -5 -6 1))
                      (("1" (grind) nil nil)) nil)
                     ("2" (hide-all-but (-1 -5 -6 2))
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skeep*)
      (("8" (expand mark 1)
        (("8" (decompose-equality)
          (("1" (expand markv)
            (("1" (lift-if)
              (("1" (lift-if)
                (("1" (lift-if)
                  (("1" (lift-if)
                    (("1" (ground)
                      (("1" (hide-all-but (-1 -4 -5 1))
                        (("1" (grind) nil nil)) nil)
                       ("2" (hide-all-but (-1 -4 -5 2))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand markv)
            (("2" (lift-if)
              (("2" (lift-if)
                (("2" (lift-if)
                  (("2" (ground)
                    (("1" (hide-all-but (-1 -4 -5 1))
                      (("1" (grind) nil nil)) nil)
                     ("2" (hide-all-but (-1 -4 -5 2))
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (skeep*)
      (("11" (expand mark 1)
        (("11" (decompose-equality)
          (("11" (rewrite -1)
            (("1" (grind) nil nil)
             ("2" (delete 2) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("12" (grind) nil nil)
     ("13" (skeep*)
      (("13" (expand mark 1)
        (("13" (decompose-equality)
          (("1" (expand markv)
            (("1" (lift-if)
              (("1" (lift-if)
                (("1" (lift-if)
                  (("1" (ground)
                    (("1" (hide-all-but (-1 -4 -5 1))
                      (("1" (grind) nil nil)) nil)
                     ("2" (hide-all-but (-1 -4 -5 2))
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rewrite -2) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((release1_var skolem-const-decl "(variable?)" preprocess nil)
    (X skolem-const-decl "finite_set[nat]" preprocess nil)
    (Y skolem-const-decl "finite_set[nat]" preprocess nil)
    (release2_var skolem-const-decl "IExpression" preprocess nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (IExpression_pop_extensionality formula-decl nil IExpression_adt
     nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (Y skolem-const-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (i!1 skolem-const-decl "(bump(Y))" preprocess nil)
    (i!1 skolem-const-decl "(bump(Y))" preprocess nil)
    (injective? const-decl "bool" functions nil)
    (X skolem-const-decl "finite_set[nat]" preprocess nil)
    (i!1 skolem-const-decl "(bump(X))" preprocess nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (IExpression_lookup_extensionality formula-decl nil IExpression_adt
     nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup1_var skolem-const-decl "(variable?)" preprocess nil)
    (X skolem-const-decl "finite_set[nat]" preprocess nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (IExpression_update_extensionality formula-decl nil IExpression_adt
     nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (update1_var skolem-const-decl "(variable?)" preprocess nil)
    (X skolem-const-decl "finite_set[nat]" preprocess nil)
    (update2_var skolem-const-decl "(variable?)" preprocess nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (difference const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (X skolem-const-decl "finite_set[nat]" preprocess nil)
    (ift1_var skolem-const-decl "(variable?)" preprocess nil)
    (vars_release_set formula-decl nil preprocess nil)
    (intersection const-decl "set" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (finite_intersection2 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (x!1 skolem-const-decl "nat" preprocess nil)
    (Y skolem-const-decl "finite_set[nat]" preprocess nil)
    (x!1 skolem-const-decl "nat" preprocess nil)
    (mark_release_set formula-decl nil preprocess nil)
    (x!1 skolem-const-decl "nat" preprocess nil)
    (x!1 skolem-const-decl "nat" preprocess nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (vars_mark formula-decl nil preprocess nil)
    (X skolem-const-decl "finite_set[nat]" preprocess nil)
    (i skolem-const-decl "(bump(Y))" preprocess nil)
    (Y skolem-const-decl "finite_set[nat]" preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (i skolem-const-decl "(bump(Y))" preprocess nil)
    (member const-decl "bool" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (union const-decl "set" sets nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (length def-decl "nat" list_props nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (IExpression_application_extensionality formula-decl nil
     IExpression_adt nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (markvars_repeat formula-decl nil preprocess nil)
    (emptyset const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (Y skolem-const-decl "finite_set[nat]" preprocess nil)
    (variable1_var skolem-const-decl "nat" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (refs_mark 0
  (refs_mark-1 nil 3693113889
   ("" (induct "A")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (grind :rewrites "refs_release_set") nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil))
    nil)
   ((bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (refs_release_set formula-decl nil preprocess nil)
    (empty? const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (bump const-decl "finite_set[nat]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (mark def-decl "IExpression" preprocess nil)
    (refs def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (popDepth_mark 0
  (popDepth_mark-1 nil 3693282152
   ("" (induct-and-simplify "A") nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (popDepth def-decl "nat" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (bump const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil))
   shostak))
 (top_releases_mark 0
  (top_releases_mark-1 nil 3698777907
   ("" (induct-and-rewrite! "A") nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (top_releases def-decl "nat" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (eq_mark_release_set 0
  (eq_mark_release_set-1 nil 3698777865
   ("" (skeep*)
    ((""
      (case "top_releases(release_set(mark(Y)(A), X)) = top_releases(A)")
      (("1" (rewrite "releaset_set_top")
        (("1" (rewrite "top_releases_mark")
          (("1" (use empty_card) (("1" (grind) nil nil)) nil)) nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((mark def-decl "IExpression" preprocess nil)
    (release_set def-decl "IExpression" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (top_releases def-decl "nat" preprocess nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (top_releases_mark formula-decl nil preprocess nil)
    (ccard const-decl "nat" preprocess nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (empty_card formula-decl nil finite_sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (releaset_set_top formula-decl nil preprocess nil))
   shostak))
 (mvars_TCC1 0
  (mvars_TCC1-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (mvars_TCC2 0
  (mvars_TCC2-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (mvars_TCC3 0
  (mvars_TCC3-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (mvars_TCC4 0
  (mvars_TCC4-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (mvars_TCC5 0
  (mvars_TCC5-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (mvars_TCC6 0
  (mvars_TCC6-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (mvars_TCC7 0
  (mvars_TCC7-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (mvars_TCC8 0
  (mvars_TCC8-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (mvars_TCC9 0
  (mvars_TCC9-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (mvars_TCC10 0
  (mvars_TCC10-1 nil 3683842373 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (mvars_TCC11 0
  (mvars_TCC11-1 nil 3683842373 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (unmarkvars_TCC1 0
  (unmarkvars_TCC1-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (unmark_TCC1 0
  (unmark_TCC1-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (unmark_TCC2 0
  (unmark_TCC2-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (unmark_TCC3 0
  (unmark_TCC3-1 nil 3683842373 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (markc_TCC1 0
  (markc_TCC1-1 nil 3655657330 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)
    (injective? const-decl "bool" functions nil)
    (bump const-decl "finite_set[nat]" IL nil))
   nil))
 (markc_TCC2 0
  (markc_TCC2-1 nil 3655657330 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)) nil))
 (cvars_TCC1 0
  (cvars_TCC1-1 nil 3683843116 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)) nil))
 (cvars_fill 0
  (cvars_fill-1 nil 3699294594
   ("" (induct "K")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand fill 1)
        (("2" (expand cvars 1)
          (("2" (expand union 1)
            (("2" (expand bumpn 1)
              (("2" (expand drop 1)
                (("2" (expand member 1)
                  (("2" (rewrite popdepth_fill)
                    (("2" (inst? -1)
                      (("2" (rewrite -1)
                        (("2" (expand bumpn 1) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep*) (("3" (grind) nil nil)) nil))
    nil)
   ((int_plus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (popdepth_fill formula-decl nil IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (union const-decl "set" sets nil)
    (emptyset const-decl "set" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IContext_induction formula-decl nil IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fill def-decl "IExpression" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   shostak))
 (mark_fill 0
  (mark_fill-1 nil 3656268737
   ("" (induct "K")
    (("1" (grind)
      (("1"
        (apply (then (rewrite "union_commutative")
                (rewrite "union_empty") (rewrite "bumpn_zero")))
        nil nil)
       ("2"
        (apply (then (rewrite "union_commutative")
                (rewrite "union_empty") (rewrite "bumpn_zero")))
        nil nil)
       ("3"
        (apply (then (rewrite "union_commutative")
                (rewrite "union_empty") (rewrite "bumpn_zero")))
        nil nil))
      nil)
     ("2" (lazy-grind)
      (("1" (hide -)
        (("1" (rewrite "union_associative")
          (("1" (rewrite "bumpn_union") nil nil)) nil))
        nil)
       ("2" (hide -)
        (("2" (rewrite "union_associative")
          (("2" (rewrite "bumpn_union") nil nil)) nil))
        nil)
       ("3" (hide -)
        (("3" (rewrite "union_associative")
          (("3" (rewrite "bumpn_union") nil nil)) nil))
        nil)
       ("4" (lazy-grind :exclude "bump")
        (("4" (hide -)
          (("4" (rewrite "union_associative")
            (("4" (rewrite "bumpn_union") nil nil)) nil))
          nil))
        nil)
       ("5" (hide -)
        (("5" (rewrite "union_associative")
          (("5" (rewrite "bumpn_union") nil nil)) nil))
        nil)
       ("6" (hide -)
        (("6" (rewrite "union_associative")
          (("6" (rewrite "bumpn_union") nil nil)) nil))
        nil))
      nil)
     ("3" (lazy-grind :exclude "bump")
      (("1" (rewrite "bumpn_bump") nil nil)
       ("2" (lazy-grind :exclude "bump")
        (("2" (rewrite "bumpn_bump") nil nil)) nil)
       ("3" (lazy-grind :exclude "bump")
        (("3" (rewrite "bumpn_bump") nil nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn_bump formula-decl nil IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (union_associative formula-decl nil sets_lemmas nil)
    (bumpn_union formula-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (union_commutative formula-decl nil sets_lemmas nil)
    (bumpn_zero formula-decl nil IL nil)
    (union_empty formula-decl nil sets_lemmas nil)
    (IContext_induction formula-decl nil IL nil)
    (popDepth def-decl "nat" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (union const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (fill def-decl "IExpression" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   shostak))
 (wellformed_release_set 0
  (wellformed_release_set-1 nil 3656869616
   ("" (induct "X" :name "finite_set_induction")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand "release_set" +)
        (("2" (ground)
          (("2" (inst?)
            (("2" (ground)
              (("1" (grind) nil nil) ("2" (lazy-grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (intersection2_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_intersection2 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (release_set def-decl "IExpression" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (disjoint? const-decl "bool" sets nil)
    (wellformed? def-decl "bool" preprocess nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (wellformed_mark 0
  (wellformed_mark-1 nil 3656868911
   (""
    (induct-and-simplify "A" :rewrites
     ("vars_mark" "wellformed_release_set"))
    (("1" (rewrite "wellformed_release_set")
      (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)
     ("2" (rewrite "wellformed_release_set")
      (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)
     ("3" (grind) nil nil))
    nil)
   ((markv const-decl "(variable?)" preprocess nil)
    (wellformed_release_set formula-decl nil preprocess nil)
    (finite_intersection2 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (intersection const-decl "set" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (vars_mark formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (wellformed? def-decl "bool" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (mvars_release_set 0
  (mvars_release_set-1 nil 3683210798
   ("" (induct "X" 1 "finite_set_induction")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand "release_set" +)
        (("2" (lift-if)
          (("2" (ground)
            (("1" (grind) nil nil)
             ("2" (inst?)
              (("2" (replace -2 :hide? t)
                (("2" (rewrite "mvars")
                  (("2" (iff +) (("2" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (release_set def-decl "IExpression" preprocess nil)
    (mvars def-decl "bool" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (mvars_mark 0
  (mvars_mark-1 nil 3683170978
   ("" (induct "A")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep*)
      (("4" (rewrite "mark")
        (("4" (rewrite "mvars")
          (("4" (rewrite "some_nth")
            (("4" (iff)
              (("4" (ground)
                (("1" (skeep)
                  (("1" (use "markvars_index")
                    (("1" (rewrite "vars")
                      (("1" (rewrite "in_varlist")
                        (("1" (rewrite "some_nth")
                          (("1" (inst?)
                            (("1" (rewrite "every_nth")
                              (("1"
                                (inst?)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (inst - "i")
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skeep)
                  (("2" (rewrite "every_nth")
                    (("2" (inst - "i_1")
                      (("2" (inst?)
                        (("2" (use "markvars_index")
                          (("2" (grind)
                            (("2"
                              (typepred "nth(application2_var, i_1)")
                              (("2"
                                (grind)
                                (("2"
                                  (grind)
                                  (("2"
                                    (use markvars_markX)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (rewrite "vars")
                  (("3" (expand "in_varlist")
                    (("3" (rewrite "some_nth")
                      (("3" (skeep)
                        (("3" (use "markvars_mark")
                          (("3" (grind :if-match nil)
                            (("3" (inst?)
                              (("3"
                                (apply-extensionality)
                                (("3" (use "markvars_index") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (rewrite "mark")
        (("5" (rewrite "mvars")
          (("5" (inst?)
            (("5" (inst?)
              (("5" (expand "vars" + 2)
                (("5" (rewrite "union" +)
                  (("5" (iff +)
                    (("5" (ground)
                      (("1" (grind) nil nil) ("2" (grind) nil nil)
                       ("3" (grind) nil nil) ("4" (grind) nil nil)
                       ("5" (grind) nil nil) ("6" (grind) nil nil)
                       ("7" (grind) nil nil) ("8" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (rewrite "mark")
        (("6" (rewrite "mvars")
          (("6" (rewrite "mvars_release_set")
            (("6" (rewrite "mvars_release_set")
              (("6"
                (inst -
                 "union(vars(ift2_var), union(vars(ift3_var), X))" "i")
                (("6" (inst?)
                  (("6" (inst?)
                    (("6" (replace*)
                      (("6" (rewrite "mark")
                        (("6" (replace -1)
                          (("6" (hide -)
                            (("6" (iff)
                              (("6"
                                (ground)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil)
                                 ("3" (grind) nil nil)
                                 ("4" (grind) nil nil)
                                 ("5" (grind) nil nil)
                                 ("6" (grind) nil nil)
                                 ("7" (grind) nil nil)
                                 ("8" (grind) nil nil)
                                 ("9" (grind) nil nil)
                                 ("10" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep*)
      (("7" (rewrite "mark")
        (("7" (expand "mark" -)
          (("7" (rewrite "mvars" +)
            (("7" (inst?)
              (("7" (inst?) (("7" (inst?) (("7" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skeep*)
      (("8" (rewrite "mark")
        (("8" (rewrite "mvars")
          (("8" (expand "mark")
            (("8" (inst?) (("8" (inst?) (("8" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (lazy-grind) nil nil) ("12" (grind) nil nil)
     ("13" (skeep*)
      (("13" (rewrite "mark")
        (("13" (rewrite "mvars")
          (("13" (inst - "emptyset" "i")
            (("13" (inst?) (("13" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mvars def-decl "bool" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (singleton const-decl "(singleton?)" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (TRUE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (markvars_index formula-decl nil preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (every_nth formula-decl nil list_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (markvars_markX formula-decl nil preprocess nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (markvars_mark formula-decl nil preprocess nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (member const-decl "bool" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (mvars_release_set formula-decl nil preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (release_set def-decl "IExpression" preprocess nil)
    (difference const-decl "set" sets nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (N!1 skolem-const-decl "nat" preprocess nil))
   shostak))
 (pure_release_set 0
  (pure_release_set-1 nil 3693353022
   ("" (induct "X" :name "finite_set_induction")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand "release_set" +)
        (("2" (grind :if-match nil)
          (("1" (inst?) (("1" (grind) nil nil)) nil)
           ("2" (inst?) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (release_set def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (pure_mark 0
  (pure_mark-1 nil 3693352668
   ("" (induct-and-simplify "A" :rewrites "pure_release_set") nil nil)
   ((nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (pure_release_set formula-decl nil preprocess nil)
    (empty? const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (mark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak)))

