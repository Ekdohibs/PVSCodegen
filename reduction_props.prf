(reduction_props
 (decref_induction_TCC1 0
  (decref_induction_TCC1-1 nil 3700406650 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil))
   nil))
 (decref_induction_TCC2 0
  (decref_induction_TCC2-1 nil 3700406650
   ("" (skeep*)
    (("" (typepred "rS`store(r)`seq(i)") (("" (grind) nil nil)) nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_induction_TCC3 0
  (decref_induction_TCC3-1 nil 3700406650
   ("" (skeep* :preds? t)
    (("" (case "rS`domain(refindex(rS`store(r)`seq(i)))")
      (("1" (typepred "rS`count(refindex(rS`store(r)`seq(i)))")
        (("1" (rewrite -1)
          (("1" (split)
            (("1" (expand refcount)
              (("1" (use refcountStore_ref)
                (("1" (grind-with-ext) nil nil)) nil))
              nil)
             ("2" (expand refcount)
              (("2" (use refcountStore_update)
                (("2" (grind-with-ext) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil)
       ("2" (typepred "rS`store(r)`seq(i)") (("2" (grind) nil nil))
        nil)
       ("3" (propax) nil nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_induction 0
  (decref_induction-1 nil 3700487573
   ("" (skeep)
    (("" (measure-induct+ "allcountStore(rS)" ("rS"))
      (("" (skeep)
        (("" (generalize i i "upto(x!1`store(r)`length)" 1)
          (("" (induct i)
            (("1" (expand decref 1 :assert? nil)
              (("1" (propax) nil nil)) nil)
             ("2" (skeep)
              (("2" (expand decref 1 :assert? nil)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (lift-if)
                      (("1" (split)
                        (("1" (flatten)
                          (("1" (name-replace "rS" "x!1")
                            (("1"
                              (name "rS2" "rS
                        WITH [`store(r)`seq(jt) := nil,
                              `count(refindex(rS`store(r)`seq(jt)))
                                := rS`count(refindex(rS`store(r)`seq(jt)))
                                    - 1]")
                              (("1"
                                (replace -1)
                                (("1"
                                  (case "P(rS2)")
                                  (("1"
                                    (name
                                     "rS3"
                                     "decref(rS2, refindex(rS`store(r)`seq(jt)),
                      rS`store(refindex(rS`store(r)`seq(jt)))`length)")
                                    (("1"
                                      (replace -1)
                                      (("1"
                                        (case "P(rS3)")
                                        (("1"
                                          (typepred rS3)
                                          (("1"
                                            (inst -13 rS3)
                                            (("1"
                                              (inst -13 r jt)
                                              (("1"
                                                (split -13)
                                                (("1" (propax) nil nil)
                                                 ("2" (propax) nil nil)
                                                 ("3"
                                                  (case
                                                   "allcountStore(rS2) < allcountStore(rS)")
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (replace
                                                     -8
                                                     :dir
                                                     RL)
                                                    (("2"
                                                      (rewrite
                                                       allcountStore_update)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (hide-all-but
                                                         (1 -9))
                                                        (("2"
                                                          (grind-with-ext)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (inst -8 rS2)
                                          (("2"
                                            (inst
                                             -8
                                             "refindex(rS`store(r)`seq(jt))"
                                             "rS`store(refindex(rS`store(r)`seq(jt)))`length")
                                            (("2"
                                              (split -8)
                                              (("1" (grind) nil nil)
                                               ("2" (propax) nil nil)
                                               ("3"
                                                (replace -3 :dir RL)
                                                (("3"
                                                  (rewrite
                                                   allcountStore_update)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (hide-all-but
                                                     (1 -4))
                                                    (("2"
                                                      (grind-with-ext)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (inst -8 rS r jt)
                                    (("2"
                                      (split -8)
                                      (("1" (grind) nil nil)
                                       ("2" (propax) nil nil)
                                       ("3" (propax) nil nil)
                                       ("4" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (typepred rS)
                                (("2" (grind) nil nil))
                                nil)
                               ("3"
                                (delete 2)
                                (("3"
                                  (typepred
                                   "rS`count(refindex(rS`store(r)`seq(jt)))")
                                  (("1"
                                    (rewrite -1)
                                    (("1"
                                      (expand refcount)
                                      (("1"
                                        (split)
                                        (("1"
                                          (use refcountStore_ref)
                                          (("1"
                                            (split -1)
                                            (("1"
                                              (hide-all-but (1 -1))
                                              (("1" (grind) nil nil))
                                              nil)
                                             ("2"
                                              (hide-all-but (1 -1))
                                              (("2"
                                                (grind-with-ext)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (rewrite
                                           refcountStore_update)
                                          (("2"
                                            (hide-all-but (1 -1))
                                            (("2"
                                              (grind-with-ext)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (typepred "rS`store(r)`seq(jt)")
                                    (("2"
                                      (hide-all-but (1 -2 -3))
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("3" (propax) nil nil)
                                   ("4" (propax) nil nil))
                                  nil))
                                nil)
                               ("4" (grind) nil nil)
                               ("5" (propax) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (allcountStore const-decl "nat" rreduction nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (decref def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (allcountStore_update formula-decl nil rreduction nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (decref_preserves 0
  (decref_preserves-1 nil 3700406796
   ("" (skeep*)
    (("" (lemma decref_induction)
      ((""
        (inst -1
         "LAMBDA rS2: rS2`redex = rS`redex AND rS2`stack = rS`stack AND rS2`context = rS`context AND rS2`error = rS`error")
        (("" (split -1)
          (("1" (inst -1 rS r i) nil nil)
           ("2" (simplify) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((decref_induction formula-decl nil reduction_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (pred type-eq-decl nil defined_types nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (decref_preserves_jdg 0
  (decref_preserves_jdg-1 nil 3700418585
   ("" (skeep*) (("" (use decref_preserves) nil nil)) nil)
   ((upto nonempty-type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (decref_preserves formula-decl nil reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (translate_refs_TCC1 0
  (translate_refs_TCC1-1 nil 3699880315
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (translate_refs_TCC2 0
  (translate_refs_TCC2-1 nil 3699880315
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (translate_refs_TCC3 0
  (translate_refs_TCC3-1 nil 3699880315 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (translate_refs_TCC4 0
  (translate_refs_TCC4-2 "" 3700407020
   ("" (skeep* :preds? t)
    (("" (use pure_contextPure) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   shostak)
  (translate_refs_TCC4-1 nil 3699880315
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (use pure_contextPure) (("1" (grind) nil nil)) nil)
       ("2" (use pure_refs) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil))
   nil))
 (translate_refs_TCC5 0
  (translate_refs_TCC5-1 nil 3699880315 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (translate_refs_TCC6 0
  (translate_refs_TCC6-2 "" 3700407052 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   shostak)
  (translate_refs_TCC6-1 nil 3699880315
   ("" (skeep* :preds? t)
    (("" (split 1)
      (("1" (use pure_contextPure) (("1" (grind) nil nil)) nil)
       ("2" (use pure_refs) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (translate_refs_pure_TCC1 0
  (translate_refs_pure_TCC1-2 "" 3700416459
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pure? def-decl "bool" IL nil))
   shostak)
  (translate_refs_pure_TCC1-1 nil 3700317399
   ("" (skeep*)
    (("" (use pure_contextPure)
      (("" (use pure_refs) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pure? def-decl "bool" IL nil))
   nil))
 (translate_refs_pure_TCC2 0
  (translate_refs_pure_TCC2-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil))
 (translate_refs_pure_TCC3 0
  (translate_refs_pure_TCC3-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil))
 (translate_refs_pure_TCC4 0
  (translate_refs_pure_TCC4-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil))
 (translate_refs_pure_TCC5 0
  (translate_refs_pure_TCC5-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil))
 (translate_refs_pure_TCC6 0
  (translate_refs_pure_TCC6-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil))
 (translate_refs_pure_TCC7 0
  (translate_refs_pure_TCC7-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil))
 (translate_refs_pure_TCC8 0
  (translate_refs_pure_TCC8-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil))
 (translate_refs_pure_TCC9 0
  (translate_refs_pure_TCC9-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil))
 (translate_refs_pure_TCC10 0
  (translate_refs_pure_TCC10-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil))
 (translate_refs_pure_TCC11 0
  (translate_refs_pure_TCC11-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil))
 (translate_refs_pure 0
  (translate_refs_pure-1 nil 3700317400
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (delete 2)
      (("14" (skeep*)
        (("14" (use pure_contextPure)
          (("14" (use pure_refs) (("14" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (pure_refs formula-decl nil IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (refs def-decl "bool" IL nil))
   shostak))
 (translate_refs_contextPure_TCC1 0
  (translate_refs_contextPure_TCC1-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((contextPure? def-decl "bool" IL nil)) nil))
 (translate_refs_contextPure_TCC2 0
  (translate_refs_contextPure_TCC2-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (translate_refs_contextPure_TCC3 0
  (translate_refs_contextPure_TCC3-1 nil 3700406650
   ("" (skeep* :preds? t)
    (("" (lemma pure_contextPure)
      (("" (inst -1 C) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil))
   nil))
 (translate_refs_contextPure_TCC4 0
  (translate_refs_contextPure_TCC4-1 nil 3700406650
   ("" (skeep* :preds? t)
    (("" (grind) (("" (use translate_refs_pure) nil nil)) nil)) nil)
   ((contextPure? def-decl "bool" IL nil)
    (translate_refs_pure recursive-judgement-axiom nil reduction_props
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (translate_refs_contextPure_TCC5 0
  (translate_refs_contextPure_TCC5-1 nil 3700406650
   ("" (skeep* :preds? t)
    (("" (lemma pure_contextPure) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (translate_refs_contextPure_TCC6 0
  (translate_refs_contextPure_TCC6-1 nil 3700406650
   ("" (skeep* :preds? t)
    (("" (lemma pure_contextPure) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (translate_refs_contextPure_TCC7 0
  (translate_refs_contextPure_TCC7-1 nil 3700406650
   ("" (skeep* :preds? t)
    (("" (recursive-judgement-tcc)
      (("1" (use translate_refs_pure) nil nil)
       ("2" (use translate_refs_pure) nil nil))
      nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (translate_refs_pure recursive-judgement-axiom nil reduction_props
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (translate_refs_contextPure_TCC8 0
  (translate_refs_contextPure_TCC8-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (translate_refs_contextPure_TCC9 0
  (translate_refs_contextPure_TCC9-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((contextPure? def-decl "bool" IL nil)) nil))
 (translate_refs_contextPure_TCC10 0
  (translate_refs_contextPure_TCC10-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil))
 (translate_refs_contextPure_TCC11 0
  (translate_refs_contextPure_TCC11-1 nil 3700406650
   ("" (recursive-judgement-tcc) nil nil)
   ((contextPure? def-decl "bool" IL nil)) nil))
 (translate_refs_value 0
  (translate_refs_value-1 nil 3700406650
   ("" (judgement-tcc)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil))
    nil)
   ((translate_refs def-decl "IExpression" reduction_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil))
   nil))
 (translate_refs_atom 0
  (translate_refs_atom-1 nil 3700406650
   ("" (judgement-tcc)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil))
    nil)
   ((translate_refs def-decl "IExpression" reduction_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil))
   nil))
 (translate_refs_pure_eq 0
  (translate_refs_pure_eq-1 nil 3700496981
   ("" (induct-and-simplify A) nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (translate_refs_eq 0
  (translate_refs_eq-1 nil 3700416693
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil)
     ("5" (skeep* :preds? t)
      (("5" (expand translate_refs 1)
        (("5" (decompose-equality)
          (("1" (grind) nil nil)
           ("2" (rewrite -2)
            (("1" (use pure_contextPure) (("1" (grind) nil nil)) nil)
             ("2" (use pure_refs) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand translate_refs 1)
        (("6" (decompose-equality)
          (("1" (grind)
            (("1" (use pure_contextPure) (("1" (grind) nil nil)) nil))
            nil)
           ("2" (grind)
            (("2" (use pure_contextPure) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil))
    nil)
   ((ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pure_refs formula-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pure_contextPure formula-decl nil IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (translate_refs_refs 0
  (translate_refs_refs-1 nil 3700586867
   ("" (induct-and-simplify A) nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (stack_matches_TCC1 0
  (stack_matches_TCC1-1 nil 3699880315 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (stack_matches_TCC2 0
  (stack_matches_TCC2-2 "" 3700417085 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak)
  (stack_matches_TCC2-1 nil 3699880315
   ("" (skeep* :preds? t)
    (("" (typepred "S`seq(S`length -i-1)")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (store_matches_TCC1 0
  (store_matches_TCC1-2 "" 3700417113 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil))
   shostak)
  (store_matches_TCC1-1 nil 3699880315
   ("" (skeep* :preds? t)
    (("" (typepred "store(r)`seq(j)") (("" (grind) nil nil)) nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil))
 (state_matches_eq 0
  (state_matches_eq-1 nil 3700587734
   ("" (with-labels (skeep) ((stm treq obj)))
    (("" (expand state_matches)
      (("" (with-labels (flatten) ((err trr unm stam stom)))
        (("" (split)
          (("1" (propax) nil nil)
           ("2"
            (lemma translate_refs_eq
             (A "unmark(rS`redex)" translate translate translate2
              translate2))
            (("2" (split)
              (("1" (grind) nil nil)
               ("2" (use unmark_contextPure) nil nil)
               ("3" (skeep)
                (("3" (inst treq i)
                  (("1" (split)
                    (("1" (propax) nil nil)
                     ("2" (typepred "rS`count(i)")
                      (("2" (rewrite -1)
                        (("2" (expand refcount)
                          (("2" (expand refcountExpr)
                            (("2" (rewrite unmark_refs)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (typepred "rS`redex")
                    (("2" (rewrite unmark_refs) (("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (propax) nil nil)
           ("4" (expand stack_matches)
            (("4" (flatten)
              (("4" (split)
                (("1" (propax) nil nil)
                 ("2" (skeep)
                  (("2" (inst?)
                    (("2" (ground)
                      (("2"
                        (lemma translate_refs_eq
                         (A "rS`stack`seq(rS`stack`length - 1 - i)"
                          translate translate translate2 translate2))
                        (("2" (split)
                          (("1" (grind) nil nil)
                           ("2"
                            (typepred
                             "rS`stack`seq(rS`stack`length - 1 - i)")
                            (("2" (grind) nil nil)) nil)
                           ("3" (skeep)
                            (("3" (inst treq i_1)
                              (("1"
                                (split treq)
                                (("1" (propax) nil nil)
                                 ("2"
                                  (typepred "rS`count(i_1)")
                                  (("2"
                                    (rewrite -1)
                                    (("2"
                                      (expand refcount)
                                      (("2"
                                        (expand refcountStack)
                                        (("2"
                                          (lemma
                                           "count_elem[(value?)]")
                                          (("2"
                                            (inst?)
                                            (("2"
                                              (inst -1 "ref(i_1)")
                                              (("1"
                                                (ground)
                                                (("1"
                                                  (inst
                                                   1
                                                   "rS`stack`length - i - 1")
                                                  (("1"
                                                    (typepred
                                                     "rS`stack`seq(rS`stack`length - i - 1)")
                                                    (("1"
                                                      (grind-with-ext)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (typepred
                                 "rS`stack`seq(rS`stack`length - 1 - i)")
                                (("2"
                                  (typepred "rS`stack")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("5" (expand store_matches)
            (("5" (skeep)
              (("5" (inst stom r)
                (("5" (case-replace "translate2(r) = translate(r)")
                  (("1" (assert)
                    (("1" (ground)
                      (("1" (skeep)
                        (("1" (inst stom j)
                          (("1"
                            (lemma translate_refs_eq
                             (A "rS`store(r)`seq(j)" translate
                              translate translate2 translate2))
                            (("1" (split -1)
                              (("1" (grind) nil nil)
                               ("2"
                                (typepred "rS`store(r)`seq(j)")
                                (("2" (grind) nil nil))
                                nil)
                               ("3"
                                (skeep)
                                (("3"
                                  (inst treq i)
                                  (("1"
                                    (split treq)
                                    (("1" (propax) nil nil)
                                     ("2"
                                      (typepred "rS`count(i)")
                                      (("2"
                                        (rewrite -1)
                                        (("2"
                                          (expand refcount)
                                          (("2"
                                            (use refcountStore_ref)
                                            (("2"
                                              (split -1)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (typepred
                                                 "rS`store(r)`seq(j)")
                                                (("2"
                                                  (grind-with-ext)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (typepred "rS`store(r)`seq(j)")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst treq r) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state_matches const-decl "boolean" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure recursive-judgement-axiom nil preprocess nil)
    nil nil (NOT const-decl "[bool -> bool]" booleans nil)
    (unmark_refs formula-decl nil preprocess nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (refcountExpr const-decl "nat" rreduction nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_refs_eq formula-decl nil reduction_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (unmark def-decl "IExpression" preprocess nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (translate_refs_value application-judgement "(value?)"
     reduction_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (estate type-eq-decl nil reduction nil) nil nil
    (count_elem formula-decl nil finseq_theorems nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil) nil
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (bumpn const-decl "finite_set[nat]" IL nil) nil
    (union const-decl "set" sets nil) nil
    (OR const-decl "[bool, bool -> bool]" booleans nil) nil
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    nil (refcountStore_ref formula-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (match_domain 0
  (match_domain-1 nil 3700583978
   ("" (with-labels (skeep) ((ndr stm domr countr obj)))
    (("" (expand state_matches)
      (("" (with-labels (flatten) ((err trr unm stam stom)))
        (("" (typepred "rS`count(r)")
          (("" (rewrite -1)
            (("" (expand refcount)
              (("" (case "refcountExpr(rS`redex)(r) = 0")
                (("1" (case "refcountStack(rS`stack)(r) = 0")
                  (("1"
                    (case "refcountStore(rS`domain, rS`store)(r) = 0")
                    (("1" (grind) nil nil)
                     ("2" (expand refcountStore)
                      (("2" (expand allcount)
                        (("2" (rewrite sigma_zero)
                          (("2" (skeep)
                            (("2" (expand refcountArray)
                              (("2"
                                (rewrite count_none_zero)
                                (("2"
                                  (skeep)
                                  (("2"
                                    (expand store_matches)
                                    (("2"
                                      (inst stom r)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (typepred "rS`count(r)")
                                          (("2"
                                            (rewrite -1)
                                            (("2"
                                              (expand refcount)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand refcountStack)
                    (("2" (rewrite count_none_zero)
                      (("2" (skeep)
                        (("2" (expand stack_matches)
                          (("2" (with-labels (flatten) ((staml stamr)))
                            (("2"
                              (inst stamr "rS`stack`length - 1 - i")
                              (("1"
                                (simplify)
                                (("1"
                                  (typepred "eS`stack")
                                  (("1"
                                    (expand every)
                                    (("1"
                                      (inst -1 i)
                                      (("1"
                                        (replace staml)
                                        (("1"
                                          (simplify)
                                          (("1"
                                            (replace stamr :dir RL)
                                            (("1"
                                              (case-replace
                                               "rS`stack`seq(i) = ref(r)")
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (grind-with-ext)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (typepred i)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand noDanglingRefs?)
                                (("2"
                                  (inst ndr "rS`stack`length -1 - i")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand refcountExpr)
                  (("2" (ground)
                    (("2" (lift-if)
                      (("2" (ground)
                        (("2" (case "refs(eS`redex)(translate(r))")
                          (("1" (typepred "eS`redex")
                            (("1" (grind) nil nil)) nil)
                           ("2" (use translate_refs_refs)
                            (("2" (split -1)
                              (("1" (grind) nil nil)
                               ("2" (rewrite unmark_refs) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (translate_refs_value application-judgement "(value?)"
     reduction_props nil)
    (estate type-eq-decl nil reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (union const-decl "set" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refcountStore const-decl "nat" rreduction nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_none_zero formula-decl nil finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (sigma_zero formula-decl nil finite_set_theorems nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (refcountStack const-decl "nat" rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (translate_refs_refs formula-decl nil reduction_props nil)
    (unmark def-decl "IExpression" preprocess nil)
    (unmark_refs formula-decl nil preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (state_matches const-decl "boolean" reduction_props nil))
   shostak))
 (stack_stillmatch_TCC1 0
  (stack_stillmatch_TCC1-1 nil 3699975962 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (stack_stillmatch_TCC2 0
  (stack_stillmatch_TCC2-1 nil 3699975962 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (stack_stillmatch 0
  (stack_stillmatch-2 "" 3700417311
   ("" (skeep*)
    (("" (expand stack_matches)
      (("" (split)
        (("1" (assert) nil nil)
         ("2" (flatten)
          (("2" (skeep)
            (("2" (inst?)
              (("2" (inst?)
                (("2" (flatten)
                  (("2" (split)
                    (("1" (grind) nil nil)
                     ("2" (typepred "S2`seq(S2`length - 1 - i)")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_refs_value application-judgement "(value?)"
     reduction_props nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak)
  (stack_stillmatch-1 nil 3699979922
   ("" (skeep* :preds? t)
    (("" (simplify :let-reduce? t)
      (("" (skeep* :preds? t)
        (("" (expand stack_matches)
          (("" (split)
            (("1" (grind) nil nil)
             ("2" (skeep* :preds? t)
              (("2" (split)
                (("1" (grind) nil nil)
                 ("2" (inst -5 i)
                  (("2" (flatten)
                    (("2" (replace -6 :dir RL)
                      (("2" (replace -4 :dir RL)
                        (("2" (inst -9 i)
                          (("2" (flatten)
                            (("2" (replace -10 :dir RL)
                              (("2"
                                (lemma translate_refs_restrict)
                                (("2"
                                  (inst
                                   -1
                                   "rS`stack`seq(rS`stack`length - 1 - i)"
                                   "extend[nat, (rS`domain), bool, FALSE]
                          ({r: (rS`domain) | rS`count(r) > 0})"
                                   "eS`domain"
                                   "extend[nat, (rS2`domain), bool, FALSE]
                         ({r: (rS2`domain) | rS2`count(r) > 0})")
                                  (("1"
                                    (split -1)
                                    (("1"
                                      (rewrite -1)
                                      (("1"
                                        (case-replace
                                         "translate2 = lambda (i_1:
                                (extend[nat, (rS2`domain), bool, FALSE]
                                     ({r: (rS2`domain) |
                                       rS2`count(r) > 0}))):
                        translate(i_1)")
                                        (("1"
                                          (delete 2)
                                          (("1"
                                            (decompose-equality)
                                            (("1" (grind) nil nil)
                                             ("2" (grind) nil nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (delete 2)
                                      (("2"
                                        (skeep :preds? t)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (delete 2)
                                      (("3"
                                        (skeep*)
                                        (("3"
                                          (typepred "rS2`count(i_1)")
                                          (("1"
                                            (expand extend)
                                            (("1"
                                              (rewrite -1)
                                              (("1"
                                                (expand refcount)
                                                (("1"
                                                  (expand
                                                   refcountStack)
                                                  (("1"
                                                    (use
                                                     "count_elem[(value?)]")
                                                    (("1"
                                                      (typepred
                                                       "rS2`stack")
                                                      (("1"
                                                        (split -2)
                                                        (("1"
                                                          (case
                                                           "rS2`domain(i_1)")
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (typepred
                                                             "rS`stack`seq(rS`stack`length - 1 - i)")
                                                            (("1"
                                                              (typepred
                                                               "rS`stack")
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil)
                                                         ("3"
                                                          (typepred
                                                           "rS`stack`seq(rS`stack`length - 1 - i)")
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("4"
                                                          (typepred
                                                           "rS`stack`seq(rS`stack`length - 1 - i)")
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (typepred
                                             "rS`stack`seq(rS`stack`length - 1 - i)")
                                            (("1"
                                              (typepred "rS`stack")
                                              (("1" (grind) nil nil))
                                              nil)
                                             ("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("4"
                                      (typepred
                                       "rS`stack`seq(rS`stack`length - 1 - i)")
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (estate type-eq-decl nil reduction nil)
    (> const-decl "bool" reals nil) (extend const-decl "R" extend nil)
    (FALSE const-decl "bool" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (store_stillmatch_TCC1 0
  (store_stillmatch_TCC1-1 nil 3700406650 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (store_stillmatch_TCC2 0
  (store_stillmatch_TCC2-1 nil 3700406650 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (store_stillmatch 0
  (store_stillmatch-1 nil 3700419320
   ("" (skeep* :preds? t)
    (("" (expand store_matches)
      (("" (skeep* :preds? t)
        (("" (inst?)
          (("1" (inst?)
            (("1" (inst?)
              (("1" (assert)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (propax) nil nil) ("2" (grind) nil nil)
                     ("3" (skeep)
                      (("3" (inst?)
                        (("3" (typepred "rS`store(r)`seq(j)")
                          (("3" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((store_matches const-decl "boolean" reduction_props nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_refs_value application-judgement "(value?)"
     reduction_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (stack_subset_match 0
  (stack_subset_match-1 nil 3699982369
   ("" (skeep* :preds? t)
    (("" (expand stack_matches)
      (("" (flatten)
        (("" (split)
          (("1" (propax) nil nil)
           ("2" (skeep :preds? t)
            (("2" (inst?) (("2" (inst?) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil))
   shostak))
 (stack_subvar_match 0
  (stack_subvar_match-1 nil 3700491709
   (""
    (with-labels (skeep*)
     ((stk_eq ctx_eq depth1 depth2 vars_imp stam obj)))
    (("" (lemma stack_subset_match)
      ((""
        (inst -1 "rS`stack" "eS`stack" "union(cvars(rS2`redex),
                          bumpn(cvars(rS2`context), popDepth(rS2`redex)))"
         " union(cvars(rS`redex),
                          bumpn(cvars(rS`context), popDepth(rS`redex)))"
         translate)
        (("" (split)
          (("1" (grind) nil nil)
           ("2" (delete obj)
            (("2" (skeep* :preds? t)
              (("2" (expand union)
                (("2" (expand member)
                  (("2" (inst vars_imp i)
                    (("2" (rewrite cvars_vars)
                      (("2" (rewrite cvars_vars)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((stack_subset_match formula-decl nil reduction_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (estate type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (Stack type-eq-decl nil IL nil)
    (value? const-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (top_releases_ct_fill 0
  (top_releases_ct_fill-1 nil 3699899104
   ("" (induct K)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil))
    nil)
   ((IContext_induction formula-decl nil IL nil)
    (fill def-decl "IExpression" IL nil)
    (top_releases_ct def-decl "nat" reduction_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   shostak))
 (top_releases_build_redex 0
  (top_releases_build_redex-1 nil 3699900232
   ("" (induct-and-simplify A) nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (top_releases_ct def-decl "nat" reduction_props nil)
    (releaseRedex? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (top_releases_reduce 0
  (top_releases_reduce-1 nil 3699900446
   ("" (skeep* :preds? t)
    (("" (case "releaseRedex?(buildRedex(to_topstate(grS)`redex)`2)")
      (("1" (label is_release_redex -1)
        (("1" (expand releaseRedex?)
          (("1" (expand reduce)
            (("1" (expand pureLetRedex?)
              (("1"
                (expand*
                 (atom letRedex? updateRedex? lookupRedex?
                       pureIftRedex? iftRedex? applyRedex?))
                (("1"
                  (expand*
                   (letRedex? updateRedex? lookupRedex? pureIftRedex?
                    iftRedex? applyRedex? newintRedex? newrefRedex?))
                  (("1" (assert)
                    (("1" (expand popRedex?)
                      (("1" (lift-if)
                        (("1" (ground)
                          (("1" (grind) nil nil)
                           ("2" (expand releaseReduce)
                            (("2"
                              (case-replace
                               "top_releases_ct(grS`redex) = top_releases_ct(buildRedex(to_topstate(grS)`redex)`2)")
                              (("1"
                                (name-replace
                                 A
                                 "buildRedex(to_topstate(grS)`redex)`2")
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (hide-all-but 1)
                                (("2"
                                  (case-replace
                                   "top_releases_ct(grS`redex) = top_releases_ct(to_topstate(grS)`redex)")
                                  (("1"
                                    (typepred
                                     "buildRedex(to_topstate(grS)`redex)")
                                    (("1"
                                      (use top_releases_ct_fill)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (use top_releases_ct_fill)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma top_releases_build_redex)
        (("2" (inst -1 "to_topstate(grS)`redex")
          (("2" (flatten)
            (("2" (split -1)
              (("1" (propax) nil nil)
               ("2" (expand to_topstate)
                (("2" (rewrite top_releases_ct_fill) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((goodrstate type-eq-decl nil reduction_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (top_releases_ct def-decl "nat" reduction_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}"
     reduction_props nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (top_releases_ct_fill formula-decl nil reduction_props nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (pureRedex? const-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (reduce const-decl "rstate" rreduction nil)
    (top_releases_build_redex formula-decl nil reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (decref_stillmatch 0
  (decref_stillmatch-1 nil 3700419666
   ("" (skeep* :preds? t)
    (("" (lemma decref_induction)
      (("" (inst -1 "LAMBDA rS2: state_matches(eS, rS2)(translate)")
        (("" (split)
          (("1" (inst?) (("1" (prop) nil nil)) nil)
           ("2" (skolem 1 ("rS2" "r2" "i2"))
            (("2" (flatten)
              (("2" (hide-all-but (-1 -2 -3 1))
                (("2" (expand state_matches)
                  (("2" (flatten)
                    (("2" (split)
                      (("1" (propax) nil nil) ("2" (propax) nil nil)
                       ("3" (propax) nil nil) ("4" (propax) nil nil)
                       ("5" (expand store_matches)
                        (("5" (skeep :preds? t)
                          (("5" (inst?)
                            (("5" (case-replace "r!1 = r2")
                              (("1" (grind) nil nil)
                               ("2"
                                (simplify)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((decref_induction formula-decl nil reduction_props nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (translate_refs_value application-judgement "(value?)"
     reduction_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (estate type-eq-decl nil reduction nil)
    (pred type-eq-decl nil defined_types nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (releaseReduce_match_TCC1 0
  (releaseReduce_match_TCC1-1 nil 3700234159 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (releaseReduce_match 0
  (releaseReduce_match-6 "" 3700423366
   ("" (with-labels (skeep* :preds? t) ((err prr ndm arm stm obj)))
    (("" (expand releaseReduce)
      (("" (lift-if)
        (("" (with-labels (ground) ((rf obj) (rf obj)))
          (("1"
            (with-labels
             (case "index(rvar(grS`redex)) + popDepth(grS`redex) < grS`stack`length")
             (("index_sl")))
            (("1" (with-labels (ground) ((rf obj) (rf obj)))
              (("1" (expand state_matches?)
                (("1" (skeep)
                  (("1" (inst?)
                    (("1"
                      (with-labels (use decref_stillmatch)
                       ((dcimp) (ndrh) (cnth) (rdxh) (nilh) (sth)))
                      (("1" (split dcimp)
                        (("1" (propax) nil nil)
                         ("2" (delete obj)
                          (("2"
                            (with-labels
                             (name "rS2" "grS
                                                                                      WITH [`stack`seq
                                                                                                    (grS`stack`length - 1
                                                                                                     -
                                                                                                     index(rvar(grS`redex))
                                                                                                     -
                                                                                                     popDepth(grS`redex))
                                                                                              := nil,
                                                                                            `count
                                                                                              (refindex(grS`stack`seq
                                                                                                        (grS`stack`length - 1
                                                                                                         -
                                                                                                         index(rvar(grS`redex))
                                                                                                         -
                                                                                                         popDepth(grS`redex))))
                                                                                              := grS`count
                                                                                                     (refindex
                                                                                                      (grS`stack`seq
                                                                                                       (grS`stack`length - 1
                                                                                                        -
                                                                                                        index(rvar(grS`redex))
                                                                                                        -
                                                                                                        popDepth(grS`redex))))
                                                                                                  - 1,
                                                                                            `redex := rexpr(grS`redex)]")
                             ((rS2def)))
                            (("1" (replace -1)
                              (("1"
                                (expand state_matches)
                                (("1"
                                  (with-labels
                                   (flatten)
                                   ((esr trr unm stam stom)))
                                  (("1"
                                    (split dcimp)
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil)
                                     ("3" (grind) nil nil)
                                     ("4"
                                      (with-labels
                                       (lemma stack_stillmatch)
                                       ((ssm)))
                                      (("4"
                                        (inst
                                         ssm
                                         "grS`stack"
                                         "eS`stack"
                                         "rS2`stack"
                                         "union(cvars(rS2`redex),
                                                                        bumpn(cvars(rS2`context), popDepth(rS2`redex)))"
                                         "translate"
                                         "translate")
                                        (("4"
                                          (split ssm)
                                          (("1" (propax) nil nil)
                                           ("2" (grind) nil nil)
                                           ("3"
                                            (hide-all-but
                                             (ssm stam rS2def prr))
                                            (("3"
                                              (replace rS2def :dir RL)
                                              (("3"
                                                (simplify)
                                                (("3"
                                                  (with-labels
                                                   (lemma
                                                    stack_subset_match)
                                                   ((sbm)))
                                                  (("3"
                                                    (inst? sbm)
                                                    (("3"
                                                      (inst?
                                                       sbm
                                                       :where
                                                       stam)
                                                      (("3"
                                                        (split sbm)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (with-labels
                                                           (skeep
                                                            :preds?
                                                            t)
                                                           ((ih sbm)))
                                                          (("2"
                                                            (expand
                                                             union)
                                                            (("2"
                                                              (expand
                                                               member)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("4"
                                            (delete dcimp)
                                            (("4"
                                              (replace rS2def :dir RL)
                                              (("4"
                                                (simplify)
                                                (("4"
                                                  (with-labels
                                                   (skeep :preds? t)
                                                   ((ih ssm)))
                                                  (("4"
                                                    (lift-if)
                                                    (("4"
                                                      (case-replace
                                                       "i = index(rvar(grS`redex)) + popDepth(grS`redex)")
                                                      (("1"
                                                        (simplify)
                                                        (("1"
                                                          (replace
                                                           rS2def
                                                           :dir
                                                           RL)
                                                          (("1"
                                                            (simplify)
                                                            (("1"
                                                              (with-labels
                                                               (typepred
                                                                "grS`redex")
                                                               ((hrefs
                                                                 hvars
                                                                 hcvars
                                                                 hpop
                                                                 hcp
                                                                 hmark)))
                                                              (("1"
                                                                (expand
                                                                 bumpn)
                                                                (("1"
                                                                  (expand
                                                                   union)
                                                                  (("1"
                                                                    (expand
                                                                     member)
                                                                    (("1"
                                                                      (apply-eta
                                                                       "grS`redex"
                                                                       "(release?)")
                                                                      (("1"
                                                                        (replace
                                                                         -1
                                                                         :dir
                                                                         RL)
                                                                        (("1"
                                                                          (simplify)
                                                                          (("1"
                                                                            (expand
                                                                             mark)
                                                                            (("1"
                                                                              (with-labels
                                                                               (decompose-equality
                                                                                hmark)
                                                                               ((hmark1
                                                                                 hmark2)))
                                                                              (("1"
                                                                                (expand
                                                                                 allReleaseMarked?)
                                                                                (("1"
                                                                                  (expand
                                                                                   markv)
                                                                                  (("1"
                                                                                    (replace
                                                                                     hmark1
                                                                                     :dir
                                                                                     RL)
                                                                                    (("1"
                                                                                      (flatten
                                                                                       arm)
                                                                                      (("1"
                                                                                        (lift-if
                                                                                         arm)
                                                                                        (("1"
                                                                                          (simplify)
                                                                                          (("1"
                                                                                            (split
                                                                                             arm)
                                                                                            (("1"
                                                                                              (propax)
                                                                                              nil
                                                                                              nil)
                                                                                             ("2"
                                                                                              (simplify)
                                                                                              (("2"
                                                                                                (hide-all-but
                                                                                                 (arm
                                                                                                  ih
                                                                                                  prr))
                                                                                                (("2"
                                                                                                  (expand
                                                                                                   popDepth
                                                                                                   ih
                                                                                                   (1
                                                                                                    2
                                                                                                    4))
                                                                                                  (("2"
                                                                                                    (expand
                                                                                                     union)
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       member)
                                                                                                      (("2"
                                                                                                        (rewrite
                                                                                                         cvars_vars)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("5"
                                      (lemma store_stillmatch)
                                      (("5"
                                        (inst?)
                                        (("5"
                                          (inst? :where stom)
                                          (("5"
                                            (split -1)
                                            (("1" (propax) nil nil)
                                             ("2" (grind) nil nil)
                                             ("3"
                                              (skeep)
                                              (("3"
                                                (case
                                                 "rS2`count(r) <= 0")
                                                (("1" (grind) nil nil)
                                                 ("2"
                                                  (replace
                                                   rS2def
                                                   :dir
                                                   RL)
                                                  (("2"
                                                    (simplify)
                                                    (("2"
                                                      (lift-if)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("4" (grind) nil nil)
                                             ("5" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (delete dcimp)
                              (("2"
                                (lemma refcount_stack_update)
                                (("2"
                                  (inst?)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (split)
                                      (("1"
                                        (ground)
                                        (("1" (grind) nil nil))
                                        nil)
                                       ("2" (grind-with-ext) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (typepred "grS`stack")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (use release_reduce_redex_correct)
                              (("3" (grind) nil nil)) nil)
                             ("4" (use stack_update_correct)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("5" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete obj)
                        (("2" (expand noDanglingRefs?)
                          (("2" (skeep)
                            (("2" (inst ndm i)
                              (("2"
                                (split ndm)
                                (("1"
                                  (apply-eta "grS`redex" "(release?)")
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil)
                                 ("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (use refcount_stack_update)
                        (("3" (split -1)
                          (("1" (ground) (("1" (grind) nil nil)) nil)
                           ("2" (hide-all-but (1 rf))
                            (("2" (grind-with-ext) nil nil)) nil))
                          nil))
                        nil)
                       ("4" (use release_reduce_redex_correct)
                        (("4" (split)
                          (("1" (propax) nil nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil)
                       ("5" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete obj)
              (("2" (typepred "grS`redex")
                (("2" (inst?)
                  (("2" (inst?) (("2" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil)
           ("2" (expand state_matches?)
            (("2" (skeep)
              (("2" (inst?)
                (("2" (expand state_matches)
                  (("2" (flatten)
                    (("2" (split obj)
                      (("1" (propax) nil nil)
                       ("2" (apply-eta "grS`redex" "(release?)")
                        (("2" (grind) nil nil)) nil)
                       ("3" (propax) nil nil)
                       ("4" (lemma stack_subset_match)
                        (("4" (inst? -1)
                          (("4" (inst? -1 :where stm)
                            (("4" (split -1)
                              (("1" (propax) nil nil)
                               ("2"
                                (skeep :preds? t)
                                (("2"
                                  (apply-eta "grS`redex" "(release?)")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("5" (lemma store_stillmatch)
                        (("5" (inst? -1)
                          (("1" (inst? -1 :where stm)
                            (("1" (split -1)
                              (("1" (propax) nil nil)
                               ("2" (assert) nil nil)
                               ("3"
                                (assert)
                                (("3" (grind) nil nil))
                                nil)
                               ("4" (grind) nil nil)
                               ("5" (propax) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil)
                           ("3" (use release_reduce_redex_correct)
                            (("3" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}"
     reduction_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref_stillmatch formula-decl nil reduction_props nil)
    (estate type-eq-decl nil reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (stack_update_correct formula-decl nil rreduction nil)
    (release_reduce_redex_correct formula-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (refcount_stack_update formula-decl nil rreduction nil)
    (store_stillmatch formula-decl nil reduction_props nil)
    (stack_stillmatch formula-decl nil reduction_props nil)
    (stack_subset_match formula-decl nil reduction_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (IExpression_release_eta formula-decl nil IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (cvars_vars formula-decl nil preprocess nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (unmark def-decl "IExpression" preprocess nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (state_matches const-decl "boolean" reduction_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (translate_refs_value application-judgement "(value?)"
     reduction_props nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak)
  (releaseReduce_match-5 "" 3700422764
   ("" (with-labels (skeep* :preds? t) ((err prr ndm arm stm obj)))
    (("" (expand releaseReduce)
      (("" (lift-if)
        (("" (with-labels (ground) ((rf obj) (rf obj)))
          (("1"
            (with-labels
             (case "index(rvar(grS`redex)) + popDepth(grS`redex) < grS`stack`length")
             (("index_sl")))
            (("1" (with-labels (ground) ((rf obj) (rf obj)))
              (("1" (expand state_matches?)
                (("1" (skeep)
                  (("1" (inst?)
                    (("1"
                      (with-labels (use decref_stillmatch)
                       ((dcimp) (ndrh) (cnth) (rdxh) (nilh) (sth)))
                      (("1" (split dcimp)
                        (("1" (propax) nil nil)
                         ("2" (delete obj)
                          (("2"
                            (with-labels
                             (name "rS2" "grS
                                                                      WITH [`stack`seq
                                                                                    (grS`stack`length - 1
                                                                                     -
                                                                                     index(rvar(grS`redex))
                                                                                     -
                                                                                     popDepth(grS`redex))
                                                                              := nil,
                                                                            `count
                                                                              (refindex(grS`stack`seq
                                                                                        (grS`stack`length - 1
                                                                                         -
                                                                                         index(rvar(grS`redex))
                                                                                         -
                                                                                         popDepth(grS`redex))))
                                                                              := grS`count
                                                                                     (refindex
                                                                                      (grS`stack`seq
                                                                                       (grS`stack`length - 1
                                                                                        -
                                                                                        index(rvar(grS`redex))
                                                                                        -
                                                                                        popDepth(grS`redex))))
                                                                                  - 1,
                                                                            `redex := rexpr(grS`redex)]")
                             ((rS2def)))
                            (("1" (replace -1)
                              (("1"
                                (expand state_matches)
                                (("1"
                                  (with-labels
                                   (flatten)
                                   ((esr trr unm stam stom)))
                                  (("1"
                                    (split dcimp)
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil)
                                     ("3" (grind) nil nil)
                                     ("4"
                                      (with-labels
                                       (lemma stack_stillmatch)
                                       ((ssm)))
                                      (("4"
                                        (inst
                                         ssm
                                         "grS`stack"
                                         "eS`stack"
                                         "rS2`stack"
                                         "union(cvars(rS2`redex),
                                                          bumpn(cvars(rS2`context), popDepth(rS2`redex)))"
                                         "translate"
                                         "translate")
                                        (("4"
                                          (split ssm)
                                          (("1" (propax) nil nil)
                                           ("2" (grind) nil nil)
                                           ("3"
                                            (hide-all-but
                                             (ssm stam rS2def prr))
                                            (("3"
                                              (replace rS2def :dir RL)
                                              (("3"
                                                (simplify)
                                                (("3"
                                                  (with-labels
                                                   (lemma
                                                    stack_subset_match)
                                                   ((sbm)))
                                                  (("3"
                                                    (inst? sbm)
                                                    (("3"
                                                      (inst?
                                                       sbm
                                                       :where
                                                       stam)
                                                      (("3"
                                                        (split sbm)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (with-labels
                                                           (skeep
                                                            :preds?
                                                            t)
                                                           ((ih sbm)))
                                                          (("2"
                                                            (expand
                                                             union)
                                                            (("2"
                                                              (expand
                                                               member)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("4"
                                            (delete dcimp)
                                            (("4"
                                              (replace rS2def :dir RL)
                                              (("4"
                                                (simplify)
                                                (("4"
                                                  (with-labels
                                                   (skeep :preds? t)
                                                   ((ih ssm)))
                                                  (("4"
                                                    (lift-if)
                                                    (("4"
                                                      (case-replace
                                                       "i = index(rvar(grS`redex)) + popDepth(grS`redex)")
                                                      (("1"
                                                        (simplify)
                                                        (("1"
                                                          (replace
                                                           rS2def
                                                           :dir
                                                           RL)
                                                          (("1"
                                                            (simplify)
                                                            (("1"
                                                              (with-labels
                                                               (typepred
                                                                "grS`redex")
                                                               ((hrefs
                                                                 hvars
                                                                 hcvars
                                                                 hpop
                                                                 hcp
                                                                 hmark)))
                                                              (("1"
                                                                (rewrite
                                                                 purePopDepth)
                                                                (("1"
                                                                  (rewrite
                                                                   purePopDepth)
                                                                  (("1"
                                                                    (expand
                                                                     bumpn)
                                                                    (("1"
                                                                      (expand
                                                                       union)
                                                                      (("1"
                                                                        (expand
                                                                         member)
                                                                        (("1"
                                                                          (apply-eta
                                                                           "grS`redex"
                                                                           "(release?)")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :dir
                                                                             RL)
                                                                            (("1"
                                                                              (simplify)
                                                                              (("1"
                                                                                (expand
                                                                                 mark)
                                                                                (("1"
                                                                                  (with-labels
                                                                                   (decompose-equality
                                                                                    hmark)
                                                                                   ((hmark1
                                                                                     hmark2)))
                                                                                  (("1"
                                                                                    (expand
                                                                                     allReleaseMarked?)
                                                                                    (("1"
                                                                                      (expand
                                                                                       markv)
                                                                                      (("1"
                                                                                        (replace
                                                                                         hmark1
                                                                                         :dir
                                                                                         RL)
                                                                                        (("1"
                                                                                          (flatten
                                                                                           arm)
                                                                                          (("1"
                                                                                            (lift-if
                                                                                             arm)
                                                                                            (("1"
                                                                                              (simplify)
                                                                                              (("1"
                                                                                                (split
                                                                                                 arm)
                                                                                                (("1"
                                                                                                  (propax)
                                                                                                  nil
                                                                                                  nil)
                                                                                                 ("2"
                                                                                                  (simplify)
                                                                                                  (("2"
                                                                                                    (hide-all-but
                                                                                                     (arm
                                                                                                      ih
                                                                                                      prr))
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       union)
                                                                                                      (("2"
                                                                                                        (expand
                                                                                                         member)
                                                                                                        (("2"
                                                                                                          (rewrite
                                                                                                           cvars_vars)
                                                                                                          (("2"
                                                                                                            (expand
                                                                                                             pureReleaseRedex?)
                                                                                                            (("2"
                                                                                                              (expand
                                                                                                               releaseRedex?)
                                                                                                              (("2"
                                                                                                                (postpone)
                                                                                                                nil
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (postpone)
                                                                    nil
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (postpone)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("5" (postpone) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (delete dcimp)
                              (("2"
                                (case
                                 "grS`domain(refindex(grS`stack`seq
                        (grS`stack`length - 1 - index(rvar(grS`redex)) -
                          popDepth(grS`redex))))")
                                (("1"
                                  (typepred
                                   "grS`count
           (refindex(grS`stack`seq
                         (grS`stack`length - 1 - index(rvar(grS`redex)) -
                           popDepth(grS`redex))))")
                                  (("1"
                                    (rewrite -1)
                                    (("1"
                                      (expand refcount)
                                      (("1"
                                        (split)
                                        (("1" (postpone) nil nil)
                                         ("2" (postpone) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (propax) nil nil))
                                  nil)
                                 ("2" (postpone) nil nil))
                                nil))
                              nil)
                             ("3" (postpone) nil nil)
                             ("4" (postpone) nil nil)
                             ("5" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (postpone) nil nil)
                       ("3" (postpone) nil nil)
                       ("4" (postpone) nil nil) ("5" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (postpone) nil nil))
            nil)
           ("2" (expand state_matches?)
            (("2" (skeep)
              (("2" (inst?)
                (("2" (expand state_matches)
                  (("2" (flatten)
                    (("2" (split obj)
                      (("1" (propax) nil nil) ("2" (postpone) nil nil)
                       ("3" (propax) nil nil)
                       ("4" (lemma stack_subset_match)
                        (("4" (inst? -1)
                          (("4" (inst? -1 :where stm)
                            (("4" (split -1)
                              (("1" (propax) nil nil)
                               ("2"
                                (skeep :preds? t)
                                (("2"
                                  (apply-eta "grS`redex" "(release?)")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("5" (lemma store_stillmatch)
                        (("5" (inst? -1)
                          (("1" (inst? -1 :where stm)
                            (("1" (split -1)
                              (("1" (propax) nil nil)
                               ("2" (assert) nil nil)
                               ("3"
                                (assert)
                                (("3" (grind) nil nil))
                                nil)
                               ("4" (grind) nil nil)
                               ("5" (propax) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil)
                           ("3" (postpone) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (releaseReduce_match-4 "" 3700310976
   ("" (with-labels (skeep* :preds? t) ((err prr ndm arm stm obj)))
    (("" (expand releaseReduce)
      (("" (lift-if)
        (("" (with-labels (ground) ((rf obj) (rf obj)))
          (("1"
            (with-labels
             (case "index(rvar(grS`redex)) + popDepth(grS`redex) < grS`stack`length")
             (("index_sl")))
            (("1" (with-labels (ground) ((rf obj) (rf obj)))
              (("1"
                (with-labels (use decref_match)
                 ((dcimp) (ndrh) (cnth) (rdxh) (nilh) (sth)))
                (("1" (split dcimp)
                  (("1" (propax) nil nil)
                   ("2" (delete obj)
                    (("2"
                      (with-labels
                       (name "rS2" "grS
                                                      WITH [`stack`seq
                                                                    (grS`stack`length - 1
                                                                     -
                                                                     index(rvar(grS`redex))
                                                                     -
                                                                     popDepth(grS`redex))
                                                              := nil,
                                                            `count
                                                              (refindex(grS`stack`seq
                                                                        (grS`stack`length - 1
                                                                         -
                                                                         index(rvar(grS`redex))
                                                                         -
                                                                         popDepth(grS`redex))))
                                                              := grS`count
                                                                     (refindex
                                                                      (grS`stack`seq
                                                                       (grS`stack`length - 1
                                                                        -
                                                                        index(rvar(grS`redex))
                                                                        -
                                                                        popDepth(grS`redex))))
                                                                  - 1,
                                                            `redex := rexpr(grS`redex)]")
                       ((rS2def)))
                      (("1" (replace -1)
                        (("1" (expand state_matches?)
                          (("1" (skeep)
                            (("1"
                              (inst dcimp
                               "LAMBDA (r: (rS2`domain) | rS2`count(r) > 0): translate(r)")
                              (("1"
                                (expand state_matches)
                                (("1"
                                  (with-labels
                                   (flatten)
                                   ((esr trr unm stam stom)))
                                  (("1"
                                    (split dcimp)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (replace trr :dir RL)
                                      (("2"
                                        (lemma
                                         translate_refs_restrict2)
                                        (("2"
                                          (inst
                                           -1
                                           "unmark(grS`redex)"
                                           "extend[nat, (grS`domain), bool, FALSE]
                                          ({r: (grS`domain) | grS`count(r) > 0})"
                                           "eS`domain"
                                           "extend[nat, (rS2`domain), bool, FALSE]
                                         ({r: (rS2`domain) | rS2`count(r) > 0})"
                                           _
                                           _)
                                          (("2"
                                            (inst? -1)
                                            (("2"
                                              (inst? -1)
                                              (("1"
                                                (split -1)
                                                (("1" (grind) nil nil)
                                                 ("2"
                                                  (delete dcimp)
                                                  (("2"
                                                    (hide-all-but
                                                     (1 rS2def))
                                                    (("2"
                                                      (skeep*
                                                       :preds?
                                                       t)
                                                      (("2"
                                                        (replace
                                                         rS2def
                                                         :dir
                                                         RL)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (delete dcimp)
                                                  (("3"
                                                    (skeep*)
                                                    (("3"
                                                      (typepred
                                                       "rS2`redex")
                                                      (("3"
                                                        (rewrite
                                                         unmark_refs)
                                                        (("3"
                                                          (inst -1 i)
                                                          (("3"
                                                            (typepred
                                                             "rS2`count(i)")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("4"
                                                  (rewrite
                                                   unmark_contextPure)
                                                  nil
                                                  nil)
                                                 ("5" (grind) nil nil))
                                                nil)
                                               ("2" (grind) nil nil)
                                               ("3"
                                                (skeep* :preds? t)
                                                (("3"
                                                  (replace
                                                   rS2def
                                                   :dir
                                                   RL)
                                                  (("3"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3" (grind) nil nil)
                                     ("4"
                                      (with-labels
                                       (lemma stack_stillmatch)
                                       ((ssm)))
                                      (("4"
                                        (inst
                                         ssm
                                         "union(cvars(rS2`redex),
                                          bumpn(cvars(rS2`context), popDepth(rS2`redex)))"
                                         eS
                                         grS
                                         rS2)
                                        (("4"
                                          (simplify :let-reduce? t)
                                          (("4"
                                            (inst? ssm)
                                            (("1"
                                              (inst ssm translate)
                                              (("1"
                                                (split ssm)
                                                (("1" (propax) nil nil)
                                                 ("2" (grind) nil nil)
                                                 ("3" (grind) nil nil)
                                                 ("4"
                                                  (delete dcimp)
                                                  (("4"
                                                    (with-labels
                                                     (skeep :preds? t)
                                                     ((ih ssm)))
                                                    (("4"
                                                      (expand union)
                                                      (("4"
                                                        (expand member)
                                                        (("4"
                                                          (with-labels
                                                           (typepred
                                                            "grS`redex")
                                                           ((hrefs
                                                             hvars
                                                             hcvars
                                                             hpop
                                                             hcp
                                                             hmark)))
                                                          (("4"
                                                            (rewrite
                                                             rS2def
                                                             :dir
                                                             RL)
                                                            (("4"
                                                              (simplify)
                                                              (("4"
                                                                (delete
                                                                 trr
                                                                 unm
                                                                 stom)
                                                                (("4"
                                                                  (split
                                                                   ssm)
                                                                  (("1"
                                                                    (split
                                                                     ih)
                                                                    (("1"
                                                                      (lemma
                                                                       cvars_vars)
                                                                      (("1"
                                                                        (inst
                                                                         -1
                                                                         "grS`redex"
                                                                         "i - popDepth(grS`redex)")
                                                                        (("1"
                                                                          (apply-eta
                                                                           "grS`redex"
                                                                           "(release?)")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :dir
                                                                             RL)
                                                                            (("1"
                                                                              (grind)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (expand
                                                                       bumpn)
                                                                      (("2"
                                                                        (lemma
                                                                         cvars_vars_ctx)
                                                                        (("2"
                                                                          (inst
                                                                           -1
                                                                           "grS`context"
                                                                           "i - popDepth(grS`redex) - popDepth(grS`context)")
                                                                          (("1"
                                                                            (apply-eta
                                                                             "grS`redex"
                                                                             "(release?)")
                                                                            (("1"
                                                                              (replace
                                                                               -1
                                                                               :dir
                                                                               RL)
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (lift-if)
                                                                    (("2"
                                                                      (split
                                                                       ssm)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (apply-eta
                                                                           "grS`redex"
                                                                           "(release?)")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :dir
                                                                             RL)
                                                                            (("1"
                                                                              (expand
                                                                               mark
                                                                               hmark)
                                                                              (("1"
                                                                                (with-labels
                                                                                 (decompose-equality
                                                                                  hmark)
                                                                                 ((hmark1
                                                                                   hmark2)))
                                                                                (("1"
                                                                                  (expand
                                                                                   allReleaseMarked?)
                                                                                  (("1"
                                                                                    (simplify)
                                                                                    (("1"
                                                                                      (expand
                                                                                       markv)
                                                                                      (("1"
                                                                                        (replace
                                                                                         hmark1
                                                                                         :dir
                                                                                         RL)
                                                                                        (("1"
                                                                                          (flatten
                                                                                           arm)
                                                                                          (("1"
                                                                                            (lift-if
                                                                                             arm)
                                                                                            (("1"
                                                                                              (simplify)
                                                                                              (("1"
                                                                                                (split
                                                                                                 arm)
                                                                                                (("1"
                                                                                                  (propax)
                                                                                                  nil
                                                                                                  nil)
                                                                                                 ("2"
                                                                                                  (expand
                                                                                                   popDepth
                                                                                                   ssm)
                                                                                                  (("2"
                                                                                                    (simplify)
                                                                                                    (("2"
                                                                                                      (case-replace
                                                                                                       "i = index(rvar(grS`redex)) + popDepth(rexpr(grS`redex))")
                                                                                                      (("1"
                                                                                                        (hide-all-but
                                                                                                         (ih
                                                                                                          arm))
                                                                                                        (("1"
                                                                                                          (expand
                                                                                                           bumpn)
                                                                                                          (("1"
                                                                                                            (expand
                                                                                                             union)
                                                                                                            (("1"
                                                                                                              (expand
                                                                                                               member)
                                                                                                              (("1"
                                                                                                                (rewrite
                                                                                                                 cvars_vars)
                                                                                                                nil
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil)
                                                                                                       ("2"
                                                                                                        (grind)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (propax)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("5"
                                                  (delete dcimp)
                                                  (("5"
                                                    (skeep)
                                                    (("5"
                                                      (case
                                                       "rS2`count(r) <= 0")
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (replace
                                                         rS2def
                                                         :dir
                                                         RL)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("6"
                                                  (delete dcimp)
                                                  (("6"
                                                    (replace
                                                     rS2def
                                                     :dir
                                                     RL)
                                                    (("6"
                                                      (simplify)
                                                      (("6"
                                                        (hide-all-but
                                                         (ssm stam))
                                                        (("6"
                                                          (lemma
                                                           stack_subset_match)
                                                          (("6"
                                                            (postpone)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("7" (grind) nil nil))
                                                nil))
                                              nil)
                                             ("2" (grind) nil nil)
                                             ("3"
                                              (skeep* :preds? t)
                                              (("3"
                                                (replace
                                                 rS2def
                                                 :dir
                                                 RL)
                                                (("3" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("5"
                                      (expand store_matches)
                                      (("5"
                                        (skeep)
                                        (("5"
                                          (inst stom r_2)
                                          (("1"
                                            (split dcimp)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (skeep)
                                              (("2"
                                                (with-labels
                                                 (lemma
                                                  translate_refs_restrict)
                                                 ((tsr)))
                                                (("2"
                                                  (inst
                                                   tsr
                                                   "rS2`store(r_2)`seq(j)"
                                                   _
                                                   _
                                                   _)
                                                  (("2"
                                                    (inst
                                                     tsr
                                                     "extend[nat, (grS`domain), bool, FALSE]
                                                                   ({r: (grS`domain) | grS`count(r) > 0})"
                                                     "eS`domain"
                                                     "extend[nat, (rS2`domain), bool, FALSE]
                                                                   ({r: (rS2`domain) | rS2`count(r) > 0})")
                                                    (("2"
                                                      (split tsr)
                                                      (("1"
                                                        (inst
                                                         tsr
                                                         translate)
                                                        (("1"
                                                          (case-replace
                                                           "(lambda (i:
                                                                            (extend[nat, (rS2`domain), bool, FALSE]
                                                                                 ({r: (rS2`domain) |
                                                                                   rS2`count(r) > 0}))):
                                                                    translate(i)) =  lambda (r: (rS2`domain) | rS2`count(r) > 0):
                                                                   translate(r)")
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (delete
                                                             dcimp)
                                                            (("2"
                                                              (decompose-equality)
                                                              (("1"
                                                                (replace
                                                                 rS2def
                                                                 :dir
                                                                 RL)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (skeep*
                                                                 :preds?
                                                                 t)
                                                                (("2"
                                                                  (replace
                                                                   rS2def
                                                                   :dir
                                                                   RL)
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("3"
                                                                (skeep*
                                                                 :preds?
                                                                 t)
                                                                (("3"
                                                                  (replace
                                                                   rS2def
                                                                   :dir
                                                                   RL)
                                                                  (("3"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (replace
                                                             rS2def
                                                             :dir
                                                             RL)
                                                            (("3"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("4"
                                                            (skeep*
                                                             :preds?
                                                             t)
                                                            (("4"
                                                              (replace
                                                               rS2def
                                                               :dir
                                                               RL)
                                                              (("4"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("5"
                                                            (skeep*
                                                             :preds?
                                                             t)
                                                            (("5"
                                                              (replace
                                                               rS2def
                                                               :dir
                                                               RL)
                                                              (("5"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (skeep*
                                                         :preds?
                                                         t)
                                                        (("2"
                                                          (replace
                                                           rS2def
                                                           :dir
                                                           RL)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (skeep*)
                                                        (("3"
                                                          (typepred
                                                           "rS2`store(r_2)`seq(j)")
                                                          (("3"
                                                            (typepred
                                                             "rS2`count(i)")
                                                            (("1"
                                                              (expand
                                                               refcount)
                                                              (("1"
                                                                (use
                                                                 refcountStore_ref)
                                                                (("1"
                                                                  (hide-all-but
                                                                   (1
                                                                    -1
                                                                    -2
                                                                    -3
                                                                    -4
                                                                    tsr))
                                                                  (("1"
                                                                    (grind-with-ext)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("4"
                                                        (typepred
                                                         "rS2`store(r_2)`seq(j)")
                                                        (("4"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (typepred r_2)
                                            (("2"
                                              (replace rS2def :dir RL)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skeep* :preds? t)
                                (("2"
                                  (replace rS2def :dir RL)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete dcimp)
                        (("2" (lemma refcount_stack_update)
                          (("2"
                            (inst -1 grS
                             "grS`stack`length - 1 - index(rvar(grS`redex)) -
                             popDepth(grS`redex)"
                             "refindex(grS`stack`seq(grS`stack`length - 1 - index(rvar(grS`redex)) - popDepth(grS`redex)))")
                            (("1" (split -1)
                              (("1"
                                (flatten)
                                (("1"
                                  (split)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (replace -2)
                                    (("2"
                                      (expand refcount)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind-with-ext) nil nil))
                              nil)
                             ("2" (typepred "grS`stack")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("3" (delete dcimp)
                        (("3"
                          (with-labels (typepred "grS`redex")
                           ((hrefs hvars hcvars hpop hcp hmark)))
                          (("3" (split rS2def)
                            (("1" (skeep)
                              (("1"
                                (inst hrefs i)
                                (("1" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil)
                             ("3" (grind) nil nil)
                             ("4" (grind) nil nil)
                             ("5" (grind) nil nil)
                             ("6" (apply-eta "grS`redex" "(release?)")
                              (("6"
                                (replace -1 :dir RL)
                                (("6"
                                  (expand mark hmark)
                                  (("6"
                                    (decompose-equality hmark)
                                    (("6"
                                      (simplify)
                                      (("6" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (delete dcimp)
                        (("4" (typepred "grS`stack")
                          (("4" (expand every)
                            (("4" (skeep)
                              (("4"
                                (inst -1 i)
                                (("4" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("5" (delete dcimp) (("5" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete obj)
                  (("2" (expand noDanglingRefs?)
                    (("2" (skeep)
                      (("2" (inst ndm i)
                        (("2" (ground)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (delete obj)
                  (("3"
                    (typepred "grS`count
                           (refindex(grS`stack`seq
                                         (grS`stack`length - 1 - index(rvar(grS`redex)) -
                                           popDepth(grS`redex))))")
                    (("1" (rewrite -1)
                      (("1" (expand refcount)
                        (("1" (split cnth)
                          (("1" (expand refcountStack)
                            (("1" (use "count_elem[(value?)]")
                              (("1"
                                (split -1)
                                (("1" (grind) nil nil)
                                 ("2" (inst?) nil nil)
                                 ("3" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand refcountStack)
                            (("2" (rewrite count_update)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "grS`stack")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("4" (delete obj)
                  (("4"
                    (with-labels (typepred "grS`redex")
                     ((hrefs hvars hcvars hpop hcp hmark)))
                    (("4" (split rdxh)
                      (("1" (skeep)
                        (("1" (inst hrefs i) (("1" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil) ("3" (grind) nil nil)
                       ("4" (grind) nil nil) ("5" (grind) nil nil)
                       ("6" (apply-eta "grS`redex" "(release?)")
                        (("6" (replace -1 :dir RL)
                          (("6" (expand mark hmark)
                            (("6" (decompose-equality hmark)
                              (("6"
                                (simplify)
                                (("6" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("5" (grind) nil nil))
                nil))
              nil)
             ("2" (delete obj)
              (("2" (typepred "grS`redex")
                (("2" (inst -2 "index(rvar(grS`redex))")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (expand state_matches?)
            (("2" (skeep)
              (("2" (inst?)
                (("2" (expand state_matches)
                  (("2"
                    (with-labels (flatten) ((esr trr unm stam stom)))
                    (("2" (split obj)
                      (("1" (propax) nil nil)
                       ("2" (apply-eta "grS`redex" "(release?)")
                        (("2" (rewrite -1 :dir RL)
                          (("2" (expand unmark trr)
                            (("2" (simplify) (("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (propax) nil nil)
                       ("4"
                        (with-labels (lemma stack_subset_match)
                         ((ssm)))
                        (("4" (inst? ssm)
                          (("4" (inst? ssm :where stam)
                            (("4" (split ssm)
                              (("1" (propax) nil nil)
                               ("2"
                                (delete obj)
                                (("2"
                                  (skeep :preds? t)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("5" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil)
  (releaseReduce_match-3 "" 3700310918
   ("" (with-labels (skeep* :preds? t) ((err prr ndm stm obj)))
    (("" (expand releaseReduce)
      (("" (lift-if)
        (("" (with-labels (ground) ((rf obj) (rf obj)))
          (("1"
            (with-labels
             (case "index(rvar(grS`redex)) + popDepth(grS`redex) < grS`stack`length")
             (("index_sl")))
            (("1" (with-labels (ground) ((rf obj) (rf obj)))
              (("1"
                (with-labels (use decref_match)
                 ((dcimp) (ndrh) (cnth) (rdxh) (nilh) (sth)))
                (("1" (split dcimp)
                  (("1" (propax) nil nil)
                   ("2" (delete obj)
                    (("2"
                      (with-labels
                       (name "rS2" "grS
                                      WITH [`stack`seq
                                                    (grS`stack`length - 1
                                                     -
                                                     index(rvar(grS`redex))
                                                     -
                                                     popDepth(grS`redex))
                                              := nil,
                                            `count
                                              (refindex(grS`stack`seq
                                                        (grS`stack`length - 1
                                                         -
                                                         index(rvar(grS`redex))
                                                         -
                                                         popDepth(grS`redex))))
                                              := grS`count
                                                     (refindex
                                                      (grS`stack`seq
                                                       (grS`stack`length - 1
                                                        -
                                                        index(rvar(grS`redex))
                                                        -
                                                        popDepth(grS`redex))))
                                                  - 1,
                                            `redex := rexpr(grS`redex)]")
                       ((rS2def)))
                      (("1" (replace -1)
                        (("1" (expand state_matches?)
                          (("1" (skeep)
                            (("1"
                              (inst dcimp
                               "LAMBDA (r: (rS2`domain) | rS2`count(r) > 0): translate(r)")
                              (("1"
                                (expand state_matches)
                                (("1"
                                  (with-labels
                                   (flatten)
                                   ((esr trr unm stam stom)))
                                  (("1"
                                    (split dcimp)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (replace trr :dir RL)
                                      (("2"
                                        (lemma
                                         translate_refs_restrict2)
                                        (("2"
                                          (inst
                                           -1
                                           "unmark(grS`redex)"
                                           "extend[nat, (grS`domain), bool, FALSE]
                          ({r: (grS`domain) | grS`count(r) > 0})"
                                           "eS`domain"
                                           "extend[nat, (rS2`domain), bool, FALSE]
                         ({r: (rS2`domain) | rS2`count(r) > 0})"
                                           _
                                           _)
                                          (("2"
                                            (inst? -1)
                                            (("2"
                                              (inst? -1)
                                              (("1"
                                                (split -1)
                                                (("1" (grind) nil nil)
                                                 ("2"
                                                  (delete dcimp)
                                                  (("2"
                                                    (hide-all-but
                                                     (1 rS2def))
                                                    (("2"
                                                      (skeep*
                                                       :preds?
                                                       t)
                                                      (("2"
                                                        (replace
                                                         rS2def
                                                         :dir
                                                         RL)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (delete dcimp)
                                                  (("3"
                                                    (skeep*)
                                                    (("3"
                                                      (typepred
                                                       "rS2`redex")
                                                      (("3"
                                                        (rewrite
                                                         unmark_refs)
                                                        (("3"
                                                          (inst -1 i)
                                                          (("3"
                                                            (typepred
                                                             "rS2`count(i)")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("4"
                                                  (rewrite
                                                   unmark_contextPure)
                                                  nil
                                                  nil)
                                                 ("5" (grind) nil nil))
                                                nil)
                                               ("2" (grind) nil nil)
                                               ("3"
                                                (skeep* :preds? t)
                                                (("3"
                                                  (replace
                                                   rS2def
                                                   :dir
                                                   RL)
                                                  (("3"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3" (grind) nil nil)
                                     ("4"
                                      (with-labels
                                       (lemma stack_stillmatch)
                                       ((ssm)))
                                      (("4"
                                        (inst
                                         ssm
                                         "union(cvars(rS2`redex),
                          bumpn(cvars(rS2`context), popDepth(rS2`redex)))"
                                         eS
                                         grS
                                         rS2)
                                        (("4"
                                          (simplify :let-reduce? t)
                                          (("4"
                                            (inst? ssm)
                                            (("1"
                                              (inst ssm translate)
                                              (("1"
                                                (split ssm)
                                                (("1" (propax) nil nil)
                                                 ("2" (grind) nil nil)
                                                 ("3" (grind) nil nil)
                                                 ("4"
                                                  (delete dcimp)
                                                  (("4"
                                                    (with-labels
                                                     (skeep :preds? t)
                                                     ((ih ssm)))
                                                    (("4"
                                                      (expand union)
                                                      (("4"
                                                        (expand member)
                                                        (("4"
                                                          (with-labels
                                                           (typepred
                                                            "grS`redex")
                                                           ((hrefs
                                                             hvars
                                                             hcvars
                                                             hpop
                                                             hcp
                                                             hmark)))
                                                          (("4"
                                                            (rewrite
                                                             rS2def
                                                             :dir
                                                             RL)
                                                            (("4"
                                                              (simplify)
                                                              (("4"
                                                                (delete
                                                                 trr
                                                                 unm
                                                                 stom)
                                                                (("4"
                                                                  (split
                                                                   ssm)
                                                                  (("1"
                                                                    (split
                                                                     ih)
                                                                    (("1"
                                                                      (lemma
                                                                       cvars_vars)
                                                                      (("1"
                                                                        (inst
                                                                         -1
                                                                         "grS`redex"
                                                                         "i - popDepth(grS`redex)")
                                                                        (("1"
                                                                          (apply-eta
                                                                           "grS`redex"
                                                                           "(release?)")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :dir
                                                                             RL)
                                                                            (("1"
                                                                              (grind)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (expand
                                                                       bumpn)
                                                                      (("2"
                                                                        (lemma
                                                                         cvars_vars_ctx)
                                                                        (("2"
                                                                          (inst
                                                                           -1
                                                                           "grS`context"
                                                                           "i - popDepth(grS`redex) - popDepth(grS`context)")
                                                                          (("1"
                                                                            (apply-eta
                                                                             "grS`redex"
                                                                             "(release?)")
                                                                            (("1"
                                                                              (replace
                                                                               -1
                                                                               :dir
                                                                               RL)
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (lift-if)
                                                                    (("2"
                                                                      (split
                                                                       ssm)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (apply-eta
                                                                           "grS`redex"
                                                                           "(release?)")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :dir
                                                                             RL)
                                                                            (("1"
                                                                              (expand
                                                                               mark
                                                                               hmark)
                                                                              (("1"
                                                                                (with-labels
                                                                                 (decompose-equality
                                                                                  hmark)
                                                                                 ((hmark1
                                                                                   hmark2)))
                                                                                (("1"
                                                                                  (postpone)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (propax)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("5"
                                                  (delete dcimp)
                                                  (("5"
                                                    (skeep)
                                                    (("5"
                                                      (case
                                                       "rS2`count(r) <= 0")
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (replace
                                                         rS2def
                                                         :dir
                                                         RL)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("6"
                                                  (delete dcimp)
                                                  (("6"
                                                    (replace
                                                     rS2def
                                                     :dir
                                                     RL)
                                                    (("6"
                                                      (simplify)
                                                      (("6"
                                                        (postpone)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("7" (grind) nil nil))
                                                nil))
                                              nil)
                                             ("2" (grind) nil nil)
                                             ("3"
                                              (skeep* :preds? t)
                                              (("3"
                                                (replace
                                                 rS2def
                                                 :dir
                                                 RL)
                                                (("3" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("5"
                                      (expand store_matches)
                                      (("5"
                                        (skeep)
                                        (("5"
                                          (inst stom r_2)
                                          (("1"
                                            (split dcimp)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (skeep)
                                              (("2"
                                                (with-labels
                                                 (lemma
                                                  translate_refs_restrict)
                                                 ((tsr)))
                                                (("2"
                                                  (inst
                                                   tsr
                                                   "rS2`store(r_2)`seq(j)"
                                                   _
                                                   _
                                                   _)
                                                  (("2"
                                                    (inst
                                                     tsr
                                                     "extend[nat, (grS`domain), bool, FALSE]
                                               ({r: (grS`domain) | grS`count(r) > 0})"
                                                     "eS`domain"
                                                     "extend[nat, (rS2`domain), bool, FALSE]
                                               ({r: (rS2`domain) | rS2`count(r) > 0})")
                                                    (("2"
                                                      (split tsr)
                                                      (("1"
                                                        (inst
                                                         tsr
                                                         translate)
                                                        (("1"
                                                          (case-replace
                                                           "(lambda (i:
                                                      (extend[nat, (rS2`domain), bool, FALSE]
                                                           ({r: (rS2`domain) |
                                                             rS2`count(r) > 0}))):
                                              translate(i)) =  lambda (r: (rS2`domain) | rS2`count(r) > 0):
                                             translate(r)")
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (delete
                                                             dcimp)
                                                            (("2"
                                                              (decompose-equality)
                                                              (("1"
                                                                (replace
                                                                 rS2def
                                                                 :dir
                                                                 RL)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (skeep*
                                                                 :preds?
                                                                 t)
                                                                (("2"
                                                                  (replace
                                                                   rS2def
                                                                   :dir
                                                                   RL)
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("3"
                                                                (skeep*
                                                                 :preds?
                                                                 t)
                                                                (("3"
                                                                  (replace
                                                                   rS2def
                                                                   :dir
                                                                   RL)
                                                                  (("3"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (replace
                                                             rS2def
                                                             :dir
                                                             RL)
                                                            (("3"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("4"
                                                            (skeep*
                                                             :preds?
                                                             t)
                                                            (("4"
                                                              (replace
                                                               rS2def
                                                               :dir
                                                               RL)
                                                              (("4"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("5"
                                                            (skeep*
                                                             :preds?
                                                             t)
                                                            (("5"
                                                              (replace
                                                               rS2def
                                                               :dir
                                                               RL)
                                                              (("5"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (skeep*
                                                         :preds?
                                                         t)
                                                        (("2"
                                                          (replace
                                                           rS2def
                                                           :dir
                                                           RL)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (skeep*)
                                                        (("3"
                                                          (typepred
                                                           "rS2`store(r_2)`seq(j)")
                                                          (("3"
                                                            (typepred
                                                             "rS2`count(i)")
                                                            (("1"
                                                              (expand
                                                               refcount)
                                                              (("1"
                                                                (use
                                                                 refcountStore_ref)
                                                                (("1"
                                                                  (hide-all-but
                                                                   (1
                                                                    -1
                                                                    -2
                                                                    -3
                                                                    -4
                                                                    tsr))
                                                                  (("1"
                                                                    (grind-with-ext)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("4"
                                                        (typepred
                                                         "rS2`store(r_2)`seq(j)")
                                                        (("4"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (typepred r_2)
                                            (("2"
                                              (replace rS2def :dir RL)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skeep* :preds? t)
                                (("2"
                                  (replace rS2def :dir RL)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete dcimp)
                        (("2" (lemma refcount_stack_update)
                          (("2"
                            (inst -1 grS
                             "grS`stack`length - 1 - index(rvar(grS`redex)) -
                 popDepth(grS`redex)"
                             "refindex(grS`stack`seq(grS`stack`length - 1 - index(rvar(grS`redex)) - popDepth(grS`redex)))")
                            (("1" (split -1)
                              (("1"
                                (flatten)
                                (("1"
                                  (split)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (replace -2)
                                    (("2"
                                      (expand refcount)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind-with-ext) nil nil))
                              nil)
                             ("2" (typepred "grS`stack")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("3" (delete dcimp)
                        (("3"
                          (with-labels (typepred "grS`redex")
                           ((hrefs hvars hcvars hpop hcp hmark)))
                          (("3" (split rS2def)
                            (("1" (skeep)
                              (("1"
                                (inst hrefs i)
                                (("1" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil)
                             ("3" (grind) nil nil)
                             ("4" (grind) nil nil)
                             ("5" (grind) nil nil)
                             ("6" (apply-eta "grS`redex" "(release?)")
                              (("6"
                                (replace -1 :dir RL)
                                (("6"
                                  (expand mark hmark)
                                  (("6"
                                    (decompose-equality hmark)
                                    (("6"
                                      (simplify)
                                      (("6" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (delete dcimp)
                        (("4" (typepred "grS`stack")
                          (("4" (expand every)
                            (("4" (skeep)
                              (("4"
                                (inst -1 i)
                                (("4" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("5" (delete dcimp) (("5" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete obj)
                  (("2" (expand noDanglingRefs?)
                    (("2" (skeep)
                      (("2" (inst ndm i)
                        (("2" (ground)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (delete obj)
                  (("3"
                    (typepred "grS`count
                   (refindex(grS`stack`seq
                                 (grS`stack`length - 1 - index(rvar(grS`redex)) -
                                   popDepth(grS`redex))))")
                    (("1" (rewrite -1)
                      (("1" (expand refcount)
                        (("1" (split cnth)
                          (("1" (expand refcountStack)
                            (("1" (use "count_elem[(value?)]")
                              (("1"
                                (split -1)
                                (("1" (grind) nil nil)
                                 ("2" (inst?) nil nil)
                                 ("3" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand refcountStack)
                            (("2" (rewrite count_update)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "grS`stack")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("4" (delete obj)
                  (("4"
                    (with-labels (typepred "grS`redex")
                     ((hrefs hvars hcvars hpop hcp hmark)))
                    (("4" (split rdxh)
                      (("1" (skeep)
                        (("1" (inst hrefs i) (("1" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil) ("3" (grind) nil nil)
                       ("4" (grind) nil nil) ("5" (grind) nil nil)
                       ("6" (apply-eta "grS`redex" "(release?)")
                        (("6" (replace -1 :dir RL)
                          (("6" (expand mark hmark)
                            (("6" (decompose-equality hmark)
                              (("6"
                                (simplify)
                                (("6" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("5" (grind) nil nil))
                nil))
              nil)
             ("2" (delete obj)
              (("2" (typepred "grS`redex")
                (("2" (inst -2 "index(rvar(grS`redex))")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (expand state_matches?)
            (("2" (skeep)
              (("2" (inst?)
                (("2" (expand state_matches)
                  (("2"
                    (with-labels (flatten) ((esr trr unm stam stom)))
                    (("2" (split obj)
                      (("1" (propax) nil nil)
                       ("2" (apply-eta "grS`redex" "(release?)")
                        (("2" (rewrite -1 :dir RL)
                          (("2" (expand unmark trr)
                            (("2" (simplify) (("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (propax) nil nil)
                       ("4"
                        (with-labels (lemma stack_subset_match)
                         ((ssm)))
                        (("4" (inst? ssm)
                          (("4" (inst? ssm :where stam)
                            (("4" (split ssm)
                              (("1" (propax) nil nil)
                               ("2"
                                (delete obj)
                                (("2"
                                  (skeep :preds? t)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("5" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (releaseReduce_match-2 nil 3700247765
   ("" (with-labels (skeep* :preds? t) ((err prr ndm stm obj)))
    (("" (expand releaseReduce)
      (("" (lift-if)
        (("" (with-labels (ground) ((rf obj) (rf obj)))
          (("1"
            (with-labels
             (case "index(rvar(grS`redex)) + popDepth(grS`redex) < grS`stack`length")
             (("index_sl")))
            (("1" (with-labels (ground) ((rf obj) (rf obj)))
              (("1"
                (with-labels (use decref_match)
                 ((dcimp) (ndrh) (cnth) (rdxh) (nilh) (sth)))
                (("1" (split dcimp)
                  (("1" (propax) nil nil)
                   ("2" (delete obj)
                    (("2"
                      (with-labels
                       (name "rS2" "grS
                                      WITH [`stack`seq
                                                    (grS`stack`length - 1
                                                     -
                                                     index(rvar(grS`redex))
                                                     -
                                                     popDepth(grS`redex))
                                              := nil,
                                            `count
                                              (refindex(grS`stack`seq
                                                        (grS`stack`length - 1
                                                         -
                                                         index(rvar(grS`redex))
                                                         -
                                                         popDepth(grS`redex))))
                                              := grS`count
                                                     (refindex
                                                      (grS`stack`seq
                                                       (grS`stack`length - 1
                                                        -
                                                        index(rvar(grS`redex))
                                                        -
                                                        popDepth(grS`redex))))
                                                  - 1,
                                            `redex := rexpr(grS`redex)]")
                       ((rS2def)))
                      (("1" (replace -1)
                        (("1" (expand state_matches?)
                          (("1" (skeep)
                            (("1"
                              (inst dcimp
                               "LAMBDA (r: (rS2`domain) | rS2`count(r) > 0): translate(r)")
                              (("1"
                                (expand state_matches)
                                (("1"
                                  (with-labels
                                   (flatten)
                                   ((esr trr unm stam stom)))
                                  (("1"
                                    (split dcimp)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (replace trr :dir RL)
                                      (("2"
                                        (lemma
                                         translate_refs_restrict2)
                                        (("2"
                                          (inst
                                           -1
                                           "unmark(grS`redex)"
                                           "extend[nat, (grS`domain), bool, FALSE]
                          ({r: (grS`domain) | grS`count(r) > 0})"
                                           "eS`domain"
                                           "extend[nat, (rS2`domain), bool, FALSE]
                         ({r: (rS2`domain) | rS2`count(r) > 0})"
                                           _
                                           _)
                                          (("2"
                                            (inst? -1)
                                            (("2"
                                              (inst? -1)
                                              (("1"
                                                (split -1)
                                                (("1" (grind) nil nil)
                                                 ("2"
                                                  (delete dcimp)
                                                  (("2"
                                                    (hide-all-but
                                                     (1 rS2def))
                                                    (("2"
                                                      (skeep*
                                                       :preds?
                                                       t)
                                                      (("2"
                                                        (replace
                                                         rS2def
                                                         :dir
                                                         RL)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (delete dcimp)
                                                  (("3"
                                                    (skeep*)
                                                    (("3"
                                                      (typepred
                                                       "rS2`redex")
                                                      (("3"
                                                        (rewrite
                                                         unmark_refs)
                                                        (("3"
                                                          (inst -1 i)
                                                          (("3"
                                                            (typepred
                                                             "rS2`count(i)")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("4"
                                                  (rewrite
                                                   unmark_contextPure)
                                                  nil
                                                  nil)
                                                 ("5" (grind) nil nil))
                                                nil)
                                               ("2" (grind) nil nil)
                                               ("3"
                                                (skeep* :preds? t)
                                                (("3"
                                                  (replace
                                                   rS2def
                                                   :dir
                                                   RL)
                                                  (("3"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3" (grind) nil nil)
                                     ("4"
                                      (with-labels
                                       (lemma stack_stillmatch)
                                       ((ssm)))
                                      (("4"
                                        (inst
                                         ssm
                                         "union(cvars(rS2`redex),
                          bumpn(cvars(rS2`context), popDepth(rS2`redex)))"
                                         eS
                                         grS
                                         rS2)
                                        (("4"
                                          (simplify :let-reduce? t)
                                          (("4"
                                            (inst? ssm)
                                            (("1"
                                              (inst ssm translate)
                                              (("1"
                                                (split ssm)
                                                (("1" (propax) nil nil)
                                                 ("2" (grind) nil nil)
                                                 ("3" (grind) nil nil)
                                                 ("4"
                                                  (delete dcimp)
                                                  (("4"
                                                    (with-labels
                                                     (skeep :preds? t)
                                                     ((ih ssm)))
                                                    (("4"
                                                      (expand union)
                                                      (("4"
                                                        (expand member)
                                                        (("4"
                                                          (with-labels
                                                           (typepred
                                                            "grS`redex")
                                                           ((hrefs
                                                             hvars
                                                             hcvars
                                                             hpop
                                                             hcp
                                                             hmark)))
                                                          (("4"
                                                            (rewrite
                                                             rS2def
                                                             :dir
                                                             RL)
                                                            (("4"
                                                              (simplify)
                                                              (("4"
                                                                (delete
                                                                 trr
                                                                 unm
                                                                 stom)
                                                                (("4"
                                                                  (split
                                                                   ssm)
                                                                  (("1"
                                                                    (split
                                                                     ih)
                                                                    (("1"
                                                                      (lemma
                                                                       cvars_vars)
                                                                      (("1"
                                                                        (inst
                                                                         -1
                                                                         "grS`redex"
                                                                         "i - popDepth(grS`redex)")
                                                                        (("1"
                                                                          (apply-eta
                                                                           "grS`redex"
                                                                           "(release?)")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :dir
                                                                             RL)
                                                                            (("1"
                                                                              (grind)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (expand
                                                                       bumpn)
                                                                      (("2"
                                                                        (lemma
                                                                         cvars_vars_ctx)
                                                                        (("2"
                                                                          (inst
                                                                           -1
                                                                           "grS`context"
                                                                           "i - popDepth(grS`redex) - popDepth(grS`context)")
                                                                          (("1"
                                                                            (apply-eta
                                                                             "grS`redex"
                                                                             "(release?)")
                                                                            (("1"
                                                                              (replace
                                                                               -1
                                                                               :dir
                                                                               RL)
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (lift-if)
                                                                    (("2"
                                                                      (split
                                                                       ssm)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (apply-eta
                                                                           "grS`redex"
                                                                           "(release?)")
                                                                          (("1"
                                                                            (replace
                                                                             -1
                                                                             :dir
                                                                             RL)
                                                                            (("1"
                                                                              (expand
                                                                               mark
                                                                               hmark)
                                                                              (("1"
                                                                                (with-labels
                                                                                 (decompose-equality
                                                                                  hmark)
                                                                                 ((hmark1
                                                                                   hmark2)))
                                                                                (("1"
                                                                                  (postpone)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (postpone)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("5"
                                                  (delete dcimp)
                                                  (("5"
                                                    (skeep)
                                                    (("5"
                                                      (case
                                                       "rS2`count(r) <= 0")
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (replace
                                                         rS2def
                                                         :dir
                                                         RL)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("6"
                                                  (delete dcimp)
                                                  (("6"
                                                    (replace
                                                     rS2def
                                                     :dir
                                                     RL)
                                                    (("6"
                                                      (simplify)
                                                      (("6"
                                                        (postpone)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("7" (grind) nil nil))
                                                nil))
                                              nil)
                                             ("2" (grind) nil nil)
                                             ("3"
                                              (skeep* :preds? t)
                                              (("3"
                                                (replace
                                                 rS2def
                                                 :dir
                                                 RL)
                                                (("3" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("5"
                                      (expand store_matches)
                                      (("5"
                                        (skeep)
                                        (("5"
                                          (inst stom r_2)
                                          (("1"
                                            (split dcimp)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (skeep)
                                              (("2"
                                                (with-labels
                                                 (lemma
                                                  translate_refs_restrict)
                                                 ((tsr)))
                                                (("2"
                                                  (inst
                                                   tsr
                                                   "rS2`store(r_2)`seq(j)"
                                                   _
                                                   _
                                                   _)
                                                  (("2"
                                                    (inst
                                                     tsr
                                                     "extend[nat, (grS`domain), bool, FALSE]
                                               ({r: (grS`domain) | grS`count(r) > 0})"
                                                     "eS`domain"
                                                     "extend[nat, (rS2`domain), bool, FALSE]
                                               ({r: (rS2`domain) | rS2`count(r) > 0})")
                                                    (("2"
                                                      (split tsr)
                                                      (("1"
                                                        (inst
                                                         tsr
                                                         translate)
                                                        (("1"
                                                          (case-replace
                                                           "(lambda (i:
                                                      (extend[nat, (rS2`domain), bool, FALSE]
                                                           ({r: (rS2`domain) |
                                                             rS2`count(r) > 0}))):
                                              translate(i)) =  lambda (r: (rS2`domain) | rS2`count(r) > 0):
                                             translate(r)")
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (delete
                                                             dcimp)
                                                            (("2"
                                                              (decompose-equality)
                                                              (("1"
                                                                (replace
                                                                 rS2def
                                                                 :dir
                                                                 RL)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (skeep*
                                                                 :preds?
                                                                 t)
                                                                (("2"
                                                                  (replace
                                                                   rS2def
                                                                   :dir
                                                                   RL)
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("3"
                                                                (skeep*
                                                                 :preds?
                                                                 t)
                                                                (("3"
                                                                  (replace
                                                                   rS2def
                                                                   :dir
                                                                   RL)
                                                                  (("3"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (replace
                                                             rS2def
                                                             :dir
                                                             RL)
                                                            (("3"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("4"
                                                            (skeep*
                                                             :preds?
                                                             t)
                                                            (("4"
                                                              (replace
                                                               rS2def
                                                               :dir
                                                               RL)
                                                              (("4"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("5"
                                                            (skeep*
                                                             :preds?
                                                             t)
                                                            (("5"
                                                              (replace
                                                               rS2def
                                                               :dir
                                                               RL)
                                                              (("5"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (skeep*
                                                         :preds?
                                                         t)
                                                        (("2"
                                                          (replace
                                                           rS2def
                                                           :dir
                                                           RL)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (skeep*)
                                                        (("3"
                                                          (typepred
                                                           "rS2`store(r_2)`seq(j)")
                                                          (("3"
                                                            (typepred
                                                             "rS2`count(i)")
                                                            (("1"
                                                              (expand
                                                               refcount)
                                                              (("1"
                                                                (use
                                                                 refcountStore_ref)
                                                                (("1"
                                                                  (hide-all-but
                                                                   (1
                                                                    -1
                                                                    -2
                                                                    -3
                                                                    -4
                                                                    tsr))
                                                                  (("1"
                                                                    (grind-with-ext)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("4"
                                                        (typepred
                                                         "rS2`store(r_2)`seq(j)")
                                                        (("4"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (typepred r_2)
                                            (("2"
                                              (replace rS2def :dir RL)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skeep* :preds? t)
                                (("2"
                                  (replace rS2def :dir RL)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete dcimp)
                        (("2" (lemma refcount_stack_update)
                          (("2"
                            (inst -1 grS
                             "grS`stack`length - 1 - index(rvar(grS`redex)) -
                 popDepth(grS`redex)"
                             "refindex(grS`stack`seq(grS`stack`length - 1 - index(rvar(grS`redex)) - popDepth(grS`redex)))")
                            (("1" (split -1)
                              (("1"
                                (flatten)
                                (("1"
                                  (split)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (replace -2)
                                    (("2"
                                      (expand refcount)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind-with-ext) nil nil))
                              nil)
                             ("2" (typepred "grS`stack")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("3" (delete dcimp)
                        (("3"
                          (with-labels (typepred "grS`redex")
                           ((hrefs hvars hcvars hpop hcp hmark)))
                          (("3" (split rS2def)
                            (("1" (skeep)
                              (("1"
                                (inst hrefs i)
                                (("1" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil)
                             ("3" (grind) nil nil)
                             ("4" (grind) nil nil)
                             ("5" (grind) nil nil)
                             ("6" (apply-eta "grS`redex" "(release?)")
                              (("6"
                                (replace -1 :dir RL)
                                (("6"
                                  (expand mark hmark)
                                  (("6"
                                    (decompose-equality hmark)
                                    (("6"
                                      (simplify)
                                      (("6" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (delete dcimp)
                        (("4" (typepred "grS`stack")
                          (("4" (expand every)
                            (("4" (skeep)
                              (("4"
                                (inst -1 i)
                                (("4" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("5" (delete dcimp) (("5" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete obj)
                  (("2" (expand noDanglingRefs?)
                    (("2" (skeep)
                      (("2" (inst ndm i)
                        (("2" (ground)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (delete obj)
                  (("3"
                    (typepred "grS`count
                   (refindex(grS`stack`seq
                                 (grS`stack`length - 1 - index(rvar(grS`redex)) -
                                   popDepth(grS`redex))))")
                    (("1" (rewrite -1)
                      (("1" (expand refcount)
                        (("1" (split cnth)
                          (("1" (expand refcountStack)
                            (("1" (use "count_elem[(value?)]")
                              (("1"
                                (split -1)
                                (("1" (grind) nil nil)
                                 ("2" (inst?) nil nil)
                                 ("3" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand refcountStack)
                            (("2" (rewrite count_update)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "grS`stack")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("4" (delete obj)
                  (("4"
                    (with-labels (typepred "grS`redex")
                     ((hrefs hvars hcvars hpop hcp hmark)))
                    (("4" (split rdxh)
                      (("1" (skeep)
                        (("1" (inst hrefs i) (("1" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil) ("3" (grind) nil nil)
                       ("4" (grind) nil nil) ("5" (grind) nil nil)
                       ("6" (apply-eta "grS`redex" "(release?)")
                        (("6" (replace -1 :dir RL)
                          (("6" (expand mark hmark)
                            (("6" (decompose-equality hmark)
                              (("6"
                                (simplify)
                                (("6" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("5" (grind) nil nil))
                nil))
              nil)
             ("2" (delete obj)
              (("2" (typepred "grS`redex")
                (("2" (inst -2 "index(rvar(grS`redex))")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (expand state_matches?)
            (("2" (skeep)
              (("2" (inst?)
                (("2" (expand state_matches)
                  (("2"
                    (with-labels (flatten) ((esr trr unm stam stom)))
                    (("2" (split obj)
                      (("1" (propax) nil nil)
                       ("2" (apply-eta "grS`redex" "(release?)")
                        (("2" (rewrite -1 :dir RL)
                          (("2" (expand unmark trr)
                            (("2" (simplify) (("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (propax) nil nil)
                       ("4"
                        (with-labels (lemma stack_subset_match)
                         ((ssm)))
                        (("4" (inst? ssm)
                          (("4" (inst? ssm :where stam)
                            (("4" (split ssm)
                              (("1" (propax) nil nil)
                               ("2"
                                (delete obj)
                                (("2"
                                  (skeep :preds? t)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("5" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil)
  (releaseReduce_match-1 nil 3700241450
   ("" (with-labels (skeep* :preds? t) ((err prr ndm stm obj)))
    (("" (expand releaseReduce)
      (("" (lift-if)
        (("" (with-labels (ground) ((rf obj) (rf obj)))
          (("1"
            (with-labels
             (case "index(rvar(grS`redex)) + popDepth(grS`redex) < grS`stack`length")
             (("index_sl")))
            (("1" (with-labels (ground) ((rf obj) (rf obj)))
              (("1"
                (with-labels (use decref_match)
                 ((dcimp) (ndrh) (cnth) (rdxh) (nilh) (sth)))
                (("1" (split dcimp)
                  (("1" (propax) nil nil)
                   ("2" (delete obj)
                    (("2"
                      (name "rS2" "grS
                       WITH [`stack`seq
                                     (grS`stack`length - 1
                                      -
                                      index(rvar(grS`redex))
                                      -
                                      popDepth(grS`redex))
                               := nil,
                             `count
                               (refindex(grS`stack`seq
                                         (grS`stack`length - 1
                                          -
                                          index(rvar(grS`redex))
                                          -
                                          popDepth(grS`redex))))
                               := grS`count
                                      (refindex
                                       (grS`stack`seq
                                        (grS`stack`length - 1
                                         -
                                         index(rvar(grS`redex))
                                         -
                                         popDepth(grS`redex))))
                                   - 1,
                             `redex := rexpr(grS`redex)]")
                      (("1" (replace -1)
                        (("1" (expand state_matches?)
                          (("1" (skeep)
                            (("1"
                              (inst dcimp
                               "LAMBDA (r: (rS2`domain) | rS2`count(r) > 0): translate(r)")
                              (("1"
                                (expand state_matches)
                                (("1"
                                  (with-labels
                                   (flatten)
                                   ((esr trr unm stam stom)))
                                  (("1"
                                    (split dcimp)
                                    (("1" (grind) nil nil)
                                     ("2" (postpone) nil nil)
                                     ("3" (grind) nil nil)
                                     ("4" (postpone) nil nil)
                                     ("5"
                                      (expand store_matches)
                                      (("5"
                                        (skeep)
                                        (("5"
                                          (inst stom r_2)
                                          (("1"
                                            (split dcimp)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (skeep)
                                              (("2"
                                                (with-labels
                                                 (lemma
                                                  translate_refs_restrict)
                                                 ((tsr)))
                                                (("2"
                                                  (inst
                                                   tsr
                                                   "rS2`store(r_2)`seq(j)"
                                                   _
                                                   _
                                                   _)
                                                  (("2"
                                                    (inst
                                                     tsr
                                                     "extend[nat, (grS`domain), bool, FALSE]
                           ({r: (grS`domain) | grS`count(r) > 0})"
                                                     "eS`domain"
                                                     "extend[nat, (rS2`domain), bool, FALSE]
                           ({r: (rS2`domain) | rS2`count(r) > 0})")
                                                    (("2"
                                                      (split tsr)
                                                      (("1"
                                                        (inst
                                                         tsr
                                                         translate)
                                                        (("1"
                                                          (case-replace
                                                           "(lambda (i:
                                (extend[nat, (rS2`domain), bool, FALSE]
                                     ({r: (rS2`domain) |
                                       rS2`count(r) > 0}))):
                        translate(i)) =  lambda (r: (rS2`domain) | rS2`count(r) > 0):
                       translate(r)")
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (delete
                                                             dcimp)
                                                            (("2"
                                                              (postpone)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (postpone)
                                                            nil
                                                            nil)
                                                           ("4"
                                                            (postpone)
                                                            nil
                                                            nil)
                                                           ("5"
                                                            (postpone)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (postpone)
                                                        nil
                                                        nil)
                                                       ("3"
                                                        (postpone)
                                                        nil
                                                        nil)
                                                       ("4"
                                                        (postpone)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (typepred r_2)
                                            (("2" (postpone) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (postpone) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete dcimp) (("2" (postpone) nil nil))
                        nil)
                       ("3" (postpone) nil nil)
                       ("4" (postpone) nil nil)
                       ("5" (postpone) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete obj)
                  (("2" (expand noDanglingRefs?)
                    (("2" (skeep)
                      (("2" (inst ndm i)
                        (("2" (ground)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (delete obj)
                  (("3"
                    (typepred "grS`count
           (refindex(grS`stack`seq
                         (grS`stack`length - 1 - index(rvar(grS`redex)) -
                           popDepth(grS`redex))))")
                    (("1" (rewrite -1)
                      (("1" (expand refcount)
                        (("1" (split cnth)
                          (("1" (expand refcountStack)
                            (("1" (use "count_elem[(value?)]")
                              (("1"
                                (split -1)
                                (("1" (grind) nil nil)
                                 ("2" (inst?) nil nil)
                                 ("3" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand refcountStack)
                            (("2" (rewrite count_update)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "grS`stack")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("4" (delete obj)
                  (("4"
                    (with-labels (typepred "grS`redex")
                     ((hrefs hvars hcvars hpop hcp hmark)))
                    (("4" (split rdxh)
                      (("1" (skeep)
                        (("1" (inst hrefs i) (("1" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil) ("3" (grind) nil nil)
                       ("4" (grind) nil nil) ("5" (grind) nil nil)
                       ("6" (apply-eta "grS`redex" "(release?)")
                        (("6" (replace -1 :dir RL)
                          (("6" (expand mark hmark)
                            (("6" (decompose-equality hmark)
                              (("6"
                                (simplify)
                                (("6" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("5" (grind) nil nil))
                nil))
              nil)
             ("2" (delete obj)
              (("2" (typepred "grS`redex")
                (("2" (inst -2 "index(rvar(grS`redex))")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (expand state_matches?)
            (("2" (skeep)
              (("2" (inst?)
                (("2" (expand state_matches)
                  (("2"
                    (with-labels (flatten) ((esr trr unm stam stom)))
                    (("2" (split obj)
                      (("1" (propax) nil nil)
                       ("2" (apply-eta "grS`redex" "(release?)")
                        (("2" (rewrite -1 :dir RL)
                          (("2" (expand unmark trr)
                            (("2" (simplify) (("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (propax) nil nil)
                       ("4"
                        (with-labels (lemma stack_subset_match)
                         ((ssm)))
                        (("4" (inst? ssm)
                          (("4" (inst? ssm :where stam)
                            (("4" (split ssm)
                              (("1" (propax) nil nil)
                               ("2"
                                (delete obj)
                                (("2"
                                  (skeep :preds? t)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("5" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (release_marked_match_TCC1 0
  (release_marked_match_TCC1-1 nil 3700234159
   ("" (subtype-tcc) nil nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (member const-decl "bool" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (release_marked_match_TCC2 0
  (release_marked_match_TCC2-2 "" 3700424094 ("" (grind) nil nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (member const-decl "bool" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak)
  (release_marked_match_TCC2-1 nil 3700234159
   (""
    (with-labels (skeep* :preds? t) ((xvar stm mark_imp sl_index obj)))
    (("" (split obj)
      (("1"
        (typepred "rS`stack`seq
                           (rS`stack`length - index(x) - popDepth(rS`redex) -
                             1)")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (with-labels (skeep) ((st_ref obj)))
        (("2" (with-labels (case "rS`domain(i)") ((i_domain)))
          (("1" (typepred "rS`count(i)")
            (("1" (expand refcount)
              (("1" (expand refcountStack)
                (("1" (expand extend)
                  (("1" (lemma "count_elem[(value?)]")
                    (("1" (inst? -1)
                      (("1"
                        (inst -1 "rS`stack`seq
                       (rS`stack`length - index(x) - popDepth(rS`redex) - 1)")
                        (("1" (split -1)
                          (("1" (replace -2) (("1" (assert) nil nil))
                            nil)
                           ("2"
                            (inst 1
                             "rS`stack`length - index(x) - popDepth(rS`redex) - 1")
                            (("2" (grind) nil nil)) nil)
                           ("3"
                            (typepred "rS`stack`seq
                           (rS`stack`length - index(x) - popDepth(rS`redex) - 1)")
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("4"
                            (typepred "rS`stack`seq
                           (rS`stack`length - index(x) - popDepth(rS`redex) - 1)")
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (propax) nil nil))
            nil)
           ("2" (typepred "rS`stack")
            (("2"
              (typepred
               "rS`stack`seq(rS`stack`length - index(x) - popDepth(rS`redex) - 1)")
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (member const-decl "bool" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (release_marked_match_TCC3 0
  (release_marked_match_TCC3-2 "" 3700424111 ("" (grind) nil nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak)
  (release_marked_match_TCC3-1 nil 3700234159
   ("" (skeep*) (("" (use extend_finite) nil nil)) nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (release_marked_match 0
  (release_marked_match-1 nil 3700424516
   (""
    (with-labels (skeep* :preds? t)
     ((xvar index_sl mark_imp stm trr obj)))
    (("" (expand release_marked)
      (("" (lift-if)
        (("" (ground)
          (("" (expand state_matches)
            (("" (flatten)
              (("" (split obj)
                (("1" (propax) nil nil)
                 ("2" (expand unmark obj) (("2" (propax) nil nil)) nil)
                 ("3" (propax) nil nil)
                 ("4" (expand stack_matches)
                  (("4" (flatten)
                    (("4" (split obj)
                      (("1" (propax) nil nil)
                       ("2" (skeep :preds? t)
                        (("2" (inst?)
                          (("2" (expand union)
                            (("2" (expand member)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("5" (lemma store_stillmatch)
                  (("5" (inst?)
                    (("1" (inst? :where stm)
                      (("1" (split)
                        (("1" (propax) nil nil)
                         ("2" (simplify) (("2" (propax) nil nil)) nil)
                         ("3" (simplify) (("3" (skeep) nil nil)) nil)
                         ("4" (simplify) (("4" (propax) nil nil)) nil)
                         ("5" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (skeep)
                      (("2" (typepred "rS`count(x1)")
                        (("2" (rewrite -1)
                          (("2" (expand refcount)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((release_marked const-decl "rstate" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (translate_refs_value application-judgement "(value?)"
     reduction_props nil)
    (store_stillmatch formula-decl nil reduction_props nil)
    (markv const-decl "(variable?)" preprocess nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (estate type-eq-decl nil reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil) (union const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (member const-decl "bool" sets nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (unmark def-decl "IExpression" preprocess nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (applyReduce_match_TCC1 0
  (applyReduce_match_TCC1-1 nil 3700234159
   ("" (with-labels (skeep) ((ars stm obj)))
    (("" (expand applyRedex?)
      (("" (expand state_matches?)
        (("" (skeep)
          (("" (expand state_matches) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((applyRedex? const-decl "bool" IL nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (unmark def-decl "IExpression" preprocess nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (ift_match 0
  (ift_match-1 nil 3700424146
   ("" (skeep)
    (("" (expand state_matches?)
      (("" (skeep)
        (("" (expand state_matches)
          (("" (flatten)
            (("" (apply-eta "grS`redex" "(ift?)")
              (("1" (replace -1 :dir RL)
                (("1" (expand unmark)
                  (("1" (expand translate_refs)
                    (("1" (replace -3 :dir RL)
                      (("1" (expand pureIftRedex?)
                        (("1" (expand iftRedex?)
                          (("1" (split)
                            (("1" (use translate_refs_pure)
                              (("1" (rewrite unmark_pure) nil nil))
                              nil)
                             ("2" (use translate_refs_pure)
                              (("2" (rewrite unmark_pure) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state_matches? const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (unmark def-decl "IContext" preprocess nil)
    (unmark def-decl "IExpression" preprocess nil)
    (iftRedex? const-decl "bool" IL nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (translate_refs_pure recursive-judgement-axiom nil reduction_props
     nil)
    (pure? def-decl "bool" IL nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (unmark_pure recursive-judgement-axiom nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (pureIftRedex? const-decl "bool" IL nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (ift_condtion_match_TCC1 0
  (ift_condtion_match_TCC1-1 nil 3700425131 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (ift_condtion_match_TCC2 0
  (ift_condtion_match_TCC2-1 nil 3700425131
   ("" (use ifReduce_correct_indexing) (("" (grind) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (unmark def-decl "IExpression" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (goodstate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (ifReduce_correct_indexing formula-decl nil rreduction nil))
   nil))
 (ift_condtion_match_TCC3 0
  (ift_condtion_match_TCC3-1 nil 3700425131
   ("" (use ift_match) (("" (grind) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (unmark def-decl "IExpression" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (goodstate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (ift_match formula-decl nil reduction_props nil))
   nil))
 (ift_condtion_match_TCC4 0
  (ift_condtion_match_TCC4-1 nil 3700425131
   ("" (skeep*)
    (("" (use ift_match)
      (("" (ground)
        (("" (typepred "gS`redex") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((ift_match formula-decl nil reduction_props nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (goodstate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (unmark def-decl "IExpression" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (ift_condtion_match 0
  (ift_condtion_match-1 nil 3700425030
   ("" (with-labels (skeep*) ((iftr stm obj)))
    (("" (expand get)
      (("" (expand state_matches?)
        (("" (skeep)
          (("" (expand state_matches)
            (("" (with-labels (flatten) ((trr unm stam stom)))
              (("" (expand stack_matches)
                (("" (with-labels (flatten) ((staml stamr)))
                  (("" (inst stamr "index(condition(grS`redex))")
                    (("1"
                      (case-replace
                       "index(condition(gS`redex)) = index(condition(grS`redex))")
                      (("1"
                        (with-labels (flatten stamr) ((stamrl stamrr)))
                        (("1" (replace stamrr :dir RL)
                          (("1"
                            (typepred
                             "grS`stack`seq(grS`stack`length - 1 - index(condition(grS`redex)))")
                            (("1" (grind) nil nil)
                             ("2" (typepred "grS`redex")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete obj)
                        (("2" (replace trr :dir RL)
                          (("2" (apply-eta "grS`redex" "(ift?)")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete obj) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (goodstate type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (translate_refs_value application-judgement "(value?)"
     reduction_props nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil) (union const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (stack_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (ifReduce_match_TCC1 0
  (ifReduce_match_TCC1-1 nil 3700234159
   ("" (with-labels (skeep) (iftr stm obj))
    (("" (expand state_matches?)
      (("" (skeep)
        (("" (expand state_matches)
          (("" (with-labels (flatten) ((trr unm stam stom)))
            (("" (replace trr :dir RL)
              (("" (expand pureIftRedex?)
                (("" (expand iftRedex?)
                  (("" (apply-eta "grS`redex" "(ift?)")
                    (("" (replace -1 :dir RL)
                      (("" (expand unmark)
                        (("" (expand translate_refs iftr)
                          (("" (split)
                            (("1" (use translate_refs_pure)
                              (("1"
                                (use unmark_pure)
                                (("1" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (use translate_refs_pure)
                              (("2"
                                (use unmark_pure)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state_matches? const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (iftRedex? const-decl "bool" IL nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (translate_refs_pure recursive-judgement-axiom nil reduction_props
     nil)
    (pure? def-decl "bool" IL nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (unmark_pure recursive-judgement-axiom nil preprocess nil)
    (unmark def-decl "IExpression" preprocess nil)
    (unmark def-decl "IContext" preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (ifReduce_match 0
  (ifReduce_match-3 "" 3700426340
   ("" (with-labels (skeep) ((iftr stm obj)))
    (("" (expand state_matches?)
      (("" (skeep)
        (("" (inst obj translate)
          ((""
            (with-labels
             (name "cpl"
                   "IF get(grS`stack)(condition(grS`redex)) = constant(0)
                                                        THEN grS WITH [`redex := elseexpr(grS`redex)]
                                                        ELSE grS WITH [`redex := thenexpr(grS`redex)]
                                                        ENDIF")
             ((cpl_def)))
            (("1"
              (case-replace
               "ifReduce(D)(grS) = release_marked(cpl)(condition(grS`redex))")
              (("1" (use release_marked_match)
                (("1" (split -1)
                  (("1" (propax) nil nil)
                   ("2" (delete obj)
                    (("2" (use ifReduce_correct_indexing)
                      (("2" (rewrite purePopDepth)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("3" (use ifReduce_correct_release_marked)
                    (("3" (grind) nil nil)) nil)
                   ("4" (delete obj)
                    (("4" (label obj 1)
                      (("4" (use ift_condtion_match)
                        (("4" (split -1)
                          (("1" (replace -1 cpl_def)
                            (("1" (expand ifReduce obj)
                              (("1"
                                (replace cpl_def :dir RL)
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (split obj)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand state_matches)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (split obj)
                                            (("1"
                                              (replace -1 :dir RL)
                                              (("1"
                                                (apply-eta
                                                 "grS`redex"
                                                 "(ift?)")
                                                (("1"
                                                  (replace -1 :dir RL)
                                                  (("1"
                                                    (expand unmark stm)
                                                    (("1"
                                                      (expand
                                                       translate_refs
                                                       stm)
                                                      (("1"
                                                        (replace
                                                         stm
                                                         :dir
                                                         RL)
                                                        (("1"
                                                          (simplify)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (propax) nil nil)
                                             ("3"
                                              (assert)
                                              (("3"
                                                (lemma
                                                 stack_subvar_match)
                                                (("3"
                                                  (inst
                                                   -1
                                                   gS
                                                   grS
                                                   cpl
                                                   translate)
                                                  (("3"
                                                    (split -1)
                                                    (("1"
                                                      (replace
                                                       cpl_def
                                                       :dir
                                                       RL)
                                                      (("1"
                                                        (simplify)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("3"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("4"
                                                      (use
                                                       purePopDepth)
                                                      (("4"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("5"
                                                      (rewrite
                                                       purePopDepth)
                                                      (("5"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("6"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("7"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("4"
                                              (lemma store_stillmatch)
                                              (("4"
                                                (inst?)
                                                (("1"
                                                  (inst? :where stm)
                                                  (("1"
                                                    (split -1)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("3"
                                                      (simplify)
                                                      (("3"
                                                        (prop)
                                                        (("3"
                                                          (skeep)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("4"
                                                      (simplify)
                                                      (("4"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("5"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (skeep)
                                                  (("2"
                                                    (use
                                                     pure_count_keep)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (use
                                                   ifReduce_correct_redex_else)
                                                  (("3"
                                                    (simplify
                                                     :let-reduce?
                                                     t)
                                                    (("3"
                                                      (prop)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (ground)
                                        (("2"
                                          (hide-all-but (- obj))
                                          (("2"
                                            (expand state_matches)
                                            (("2"
                                              (with-labels
                                               (flatten)
                                               ((trr unm stam stom)))
                                              (("2"
                                                (split)
                                                (("1"
                                                  (apply-eta
                                                   "grS`redex"
                                                   "(ift?)")
                                                  (("1"
                                                    (replace
                                                     -5
                                                     :dir
                                                     RL)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (propax) nil nil)
                                                 ("3"
                                                  (lemma
                                                   stack_subvar_match)
                                                  (("3"
                                                    (inst
                                                     -1
                                                     gS
                                                     grS
                                                     cpl
                                                     translate)
                                                    (("3"
                                                      (split -1)
                                                      (("1"
                                                        (replace
                                                         cpl_def
                                                         :dir
                                                         RL)
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("3"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("4"
                                                        (rewrite
                                                         purePopDepth)
                                                        (("4"
                                                          (hide-all-but
                                                           (1 iftr))
                                                          (("4"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("5"
                                                        (rewrite
                                                         purePopDepth)
                                                        (("5"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("6"
                                                        (apply-eta
                                                         "grS`redex"
                                                         "(ift?)")
                                                        (("6"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("7"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("4"
                                                  (use
                                                   store_stillmatch)
                                                  (("4"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (propax) nil nil)
                           ("3" (expand state_matches?)
                            (("3" (inst?) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("5" (delete obj)
                    (("5" (expand ifReduce 1)
                      (("5" (assert)
                        (("5" (rewrite purePopDepth)
                          (("1" (replace cpl_def :dir RL)
                            (("1" (simplify)
                              (("1"
                                (assert)
                                (("1"
                                  (expand state_matches)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (expand stack_matches)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (inst?)
                                          (("1"
                                            (flatten)
                                            (("1" (grind) nil nil))
                                            nil)
                                           ("2"
                                            (expand union)
                                            (("2"
                                              (expand member)
                                              (("2"
                                                (apply-eta
                                                 "grS`redex"
                                                 "(ift?)")
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand ifReduce 1)
                (("2" (replace cpl_def :dir RL)
                  (("2" (lift-if) (("2" (propax) nil nil)) nil)) nil))
                nil)
               ("3" (split)
                (("1" (rewrite purePopDepth)
                  (("1" (use ifReduce_correct_indexing)
                    (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (use ifReduce_correct_release_marked)
                  (("2" (grind) nil nil)) nil))
                nil)
               ("4" (grind) nil nil))
              nil)
             ("2" (flatten)
              (("2" (skeep)
                (("2" (use ifReduce_correct_count_then)
                  (("2" (grind) nil nil)) nil))
                nil))
              nil)
             ("3" (flatten)
              (("3" (use ifReduce_correct_redex_then)
                (("3" (simplify :let-reduce? t)
                  (("3" (split)
                    (("1" (propax) nil nil) ("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (grind) nil nil)
             ("5" (flatten)
              (("5" (skeep)
                (("5" (use ifReduce_correct_count_else)
                  (("5" (prop) nil nil)) nil))
                nil))
              nil)
             ("6" (use ifReduce_correct_redex_else)
              (("6" (simplify :let-reduce? t) (("6" (prop) nil nil))
                nil))
              nil)
             ("7" (grind) nil nil)
             ("8" (use ifReduce_correct_indexing)
              (("8" (prop) nil nil)) nil)
             ("9" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state_matches? const-decl "boolean" reduction_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (ifReduce_correct_count_else formula-decl nil rreduction nil)
    (ifReduce_correct_redex_then formula-decl nil rreduction nil)
    (ifReduce_correct_count_then formula-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (Definition type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (member const-decl "bool" sets nil)
    (release_marked const-decl "rstate" rreduction nil)
    (ifReduce_correct_indexing formula-decl nil rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (translate_refs_value application-judgement "(value?)"
     reduction_props nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (unmark def-decl "IExpression" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (iftRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (purePopDepth formula-decl nil IL nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (ifReduce_correct_release_marked formula-decl nil rreduction nil)
    (store_stillmatch formula-decl nil reduction_props nil)
    (ifReduce_correct_redex_else formula-decl nil rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (pure_count_keep formula-decl nil rreduction nil)
    (stack_subvar_match formula-decl nil reduction_props nil)
    (unmark def-decl "IContext" preprocess nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (ift_condtion_match formula-decl nil reduction_props nil)
    (ifReduce const-decl "estate" reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (release_marked_match formula-decl nil reduction_props nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (get const-decl "(value?)" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (constant adt-constructor-decl "[int -> (constant?)]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak)
  (ifReduce_match-2 nil 3700398730
   ("" (with-labels (skeep) ((iftr stm obj)))
    (("" (expand state_matches?)
      (("" (skeep)
        (("" (inst obj translate)
          (("1"
            (with-labels
             (name "cpl"
                   "IF get(grS`stack)(condition(grS`redex)) = constant(0)
                                              THEN grS WITH [`redex := elseexpr(grS`redex)]
                                              ELSE grS WITH [`redex := thenexpr(grS`redex)]
                                              ENDIF")
             ((cpl_def)))
            (("1"
              (case-replace
               "ifReduce(D)(grS) = release_marked(cpl)(condition(grS`redex))")
              (("1" (use release_marked_match)
                (("1" (split -1)
                  (("1" (propax) nil nil)
                   ("2" (delete obj)
                    (("2" (rewrite purePopDepth)
                      (("1" (use ifReduce_correct_indexing)
                        (("1" (rewrite cpl_def :dir RL)
                          (("1" (simplify) (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (replace cpl_def :dir RL)
                        (("2" (assert) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("3" (use ifReduce_correct_release_marked)
                    (("3" (grind) nil nil)) nil)
                   ("4" (delete obj)
                    (("4" (label obj 1)
                      (("4"
                        (case-replace
                         "(get(grS`stack)(condition(grS`redex)) = constant(0)) = (get(gS`stack)(condition(gS`redex)) = constant(0))")
                        (("1" (expand ifReduce obj)
                          (("1" (replace cpl_def :dir RL)
                            (("1" (lift-if)
                              (("1"
                                (split obj)
                                (("1" (postpone) nil nil)
                                 ("2" (postpone) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand state_matches stm)
                          (("2"
                            (with-labels (flatten)
                             ((trr unm stam stom)))
                            (("2" (expand stack_matches)
                              (("2"
                                (with-labels (flatten) ((staml stamr)))
                                (("2"
                                  (inst
                                   stamr
                                   "index(condition(gS`redex))")
                                  (("1"
                                    (expand get)
                                    (("1"
                                      (replace staml :dir RL)
                                      (("1"
                                        (with-labels
                                         (flatten)
                                         ((stamrl stamrr)))
                                        (("1"
                                          (replace stamrr :dir RL)
                                          (("1"
                                            (case-replace
                                             "index(condition(gS`redex)) = index(condition(grS`redex))")
                                            (("1"
                                              (name-replace
                                               "cd"
                                               "(grS`stack`seq(grS`stack`length - 1 - index(condition(grS`redex))))")
                                              (("1"
                                                (typepred cd)
                                                (("1"
                                                  (iff)
                                                  (("1"
                                                    (split)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (expand value?)
                                                      (("2"
                                                        (split -1)
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil)
                                                         ("3"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (use
                                                 ifReduce_correct_indexing)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (replace trr :dir RL)
                                              (("2"
                                                (apply-eta
                                                 "grS`redex"
                                                 "(ift?)")
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (apply-eta "grS`redex" "(ift?)")
                                    (("2"
                                      (expand union)
                                      (("2"
                                        (expand member)
                                        (("2"
                                          (replace -1 :dir RL)
                                          (("2"
                                            (expand cvars)
                                            (("2"
                                              (expand vars)
                                              (("2"
                                                (expand add)
                                                (("2"
                                                  (case
                                                   "index(condition(grS`redex)) = index(condition(gS`redex))")
                                                  (("1" (prop) nil nil)
                                                   ("2"
                                                    (replace
                                                     trr
                                                     :dir
                                                     RL)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (postpone) nil nil)
                         ("4" (postpone) nil nil)
                         ("5" (use ifReduce_correct_indexing)
                          (("5" (prop) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("5" (delete obj)
                    (("5" (expand ifReduce)
                      (("5" (simplify)
                        (("5" (expand extend)
                          (("5" (replace cpl_def :dir RL)
                            (("5" (simplify)
                              (("5"
                                (assert)
                                (("5"
                                  (rewrite purePopDepth)
                                  (("1"
                                    (rewrite purePopDepth)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand state_matches)
                                        (("1"
                                          (with-labels
                                           (flatten)
                                           ((trr unm stam stom)))
                                          (("1"
                                            (expand stack_matches)
                                            (("1"
                                              (with-labels
                                               (flatten)
                                               ((staml stamr)))
                                              (("1"
                                                (inst
                                                 stamr
                                                 "index(condition(grS`redex))")
                                                (("1"
                                                  (expand extend)
                                                  (("1"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (apply-eta
                                                   "grS`redex"
                                                   "(ift?)")
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (split)
                  (("1" (replace cpl_def :dir RL)
                    (("1" (delete obj)
                      (("1" (simplify) (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (expand ifReduce) (("2" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (expand ifReduce)
                (("2" (replace cpl_def :dir RL)
                  (("2" (lift-if) (("2" (propax) nil nil)) nil)) nil))
                nil)
               ("3" (split)
                (("1" (rewrite purePopDepth)
                  (("1" (use ifReduce_correct_indexing)
                    (("1" (grind) nil nil)) nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (use ifReduce_correct_release_marked)
                  (("2" (grind) nil nil)) nil))
                nil)
               ("4" (grind) nil nil))
              nil)
             ("2" (flatten)
              (("2" (skeep)
                (("2" (use ifReduce_correct_count_then)
                  (("2" (prop) nil nil)) nil))
                nil))
              nil)
             ("3" (use ifReduce_correct_redex_then)
              (("3" (simplify :let-reduce? t) (("3" (prop) nil nil))
                nil))
              nil)
             ("4" (grind) nil nil)
             ("5" (flatten)
              (("5" (skeep)
                (("5" (use ifReduce_correct_count_else)
                  (("5" (prop) nil nil)) nil))
                nil))
              nil)
             ("6" (use ifReduce_correct_redex_else)
              (("6" (simplify :let-reduce? t) (("6" (prop) nil nil))
                nil))
              nil)
             ("7" (grind) nil nil)
             ("8" (use ifReduce_correct_indexing)
              (("8" (prop) nil nil)) nil)
             ("9" (grind) nil nil))
            nil)
           ("2" (expand ifReduce)
            (("2" (expand release_marked) (("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil)
  (ifReduce_match-1 nil 3700318480
   ("" (with-labels (skeep) ((iftr stm obj)))
    (("" (expand state_matches?)
      (("" (skeep)
        (("" (inst obj translate)
          (("1"
            (name "cpl"
                  "IF get(grS`stack)(condition(grS`redex)) = constant(0)
                                     THEN grS WITH [`redex := elseexpr(grS`redex)]
                                     ELSE grS WITH [`redex := thenexpr(grS`redex)]
                                     ENDIF")
            (("1"
              (case-replace
               "ifReduce(D)(grS) = release_marked(cpl)(condition(grS`redex))")
              (("1" (use release_marked_match)
                (("1" (split -1)
                  (("1" (propax) nil nil)
                   ("2" (rewrite purePopDepth)
                    (("1" (use ifReduce_correct_indexing)
                      (("1" (prop)
                        (("1" (assert) (("1" (grind) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("3" (use ifReduce_correct_release_marked)
                    (("3" (grind) nil nil)) nil)
                   ("4" (delete obj)
                    (("4" (expand ifReduce 1)
                      (("4" (lift-if)
                        (("4" (split)
                          (("1" (flatten)
                            (("1"
                              (case "get(grS`stack)(condition(grS`redex)) = constant(0)")
                              (("1"
                                (assert)
                                (("1"
                                  (expand state_matches)
                                  (("1"
                                    (split 1)
                                    (("1" (postpone) nil nil)
                                     ("2" (grind) nil nil)
                                     ("3" (postpone) nil nil)
                                     ("4" (postpone) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (postpone) nil nil))
                              nil))
                            nil)
                           ("2" (postpone) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("5" (delete obj)
                    (("5" (expand ifReduce)
                      (("5" (simplify)
                        (("5" (case-replace "cpl`stack = grS`stack")
                          (("1" (rewrite purePopDepth)
                            (("1" (expand state_matches)
                              (("1"
                                (with-labels
                                 (flatten)
                                 ((trr unm stam stom)))
                                (("1"
                                  (expand stack_matches)
                                  (("1"
                                    (with-labels
                                     (flatten)
                                     ((staml stamr)))
                                    (("1"
                                      (inst
                                       stamr
                                       "index(condition(grS`redex))")
                                      (("1"
                                        (expand extend)
                                        (("1"
                                          (case-replace
                                           "cpl`domain = grS`domain")
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (case-replace
                                               "cpl`count = grS`count")
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (skeep)
                                                (("2"
                                                  (case-replace
                                                   "cpl`domain = grS`domain")
                                                  (("2"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand union)
                                        (("2"
                                          (expand member)
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (apply-eta
                                               "grS`redex"
                                               "(ift?)")
                                              (("2"
                                                (replace -1 :dir RL)
                                                (("2"
                                                  (expand cvars)
                                                  (("2"
                                                    (expand vars)
                                                    (("2"
                                                      (expand add)
                                                      (("2"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand ifReduce)
                  (("2" (simplify)
                    (("2" (delete obj) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (delete obj)
                (("2" (expand ifReduce)
                  (("2" (replace -1 :dir RL)
                    (("2" (lift-if) (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("3" (split)
                (("1" (rewrite purePopDepth)
                  (("1" (use ifReduce_correct_indexing)
                    (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (use ifReduce_correct_release_marked)
                  (("2" (grind) nil nil)) nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (lemma ifReduce_correct_count_then)
                (("2" (inst?)
                  (("2" (skeep)
                    (("2" (inst?) (("2" (prop) nil nil)) nil)) nil))
                  nil))
                nil))
              nil)
             ("3" (use ifReduce_correct_redex_then)
              (("3" (simplify :let-reduce? t) (("3" (prop) nil nil))
                nil))
              nil)
             ("4" (grind) nil nil)
             ("5" (flatten)
              (("5" (skeep)
                (("5" (use ifReduce_correct_count_else)
                  (("5" (prop) nil nil)) nil))
                nil))
              nil)
             ("6" (use ifReduce_correct_redex_else)
              (("6" (simplify :let-reduce? t) (("6" (prop) nil nil))
                nil))
              nil)
             ("7" (grind) nil nil)
             ("8" (use ifReduce_correct_indexing)
              (("8" (prop) nil nil)) nil)
             ("9" (grind) nil nil))
            nil)
           ("2" (expand ifReduce)
            (("2" (expand release_marked)
              (("2" (simplify) (("2" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (lookupReduce_match_TCC1 0
  (lookupReduce_match_TCC1-1 nil 3700234159
   ("" (with-labels (skeep) (lrr stm obj))
    (("" (expand state_matches?)
      (("" (skeep)
        (("" (expand lookupRedex?)
          (("" (expand state_matches) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((state_matches? const-decl "boolean" reduction_props nil)
    (lookupRedex? const-decl "bool" IL nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (unmark def-decl "IExpression" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (lookupReduce_match 0
  (lookupReduce_match-1 nil 3700505818
   ("" (with-labels (skeep) ((lookup stm obj)))
    (("" (expand state_matches?)
      (("" (skeep)
        (("" (inst obj translate)
          (("" (case "gS`redex = unmark(grS`redex)")
            (("1" (label redex_unm -1)
              (("1" (expand lookupReduce) (("1" (postpone) nil nil))
                nil))
              nil)
             ("2" (expand state_matches stm)
              (("2" (use translate_refs_pure_eq)
                (("2" (use unmark_pure)
                  (("1" (assert) nil nil)
                   ("2" (delete stm obj) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (newintReduce_match_TCC1 0
  (newintReduce_match_TCC1-1 nil 3700234159 ("" (grind) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (unmark def-decl "IExpression" preprocess nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (newintRedex? const-decl "bool" IL nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (newintReduce_match 0
  (newintReduce_match-2 nil 3700589475
   ("" (with-labels (skeep) ((nir stm ndr obj)))
    (("" (expand state_matches?)
      (("" (skeep)
        ((""
          (inst obj
           "translate WITH [(least_out(grS`domain)) := least_out(gS`domain)]")
          ((""
            (case "state_matches(gS, grS)(translate WITH [(least_out(grS`domain)) := least_out(gS`domain)])")
            (("1" (expand newintReduce)
              (("1" (label nstm -1)
                (("1" (expand state_matches (nstm obj))
                  (("1" (flatten)
                    (("1" (split)
                      (("1" (grind) nil nil) ("2" (propax) nil nil)
                       ("3" (case-replace "popDepth(grS`redex) = 0")
                        (("1" (expand popDepth obj)
                          (("1"
                            (case-replace
                             "cvars(ref(least_out(grS`domain))) = cvars(grS`redex)")
                            (("1" (grind) nil nil)) nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("4" (expand store_matches)
                        (("4" (skeep :preds? t)
                          (("4"
                            (case-replace "r = least_out(grS`domain)")
                            (("1" (simplify) (("1" (grind) nil nil))
                              nil)
                             ("2" (simplify)
                              (("2"
                                (lift-if)
                                (("2"
                                  (simplify)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (case "gS`domain(translate(r))")
                                      (("1"
                                        (case
                                         "translate(r) = least_out(gS`domain)")
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (split)
                                            (("1" (grind) nil nil)
                                             ("2" (grind) nil nil)
                                             ("3" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (delete obj)
                                        (("2"
                                          (use match_domain)
                                          (("2"
                                            (split)
                                            (("1" (propax) nil nil)
                                             ("2" (propax) nil nil)
                                             ("3" (propax) nil nil)
                                             ("4" (grind) nil nil)
                                             ("5" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (lemma state_matches_eq)
              (("2" (inst?)
                (("2" (inst -1 translate)
                  (("2" (split -1)
                    (("1" (propax) nil nil) ("2" (propax) nil nil)
                     ("3" (skeep :preds? t)
                      (("3" (lift-if) (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (match_domain formula-decl nil reduction_props nil)
    (member const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (grS skolem-const-decl "goodrstate" reduction_props nil)
    (r skolem-const-decl "(add(least_out(grS`domain), grS`domain))"
     reduction_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (translate_refs_value application-judgement "(value?)"
     reduction_props nil)
    (union const-decl "set" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (size shared-adt-accessor-decl
          "[{x: IExpression | newint?(x) OR newref?(x)} -> nat]"
          IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (constant adt-constructor-decl "[int -> (constant?)]"
     IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (unmark def-decl "IExpression" preprocess nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (newintReduce const-decl "estate" reduction nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (state_matches_eq formula-decl nil reduction_props nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (goodstate type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (state_matches? const-decl "boolean" reduction_props nil))
   nil)
  (newintReduce_match-1 nil 3700579735
   ("" (with-labels (skeep) ((nir stm obj)))
    (("" (expand state_matches?)
      (("" (skeep)
        ((""
          (inst obj
           "translate WITH [(least_out(grS`domain)) := least_out(gS`domain)]")
          ((""
            (case "state_matches(gS, grS)(translate WITH [(least_out(grS`domain)) := least_out(gS`domain)])")
            (("1" (expand newintReduce)
              (("1" (label nstm -1)
                (("1" (expand state_matches (nstm obj))
                  (("1" (flatten)
                    (("1" (split)
                      (("1" (grind) nil nil) ("2" (propax) nil nil)
                       ("3" (case-replace "popDepth(grS`redex) = 0")
                        (("1" (expand popDepth obj)
                          (("1"
                            (case-replace
                             "cvars(ref(least_out(grS`domain))) = cvars(grS`redex)")
                            (("1" (grind) nil nil)) nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("4" (expand store_matches)
                        (("4" (skeep :preds? t)
                          (("4"
                            (case-replace "r = least_out(grS`domain)")
                            (("1" (simplify) (("1" (grind) nil nil))
                              nil)
                             ("2" (simplify)
                              (("2"
                                (lift-if)
                                (("2"
                                  (simplify)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (case "gS`domain(translate(r))")
                                      (("1"
                                        (case
                                         "translate(r) = least_out(gS`domain)")
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (split)
                                            (("1" (grind) nil nil)
                                             ("2" (grind) nil nil)
                                             ("3" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (delete obj)
                                        (("2"
                                          (use match_domain)
                                          (("2"
                                            (split)
                                            (("1" (propax) nil nil)
                                             ("2" (postpone) nil nil)
                                             ("3" (propax) nil nil)
                                             ("4" (grind) nil nil)
                                             ("5" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (lemma state_matches_eq)
              (("2" (inst?)
                (("2" (inst -1 translate)
                  (("2" (split -1)
                    (("1" (propax) nil nil) ("2" (propax) nil nil)
                     ("3" (skeep :preds? t)
                      (("3" (lift-if) (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (newrefReduce_match_TCC1 0
  (newrefReduce_match_TCC1-1 nil 3700234159 ("" (grind) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (unmark def-decl "IExpression" preprocess nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (newrefRedex? const-decl "bool" IL nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (newrefReduce_match 0
  (newrefReduce_match-1 nil 3700589504
   ("" (with-labels (skeep) ((nir stm ndr obj)))
    (("" (expand state_matches?)
      (("" (skeep)
        ((""
          (inst obj
           "translate WITH [(least_out(grS`domain)) := least_out(gS`domain)]")
          ((""
            (case "state_matches(gS, grS)(translate WITH [(least_out(grS`domain)) := least_out(gS`domain)])")
            (("1" (expand newrefReduce)
              (("1" (label nstm -1)
                (("1" (expand state_matches (nstm obj))
                  (("1" (flatten)
                    (("1" (split)
                      (("1" (grind) nil nil) ("2" (propax) nil nil)
                       ("3" (case-replace "popDepth(grS`redex) = 0")
                        (("1" (expand popDepth obj)
                          (("1"
                            (case-replace
                             "cvars(ref(least_out(grS`domain))) = cvars(grS`redex)")
                            (("1" (grind) nil nil)) nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("4" (expand store_matches)
                        (("4" (skeep :preds? t)
                          (("4"
                            (case-replace "r = least_out(grS`domain)")
                            (("1" (simplify) (("1" (grind) nil nil))
                              nil)
                             ("2" (simplify)
                              (("2"
                                (lift-if)
                                (("2"
                                  (simplify)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (case "gS`domain(translate(r))")
                                      (("1"
                                        (case
                                         "translate(r) = least_out(gS`domain)")
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (split)
                                            (("1" (grind) nil nil)
                                             ("2" (grind) nil nil)
                                             ("3" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (delete obj)
                                        (("2"
                                          (use match_domain)
                                          (("2"
                                            (split)
                                            (("1" (propax) nil nil)
                                             ("2" (propax) nil nil)
                                             ("3" (propax) nil nil)
                                             ("4" (grind) nil nil)
                                             ("5" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (lemma state_matches_eq)
              (("2" (inst?)
                (("2" (inst -1 translate)
                  (("2" (split -1)
                    (("1" (propax) nil nil) ("2" (propax) nil nil)
                     ("3" (skeep :preds? t)
                      (("3" (lift-if) (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state_matches? const-decl "boolean" reduction_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (state_matches_eq formula-decl nil reduction_props nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (newrefReduce const-decl "estate" reduction nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (unmark def-decl "IExpression" preprocess nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (newrefRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (size shared-adt-accessor-decl
          "[{x: IExpression | newint?(x) OR newref?(x)} -> nat]"
          IExpression_adt nil)
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (union const-decl "set" sets nil)
    (translate_refs_value application-judgement "(value?)"
     reduction_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (r skolem-const-decl "(add(least_out(grS`domain), grS`domain))"
     reduction_props nil)
    (grS skolem-const-decl "goodrstate" reduction_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (match_domain formula-decl nil reduction_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (popReduce_match_TCC1 0
  (popReduce_match_TCC1-1 nil 3700234159
   ("" (with-labels (skeep) ((popr ndr stm obj)))
    (("" (expand state_matches?)
      (("" (skeep)
        (("" (expand state_matches)
          (("" (with-labels (flatten) ((trr unm stam stom)))
            (("" (expand popRedex?)
              (("" (replace trr :dir RL)
                (("" (apply-eta "grS`redex" "(pop?)")
                  (("" (replace -1 :dir RL)
                    (("" (expand unmark)
                      (("" (expand translate_refs)
                        (("" (expand atom?)
                          (("" (expand value?) (("" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state_matches? const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (popRedex? const-decl "bool" IL nil)
    (IExpression_pop_eta formula-decl nil IExpression_adt nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (unmark def-decl "IContext" preprocess nil)
    (unmark def-decl "IExpression" preprocess nil)
    (atom? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (translate_refs def-decl "IExpression" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (popReduce_match_TCC2 0
  (popReduce_match_TCC2-1 nil 3700234159 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (letReduce_match_TCC1 0
  (letReduce_match_TCC1-1 nil 3700234159
   ("" (with-labels (skeep) ((plr stm obj)))
    (("" (expand state_matches?)
      (("" (skeep)
        (("" (expand state_matches)
          (("" (with-labels (flatten) ((trr unm stam stom)))
            (("" (replace trr :dir RL)
              (("" (apply-eta "grS`redex" "(letexpr?)")
                (("1" (replace -1 :dir RL)
                  (("1" (expand unmark)
                    (("1" (expand translate_refs)
                      (("1" (expand pureLetRedex?)
                        (("1" (expand letRedex?)
                          (("1" (split obj)
                            (("1" (expand atom?)
                              (("1"
                                (expand value?)
                                (("1" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (use translate_refs_pure)
                              (("2"
                                (use unmark_pure)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state_matches? const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (letRedex? const-decl "bool" IL nil)
    (translate_refs_pure recursive-judgement-axiom nil reduction_props
     nil)
    (pure? def-decl "bool" IL nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (unmark_pure recursive-judgement-axiom nil preprocess nil)
    (atom? const-decl "bool" IL nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (pureLetRedex? const-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (unmark def-decl "IContext" preprocess nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_match_TCC1 0
  (updateReduce_match_TCC1-1 nil 3700234159 ("" (grind) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (unmark def-decl "IExpression" preprocess nil)
    (translate_refs def-decl "IExpression" reduction_props nil)
    (unmark_contextPure rec-application-judgement "(contextPure?)"
     preprocess nil)
    (translate_refs_contextPure rec-application-judgement
     "(contextPure?)" reduction_props nil)
    (updateRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (updateReduce_match_TCC2 0
  (updateReduce_match_TCC2-1 nil 3700234159 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (updateRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (stack_matches const-decl "boolean" reduction_props nil)
    (store_matches const-decl "boolean" reduction_props nil)
    (state_matches const-decl "boolean" reduction_props nil)
    (state_matches? const-decl "boolean" reduction_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil)))

