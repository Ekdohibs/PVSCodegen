("intermediateLanguage" intermediateLanguage popDepth_TCC5 0 (popDepth_TCC5-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage popDepth_TCC4 0 (popDepth_TCC4-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage popDepth_TCC3 0 (popDepth_TCC3-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage popDepth_TCC2 0 (popDepth_TCC2-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage pure?_TCC4 0 (pure?_TCC4-1 nil 3645328217 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage purePopDepthContext 0 (purePopDepthContext-1 nil 3645515823 ("" (induct-and-simplify "K") (("" (postpone) nil nil)) nil) nil shostak))("intermediateLanguage" intermediateLanguage refcount_TCC4 0 (refcount_TCC4-1 nil 3645614580 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refcount_TCC3 0 (refcount_TCC3-1 nil 3645614580 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage estate_TCC1 0 (estate_TCC1-1 nil 3645702721 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage fill_TCC1 0 (fill_TCC1-1 nil 3645177900 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IContext])" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage fill_TCC2 0 (fill_TCC2-1 nil 3645177900 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IContext])" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage context_lemma 0 (context_lemma-1 nil 3645177902 ("" (induct "A") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (inst + "hole" "application(application1_var, application2_var)") (("3" (grind) nil nil)) nil)) nil) ("4" (skeep) (("4" (ground) (("1" (inst + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (inst + "letc(K, letexpr2_var)" "B") (("3" (grind) nil nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (inst + "letc(K!1, letexpr2_var)" "B!1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (inst + "hole" "ift(ift1_var, ift2_var, ift3_var)") (("5" (grind) nil nil)) nil)) nil) ("6" (skeep*) (("6" (inst + "hole" "update(update1_var, update2_var, update3_var)") (("6" (grind) nil nil)) nil)) nil) ("7" (skeep*) (("7" (inst + "hole" "lookup(lookup1_var, lookup2_var)") (("7" (grind) nil nil)) nil)) nil) ("8" (skeep) (("8" (inst + "hole" "newint(newint1_var)") (("8" (grind) nil nil)) nil)) nil) ("9" (skeep) (("9" (inst + "hole" "newref(newref1_var)") (("9" (grind) nil nil)) nil)) nil) ("10" (skeep) (("10" (ground) (("1" (inst + "hole" "pop(pop1_var)") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst + "popc(K)" "B") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("11" (skeep) (("11" (inst + "hole" "ref(ref1_var)") (("11" (grind) nil nil)) nil)) nil)) nil) ((ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (popc? adt-recognizer-decl "[IContext -> boolean]" intermediateLanguage nil) (popc adt-constructor-decl "[IContext -> (popc?)]" intermediateLanguage nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (newref adt-constructor-decl "[nat -> (newref?)]" IExpression_adt nil) (newref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (newint adt-constructor-decl "[nat -> (newint?)]" IExpression_adt nil) (newint? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lookup? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lookup adt-constructor-decl "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (update adt-constructor-decl "[[(variable?), (variable?), (variable?)] -> (update?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (letc? adt-recognizer-decl "[IContext -> boolean]" intermediateLanguage nil) (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]" intermediateLanguage nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (application adt-constructor-decl "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (hole adt-constructor-decl "(hole?)" intermediateLanguage nil) (hole? adt-recognizer-decl "[IContext -> boolean]" intermediateLanguage nil) (popRedex? const-decl "bool" intermediateLanguage nil) (newrefRedex? const-decl "bool" intermediateLanguage nil) (newintRedex? const-decl "bool" intermediateLanguage nil) (lookupRedex? const-decl "bool" intermediateLanguage nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (iftRedex? const-decl "bool" intermediateLanguage nil) (applyRedex? const-decl "bool" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (IExpression_induction formula-decl nil IExpression_adt nil) (fill def-decl "IExpression" intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (redex? const-decl "bool" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) shostak))("intermediateLanguage" intermediateLanguage buildContext_TCC1 0 (buildContext_TCC1-1 nil 3645328217 ("" (skosimp*) (("" (expand "fill" +) (("" (typepred "v!1(B!1)") (("" (assert) nil nil)) nil)) nil)) nil) ((fill def-decl "IExpression" intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil intermediateLanguage nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC2 0 (buildContext_TCC2-1 nil 3645328217 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC3 0 (buildContext_TCC3-1 nil 3645328217 ("" (skosimp*) (("" (expand "fill" +) (("" (typepred "v!1(B!1)") (("" (assert) nil nil)) nil)) nil)) nil) ((fill def-decl "IExpression" intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil intermediateLanguage nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC4 0 (buildContext_TCC4-1 nil 3645328217 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC5 0 (buildContext_TCC5-1 nil 3645328217 ("" (grind) nil nil) ((fill def-decl "IExpression" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage context_composition 0 (context_composition-1 nil 3645324754 ("" (induct-and-simplify "K1") nil nil) ((IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (fill def-decl "IExpression" intermediateLanguage nil) (compose def-decl "IContext" intermediateLanguage nil) (IContext_induction formula-decl nil intermediateLanguage nil)) shostak))("intermediateLanguage" intermediateLanguage pure?_TCC1 0 (pure?_TCC1-1 nil 3645328217 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure?_TCC2 0 (pure?_TCC2-1 nil 3645328217 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure?_TCC3 0 (pure?_TCC3-1 nil 3645328217 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure_contextPure 0 (pure_contextPure-1 nil 3645472996 ("" (induct-and-simplify "A") nil nil) ((IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IExpression_induction formula-decl nil IExpression_adt nil)) shostak))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC1 0 (buildcontextPure_TCC1-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC2 0 (buildcontextPure_TCC2-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC3 0 (buildcontextPure_TCC3-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC4 0 (buildcontextPure_TCC4-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC5 0 (buildcontextPure_TCC5-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((pure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage contextPurefill 0 (contextPurefill-1 nil 3645477567 ("" (induct-and-simplify "K") nil nil) ((IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext_induction formula-decl nil intermediateLanguage nil)) shostak))("intermediateLanguage" intermediateLanguage pureLetRedex?_TCC1 0 (pureLetRedex?_TCC1-1 nil 3645472989 ("" (subtype-tcc) nil nil) ((value? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage pureIftRedex?_TCC1 0 (pureIftRedex?_TCC1-1 nil 3645472989 ("" (subtype-tcc) nil nil) ((iftRedex? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC1 0 (refs_TCC1-1 nil 3645594035 ("" (typepred "IExpression_adt.<<") (("" (expand "strict_well_founded?") (("" (expand "strict_order?") (("" (ground) (("" (hide -1 -2) (("" (grind :if-match nil) (("" (inst - "p!1") (("" (ground) (("1" (skosimp*) (("1" (inst + "y!2") (("1" (skeep) (("1" (inst?) (("1" (typepred "x_1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "y!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (inst + "y!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (well_founded? const-decl "bool" orders nil) (contextPure? def-decl "bool" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (p!1 skolem-const-decl "pred[(contextPure?)]" intermediateLanguage nil) (y!2 skolem-const-decl "(extend[IExpression, (contextPure?), bool, FALSE](p!1))" intermediateLanguage nil) (x_1 skolem-const-decl "(p!1)" intermediateLanguage nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (strict_order? const-decl "bool" orders nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC2 0 (refs_TCC2-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC3 0 (refs_TCC3-1 nil 3645594035 ("" (skeep :preds? t) (("" (grind) nil nil)) nil) ((contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC4 0 (refs_TCC4-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC5 0 (refs_TCC5-1 nil 3645594035 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC6 0 (refs_TCC6-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC7 0 (refs_TCC7-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage pure_refs_TCC1 0 (pure_refs_TCC1-1 nil 3645614580 ("" (skeep) (("" (rewrite "pure_contextPure") nil nil)) nil) ((pure_contextPure formula-decl nil intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure_refs 0 (pure_refs-1 nil 3645614582 ("" (induct-and-simplify "A") (("" (rewrite "pure_contextPure") nil nil)) nil) ((pure_contextPure formula-decl nil intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (IExpression_induction formula-decl nil IExpression_adt nil)) shostak))("intermediateLanguage" intermediateLanguage refs_fill_TCC1 0 (refs_fill_TCC1-1 nil 3645614695 ("" (skeep) (("" (rewrite "contextPurefill") (("" (ground) nil nil)) nil)) nil) ((contextPurefill formula-decl nil intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (IContext type-decl nil intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refs_fill 0 (refs_fill-1 nil 3645614697 ("" (induct-and-simplify "K") (("1" (apply-extensionality) nil nil) ("2" (apply-extensionality) nil nil) ("3" (rewrite "contextPurefill") nil nil)) nil) ((contextPurefill formula-decl nil intermediateLanguage nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (fill def-decl "IExpression" intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (IContext type-decl nil intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (refs def-decl "bool" intermediateLanguage nil) (IContext_induction formula-decl nil intermediateLanguage nil)) shostak))("intermediateLanguage" intermediateLanguage refcount_TCC1 0 (refcount_TCC1-1 nil 3645594035 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage refcount_TCC2 0 (refcount_TCC2-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage push_TCC1 0 (push_TCC1-1 nil 3645226267 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (Stack type-eq-decl nil intermediateLanguage nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage push_TCC2 0 (push_TCC2-1 nil 3645226267 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("intermediateLanguage" intermediateLanguage pop_TCC1 0 (pop_TCC1-1 nil 3645226267 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage pop_TCC2 0 (pop_TCC2-1 nil 3645226267 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage get_TCC1 0 (get_TCC1-1 nil 3645245227 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("intermediateLanguage" intermediateLanguage popDepth_TCC1 0 (popDepth_TCC1-1 nil 3645226267 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage popdepth_fill 0 (popdepth_fill-1 nil 3645226269 ("" (induct-and-simplify "K") nil nil) ((IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (fill def-decl "IExpression" intermediateLanguage nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IContext_induction formula-decl nil intermediateLanguage nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak))("intermediateLanguage" intermediateLanguage purePopDepth 0 (purePopDepth-1 nil 3645515794 ("" (induct-and-simplify "A") nil nil) ((IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression_induction formula-decl nil IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak))("intermediateLanguage" intermediateLanguage vars_TCC1 0 (vars_TCC1-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC2 0 (vars_TCC2-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC3 0 (vars_TCC3-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC4 0 (vars_TCC4-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC5 0 (vars_TCC5-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC6 0 (vars_TCC6-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_decompose 0 (vars_decompose-1 nil 3645245511 ("" (induct-and-simplify "K") nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (fill def-decl "IExpression" intermediateLanguage nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IContext_induction formula-decl nil intermediateLanguage nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak))("intermediateLanguage" intermediateLanguage letReduce_TCC1 0 (letReduce_TCC1-1 nil 3645245508 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (pureLetRedex? const-decl "bool" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (vars def-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC2 0 (letReduce_TCC2-1 nil 3645245508 ("" (skosimp*) (("" (rewrite "contextPurefill") (("1" (typepred "A!1") (("1" (expand "contextPure?" +) (("1" (ground) (("1" (grind) (("1" (rewrite "pure_contextPure") nil nil) ("2" (rewrite "pure_contextPure") nil nil) ("3" (rewrite "pure_contextPure") nil nil) ("4" (rewrite "pure_contextPure") nil nil)) nil) ("2" (skeep) (("2" (rewrite "refs_fill") (("1" (typepred "gS!1`expr") (("1" (typepred "gS!1") (("1" (replace -) (("1" (hide -1) (("1" (inst?) (("1" (ground) (("1" (rewrite "refs_fill") (("1" (expand "pureLetRedex?") (("1" (ground) (("1" (use "pure_refs") (("1" (ground) (("1" (inst?) (("1" (expand "refs" -) (("1" (use "pure_refs") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "contextPurefill") (("2" (expand "pureLetRedex?") (("2" (ground) (("2" (expand "contextPure?" +) (("2" (rewrite "pure_contextPure") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "pureLetRedex?") (("3" (ground) (("3" (skeep) (("3" (rewrite "vars_decompose") (("3" (ground) (("1" (typepred "K!1") (("1" (typepred "gS!1") (("1" (typepred "gS!1`expr") (("1" (inst?) (("1" (inst - "i") (("1" (replace -3 :hide? t) (("1" (rewrite "vars_decompose") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "gS!1`expr") (("2" (hide -1 -2) (("2" (typepred "gS!1") (("2" (replace - :hide? t) (("2" (inst - "i") (("2" (rewrite "vars_decompose") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "A!1") (("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((contextPurefill formula-decl nil intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (pureLetRedex? const-decl "bool" intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (domainValue? const-decl "bool" intermediateLanguage nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (popDepth def-decl "nat" intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (Stack type-eq-decl nil intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (vars def-decl "bool" intermediateLanguage nil) (refs def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Store type-eq-decl nil intermediateLanguage nil) (pure_refs formula-decl nil intermediateLanguage nil) (refs_fill formula-decl nil intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (pure_contextPure formula-decl nil intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC3 0 (letReduce_TCC3-1 nil 3645245508 ("" (skosimp*) (("" (typepred "gS!1`stack") (("" (typepred "gS!1`expr") (("" (typepred "gS!1") (("" (replace - :hide? t) (("" (rewrite "popdepth_fill") (("" (typepred "A!1") (("" (hide -3) (("" (inst - "index(letrhs(A!1)) - popDepth(K!1)") (("1" (rewrite "vars_decompose") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pureLetRedex? const-decl "bool" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (domainValue? const-decl "bool" intermediateLanguage nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (Stack type-eq-decl nil intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (vars def-decl "bool" intermediateLanguage nil) (refs def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Store type-eq-decl nil intermediateLanguage nil) (popDepth def-decl "nat" intermediateLanguage nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (atom? const-decl "bool" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (K!1 skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (popDepth def-decl "nat" intermediateLanguage nil) (A!1 skolem-const-decl "(pureLetRedex?)" intermediateLanguage nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC4 0 (letReduce_TCC4-1 nil 3645245508 ("" (skosimp*) (("" (typepred "A!1") (("" (grind) nil nil)) nil)) nil) ((pureLetRedex? const-decl "bool" intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC5 0 (letReduce_TCC5-1 nil 3645477565 ("" (skosimp*) (("" (ground) (("1" (typepred "gS!1`stack") (("1" (rewrite "popdepth_fill") (("1" (typepred "gS!1") (("1" (replace - :hide? t) (("1" (rewrite "popdepth_fill") (("1" (rewrite "popDepth" +) (("1" (typepred "A!1") (("1" (expand "pureLetRedex?") (("1" (ground) (("1" (forward-chain "purePopDepth") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "i!1") (("2" (lift-if) (("2" (ground) (("1" (expand "push") (("1" (ground) (("1" (typepred "gS!1`stack") (("1" (expand "get") (("1" (inst?) (("1" (typepred "A!1") (("1" (typepred "gS!1`expr") (("1" (hide -1 -2) (("1" (typepred "gS!1") (("1" (replace - :hide? t) (("1" (assert) (("1" (inst - "index(letrhs(A!1)) - gS!1`stack`length") (("1" (rewrite "vars_decompose") (("1" (ground) (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "gS!1`stack") (("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (typepred "gS!1`stack") (("2" (grind) (("2" (typepred "gS!1`expr") (("2" (typepred "gS!1") (("2" (replace - :hide? t) (("2" (inst?) (("2" (rewrite "refs_fill") (("2" (ground) (("2" (typepred "A!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (purePopDepth formula-decl nil intermediateLanguage nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (push const-decl "Stack" intermediateLanguage nil) (get const-decl "(value?)" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (popDepth def-decl "nat" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (vars def-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (pureLetRedex? const-decl "bool" intermediateLanguage nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (gS!1 skolem-const-decl "{gS | gS`expr = fill(K!1, A!1)}" intermediateLanguage nil) (A!1 skolem-const-decl "(pureLetRedex?)" intermediateLanguage nil) (K!1 skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refs_fill formula-decl nil intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC1 0 (updateReduce_TCC1-1 nil 3645791010 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (vars def-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC2 0 (updateReduce_TCC2-1 nil 3645791010 ("" (skeep* :preds? t) (("" (replace -6 :hide? t) (("" (hide -2) (("" (inst - "index(target(A)) - stack`length") (("1" (replace -8 :hide? t) (("1" (rewrite "vars_decompose") (("1" (hide -5) (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (stack skolem-const-decl "{S: Stack |
   popDepth(gS`expr) = S`length AND
    (FORALL (i: below(S`length)): domainValue?(gS`store`domain)(S`seq(i)))}" intermediateLanguage nil) (gS skolem-const-decl "{gS | gS`expr = fill(K, A)}" intermediateLanguage nil) (K skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (domainValue? const-decl "bool" intermediateLanguage nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (vars def-decl "bool" intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (popDepth def-decl "nat" intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (A skolem-const-decl "(updateRedex?)" intermediateLanguage nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC3 0 (updateReduce_TCC3-1 nil 3645791010 ("" (skeep* :preds? t) (("" (hide -3) (("" (replace -6) (("" (replace -11) (("" (inst - "index(lhs(A)) - stack`length") (("1" (rewrite "vars_decompose") (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (get const-decl "(value?)" intermediateLanguage nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (A skolem-const-decl "(updateRedex?)" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars def-decl "bool" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (K skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (gS skolem-const-decl "{gS | gS`expr = fill(K, A)}" intermediateLanguage nil) (stack skolem-const-decl "{S: Stack |
   popDepth(gS`expr) = S`length AND
    (FORALL (i: below(S`length)): domainValue?(gS`store`domain)(S`seq(i)))}" intermediateLanguage nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC4 0 (updateReduce_TCC4-1 nil 3645791010 ("" (skeep* :preds? t) (("" (hide -3 -4 10) (("" (replace -6 :hide? t) (("" (replace -10 :hide? t) (("" (inst - "index(rhs(A)) - stack`length") (("1" (rewrite "vars_decompose") (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (get const-decl "(value?)" intermediateLanguage nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (A skolem-const-decl "(updateRedex?)" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars def-decl "bool" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (K skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (gS skolem-const-decl "{gS | gS`expr = fill(K, A)}" intermediateLanguage nil) (stack skolem-const-decl "{S: Stack |
   popDepth(gS`expr) = S`length AND
    (FORALL (i: below(S`length)): domainValue?(gS`store`domain)(S`seq(i)))}" intermediateLanguage nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC5 0 (updateReduce_TCC5-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC6 0 (updateReduce_TCC6-1 nil 3645791010 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" intermediateLanguage nil) (add const-decl "(nonempty?)" sets nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC7 0 (updateReduce_TCC7-1 nil 3645791010 ("" (skeep* :preds? t) (("" (inst - "refindex(aval)") (("" (assert) (("" (replace -14) (("" (replace -9) (("" (rewrite "refs_fill") (("" (hide-all-but (-8 2 4 -11 -15)) (("" (grind :if-match nil) (("" (inst?) (("1" (ground) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((get const-decl "(value?)" intermediateLanguage nil) (add const-decl "(nonempty?)" sets nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC8 0 (updateReduce_TCC8-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC9 0 (updateReduce_TCC9-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC10 0 (updateReduce_TCC10-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC11 0 (updateReduce_TCC11-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("IL" IL popDepth_TCC1 0 (popDepth_TCC1-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL refcount_TCC2 0 (refcount_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_fill_TCC1 0 (refs_fill_TCC1-1 nil 3646033320 ("" (skeep) (("" (rewrite "contextPurefill") (("" (ground) nil nil)) nil)) nil) ((IContext type-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (contextPurefill formula-decl nil IL nil)) nil))("IL" IL pure_refs_TCC1 0 (pure_refs_TCC1-1 nil 3646033320 ("" (skeep) (("" (rewrite "pure_contextPure") nil nil)) nil) ((IExpression type-decl nil IExpression_adt nil) (pure_contextPure formula-decl nil IL nil)) nil))("IL" IL refs_TCC9 0 (refs_TCC9-1 nil 3646130633 ("" (termination-tcc) nil nil) nil nil))("IL" IL refs_TCC8 0 (refs_TCC8-1 nil 3646130633 ("" (subtype-tcc) nil nil) nil nil))("IL" IL refs_TCC7 0 (refs_TCC7-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_TCC6 0 (refs_TCC6-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_TCC5 0 (refs_TCC5-1 nil 3646033320 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL refs_TCC4 0 (refs_TCC4-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_TCC3 0 (refs_TCC3-1 nil 3646033320 ("" (skeep :preds? t) (("" (grind) nil nil)) nil) ((contextPure? def-decl "bool" IL nil)) nil))("IL" IL refs_TCC2 0 (refs_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL push_TCC2 0 (push_TCC2-1 nil 3646033320 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("IL" IL push_TCC1 0 (push_TCC1-1 nil 3646033320 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (Stack type-eq-decl nil IL nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("finite_set_theorems" finite_set_theorems nat_fullset_infinite 0 (nat_fullset_infinite-1 nil 3649860953 ("" (induct "n") (("1" (skeep) (("1" (typepred "f(0)") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep* :preds? t) (("2" (inst + "LAMBDA (i: nat): IF f(i + 1) = 0 THEN f(0) - 1 ELSE f(i + 1) - 1 ENDIF") (("1" (expand "injective?") (("1" (skeep) (("1" (apply (repeat (lift-if))) (("1" (ground) (("1" (inst - "x1 + 1" "x2 + 1") (("1" (ground) nil nil)) nil) ("2" (inst - 0 "x2 + 1") (("2" (assert) nil nil)) nil) ("3" (inst - 0 "x1 + 1") (("3" (assert) nil nil)) nil) ("4" (inst - "x1 + 1" "x2 + 1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (j skolem-const-decl "nat" finite_set_theorems nil) (f skolem-const-decl "(injective?[nat, below(1 + j)])" finite_set_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak))("finite_set_theorems" finite_set_theorems least_out_rec_TCC5 0 (least_out_rec_TCC5-1 nil 3649907982 ("" (subtype-tcc) nil nil) nil nil))("finite_set_theorems" finite_set_theorems least_out_rec_TCC4 0 (least_out_rec_TCC4-1 nil 3649901266 ("" (skeep :preds? t) (("" (ground) (("" (skeep :preds? t) (("" (typepred "v(NS, 1 + i)") (("" (inst?) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("reduction" reduction updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3647118642 ("" (grind) nil nil) ((bool nonempty-type-eq-decl nil booleans nil) (Store type-eq-decl nil reduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) (add const-decl "(nonempty?)" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set" finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq type-eq-decl nil finite_sequences nil) (get const-decl "(value?)" IL nil) (refs def-decl "bool" IL nil) (vars def-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction" reduction pushlist_TCC1 0 (pushlist_TCC1-1 nil 3650126116 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (value? const-decl "bool" IL nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("IL" IL vars_decompose_TCC1 0 (vars_decompose_TCC1-1 nil 3650427978 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL vars_TCC9 0 (vars_TCC9-1 nil 3650427820 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL vars_TCC8 0 (vars_TCC8-1 nil 3650427820 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("reduction" reduction updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3650549580 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcount_TCC1 0 (refcount_TCC1-1 nil 3650675711 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction newrefReduce_TCC6 0 (newrefReduce_TCC6-1 nil 3650550591 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (value? const-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (domainValue? const-decl "bool" IL nil)) nil))("IL" IL vars_TCC10 0 (vars_TCC10-1 nil 3650647638 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC25 0 (mark_TCC25-1 nil 3655095779 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC24 0 (mark_TCC24-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC23 0 (mark_TCC23-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC22 0 (mark_TCC22-1 nil 3655095779 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC21 0 (mark_TCC21-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC20 0 (mark_TCC20-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC19 0 (mark_TCC19-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC18 0 (mark_TCC18-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC17 0 (mark_TCC17-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC16 0 (mark_TCC16-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC15 0 (mark_TCC15-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC14 0 (mark_TCC14-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC13 0 (mark_TCC13-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC12 0 (mark_TCC12-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC11 0 (mark_TCC11-1 nil 3655095779 ("" (grind) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC9 0 (vars_TCC9-1 nil 3650647638 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC8 0 (vars_TCC8-1 nil 3650647638 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC7 0 (vars_TCC7-1 nil 3650256398 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC6 0 (vars_TCC6-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC5 0 (vars_TCC5-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC4 0 (vars_TCC4-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("reduction" reduction newrefReduce_TCC6 0 (newrefReduce_TCC6-1 nil 3655657128 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (value? const-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (domainValue? const-decl "bool" IL nil)) nil))("preprocess" preprocess markc_TCC3 0 (markc_TCC3-1 nil 3655657330 ("" (termination-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC11 0 (mark_TCC11-1 nil 3655657330 ("" (termination-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC10 0 (mark_TCC10-1 nil 3655095779 ("" (skeep*) (("" (lemma "vars_finite") (("" (inst? :if-match all) (("" (rewrite "finite_difference[nat]") nil nil)) nil)) nil)) nil) ((vars_finite formula-decl nil IL nil) (finite_difference judgement-tcc nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC9 0 (mark_TCC9-1 nil 3655095779 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC8 0 (mark_TCC8-1 nil 3655095779 ("" (skeep*) (("" (lemma "vars_finite") (("" (inst? :if-match all) (("" (rewrite "finite_difference[nat]") nil nil)) nil)) nil)) nil) ((vars_finite formula-decl nil IL nil) (finite_difference judgement-tcc nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) nil))("preprocess" preprocess markvar_TCC2 0 (markvar_TCC2-1 nil 3655327556 ("" (subtype-tcc) nil nil) nil nil))("finite_set_theorems" finite_set_theorems finite_set_induction_TCC1 0 (finite_set_induction_TCC1-1 nil 3656130778 ("" (subtype-tcc) nil nil) nil nil))("IL" IL vars_TCC3 0 (vars_TCC3-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_fill_TCC1 0 (mark_fill_TCC1-1 nil 3656268735 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess drop_TCC1 0 (drop_TCC1-1 nil 3656388994 ("" (grind :if-match nil) (("" (inst + "N!1" "LAMBDA (i | X!1(i + 1)): f!1(i+1)") (("" (grind :if-match nil) (("" (forward-chain -) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) nil))("preprocess" preprocess bump_TCC2 0 (bump_TCC2-1 nil 3655508728 ("" (grind :if-match nil) (("" (inst + "N!1" "LAMBDA (i | i > 0 AND X!1(i - 1)): f!1(i - 1)") (("1" (skeep) (("1" (forward-chain -) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (X!1 skolem-const-decl "finite_set[nat]" preprocess nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) nil))("preprocess" preprocess bump_TCC1 0 (bump_TCC1-1 nil 3655508728 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL bump_TCC2 0 (bump_TCC2-1 nil 3656390208 ("" (grind :if-match nil) (("" (inst + "N!1" "LAMBDA (i | i > 0 AND X!1(i - 1)): f!1(i - 1)") (("1" (skeep) (("1" (forward-chain -) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (X!1 skolem-const-decl "finite_set[nat]" IL nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)) nil))("IL" IL bump_TCC1 0 (bump_TCC1-1 nil 3656390208 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL bump_drop 0 (bump_drop-1 nil 3656520497 ("" (skeep) (("" (apply-extensionality) (("" (hide 2) (("" (grind :if-match nil) (("" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("finite_set_theorems" finite_set_theorems bump_finite 0 (bump_finite-1 nil 3655675856 ("" (skeep) (("" (typepred "X") (("" (expand "is_finite") (("" (skosimp) (("" (inst + "N!1" "LAMBDA (i: (bump(X))): f!1(i+1)") (("1" (grind :if-match nil) (("1" (forward-chain -) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (bump const-decl "bool" finite_set_theorems nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("preprocess" preprocess wellformed?_TCC1 0 (wellformed?_TCC1-1 nil 3656737588 ("" (skeep) (("" (rewrite "every_nth") (("" (skeep) (("" (expand "<<") (("" (ground) (("" (rewrite "some_nth") (("" (inst + "i") (("1" (grind) nil nil) ("2" (grind) (("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every_nth formula-decl nil list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (some_nth formula-decl nil finseq_theorems nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (args adt-accessor-decl "[(application?) -> list[(variable?)]]" IExpression_adt nil) (restrict const-decl "R" restrict nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (A skolem-const-decl "IExpression" preprocess nil) (i skolem-const-decl "below(length(args))" preprocess nil) (args skolem-const-decl "list[(variable?)]" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("preprocess" preprocess wellformed_mark_TCC14 0 (wellformed_mark_TCC14-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((markvar const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC13 0 (wellformed_mark_TCC13-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil)) nil))("preprocess" preprocess wellformed_mark_TCC12 0 (wellformed_mark_TCC12-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((bump const-decl "finite_set[nat]" IL nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC11 0 (wellformed_mark_TCC11-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC10 0 (wellformed_mark_TCC10-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (markv const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC9 0 (wellformed_mark_TCC9-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (markv const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC8 0 (wellformed_mark_TCC8-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) nil nil))("preprocess" preprocess wellformed_mark_TCC7 0 (wellformed_mark_TCC7-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (countable_union application-judgement "countable_set[nat]" finite_set_theorems nil) (injective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil)) nil))("preprocess" preprocess wellformed_mark_TCC6 0 (wellformed_mark_TCC6-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (countable_union application-judgement "countable_set[nat]" finite_set_theorems nil) (injective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil)) nil))("preprocess" preprocess wellformed_mark_TCC5 0 (wellformed_mark_TCC5-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) nil nil))("preprocess" preprocess wellformed_mark_TCC4 0 (wellformed_mark_TCC4-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC3 0 (wellformed_mark_TCC3-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC2 0 (wellformed_mark_TCC2-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC1 0 (wellformed_mark_TCC1-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((markv const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("IL" IL buildcontextPure_TCC5 0 (buildcontextPure_TCC5-1 nil 3646033320 ("" (recursive-judgement-tcc) nil nil) ((cpure? def-decl "bool" IL nil)) nil))("IL" IL buildcontextPure_TCC4 0 (buildcontextPure_TCC4-1 nil 3646033320 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (cpure? def-decl "bool" IL nil)) nil))("finseq_theorems" finseq_theorems compose_append 0 (compose_append-1 nil 3676394329 ("" (postpone) nil nil) nil shostak))("finseq_theorems" finseq_theorems finseq2list2finseq 0 (finseq2list2finseq-1 nil 3676394691 ("" (induct-and-simplify "L") (("" (postpone) nil nil)) nil) nil shostak))("finseq_theorems" finseq_theorems finseq2list_append 0 (finseq2list_append-1 nil 3676428779 ("" (induct "l") (("1" (grind) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil) nil shostak))("finseq_theorems" finseq_theorems finseq2list_append_TCC3 0 (finseq2list_append_TCC3-1 nil 3676428777 ("" (subtype-tcc) nil nil) nil nil))("finseq_theorems" finseq_theorems finseq2list_append_TCC2 0 (finseq2list_append_TCC2-1 nil 3676428777 ("" (subtype-tcc) nil nil) nil nil))("finseq_theorems" finseq_theorems finseq2list_append_TCC1 0 (finseq2list_append_TCC1-1 nil 3676428777 ("" (subtype-tcc) nil nil) nil nil))("finseq_theorems" finseq_theorems finseqtolist_TCC2 0 (finseqtolist_TCC2-1 nil 3676433703 ("" (termination-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan addroundlist_TCC2 0 (addroundlist_TCC2-1 nil 3677707205 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[lrlist])" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan addroundlist_TCC1 0 (addroundlist_TCC1-1 nil 3677707205 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[lrlist])" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan treelevel_monotone 0 (treelevel_monotone-1 nil 3677729690 ("" (induct-and-simplify "X") (("" (postpone) nil nil)) nil) nil shostak))("lindstrom_scan" lindstrom_scan scan_TCC7 0 (scan_TCC7-1 nil 3677642327 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (tree type-decl nil lindstrom_scan nil) (labeleq def-decl "bool" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC6 0 (scan_TCC6-1 nil 3677642327 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (tree type-decl nil lindstrom_scan nil) (<= const-decl "bool" reals nil) (uint32 type-eq-decl nil lindstrom_scan nil) (labeleq def-decl "bool" lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (treelevel def-decl "bool" lindstrom_scan nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC5 0 (scan_TCC5-1 nil 3677642327 ("" (termination-tcc) nil nil) ((restrict const-decl "R" restrict nil) (<< adt-def-decl "(strict_well_founded?[tree])" lindstrom_scan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (uint32 type-eq-decl nil lindstrom_scan nil) (<= const-decl "bool" reals nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC4 0 (scan_TCC4-1 nil 3677642327 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (tree type-decl nil lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (<= const-decl "bool" reals nil) (uint32 type-eq-decl nil lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC3 0 (scan_TCC3-1 nil 3677642327 ("" (termination-tcc) nil nil) ((restrict const-decl "R" restrict nil) (<< adt-def-decl "(strict_well_founded?[tree])" lindstrom_scan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (uint32 type-eq-decl nil lindstrom_scan nil) (<= const-decl "bool" reals nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC28 0 (sscan_correct_TCC28-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC27 0 (sscan_correct_TCC27-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC26 0 (sscan_correct_TCC26-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC25 0 (sscan_correct_TCC25-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC24 0 (sscan_correct_TCC24-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC23 0 (sscan_correct_TCC23-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC22 0 (sscan_correct_TCC22-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC21 0 (sscan_correct_TCC21-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC20 0 (sscan_correct_TCC20-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC19 0 (sscan_correct_TCC19-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC18 0 (sscan_correct_TCC18-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC17 0 (sscan_correct_TCC17-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC16 0 (sscan_correct_TCC16-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC15 0 (sscan_correct_TCC15-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC14 0 (sscan_correct_TCC14-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC13 0 (sscan_correct_TCC13-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC12 0 (sscan_correct_TCC12-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC11 0 (sscan_correct_TCC11-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC10 0 (sscan_correct_TCC10-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC9 0 (sscan_correct_TCC9-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC8 0 (sscan_correct_TCC8-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC7 0 (sscan_correct_TCC7-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC6 0 (sscan_correct_TCC6-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC5 0 (sscan_correct_TCC5-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC4 0 (sscan_correct_TCC4-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC3 0 (sscan_correct_TCC3-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC2 0 (sscan_correct_TCC2-1 nil 3677897058 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (tree type-decl nil lindstrom_scan nil) (goodtree def-decl "bool" lindstrom_scan nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (uint32 type-eq-decl nil lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC1 0 (sscan_correct_TCC1-1 nil 3677897058 ("" (skeep :preds? t) (("" (expand "goodtree" -) (("" (assert) (("" (ground) (("1" (expand "goodtree") (("1" (lift-if) (("1" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ((goodtree def-decl "bool" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("lindstrom_scan" lindstrom_scan sscan_TCC35 0 (sscan_TCC35-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_TCC34 0 (sscan_TCC34-1 nil 3677897058 ("" (termination-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_TCC33 0 (sscan_TCC33-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction letApply_TCC7 0 (letApply_TCC7-1 nil 3683776766 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction letApply_TCC6 0 (letApply_TCC6-1 nil 3683776766 ("" (termination-tcc) nil nil) nil nil))("reduction" reduction letApply_TCC5 0 (letApply_TCC5-1 nil 3683776766 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction applyReduce_TCC4 0 (applyReduce_TCC4-1 nil 3650158977 ("" (skeeps :preds? t) (("" (typepred "popit(arity)(body)") (("" (ground) (("1" (lazy-grind) nil nil) ("2" (lazy-grind) nil nil) ("3" (rewrite "popit_popDepth") (("3" (expand "pushlist" +) (("3" (expand "o") (("3" (expand "list2finseq") (("3" (rewrite "map_length") (("3" (forward-chain "purePopDepth") (("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (Definition type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (popit def-decl "IExpression" reduction nil) (vars def-decl "finite_set[nat]" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (popit_pure rec-application-judgement "{B | (forall j: NOT refs(B)(j))}" reduction nil) (popitContextPure rec-application-judgement "(contextPure?)" reduction nil) (popit_var rec-application-judgement "{B | (forall j: vars(B)(j) = vars(A)(j + i))}" reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (popit_popDepth formula-decl nil reduction nil) (map_length formula-decl nil more_map_props nil) (get const-decl "(value?)" IL nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (drop const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (purePopDepth formula-decl nil IL nil) (below type-eq-decl nil nat_types nil) (Defs type-eq-decl nil reduction nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (pushlist const-decl "Stack" reduction nil) (O const-decl "finseq" finite_sequences nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (popDepth def-decl "nat" IL nil) (in_varlist const-decl "finite_set[nat]" IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("reduction" reduction pure_letApply_TCC2 0 (pure_letApply_TCC2-1 nil 3683818064 ("" (recursive-judgement-tcc) nil nil) nil nil))("reduction" reduction vars_letApply_TCC1 0 (vars_letApply_TCC1-1 nil 3683816779 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (in_varlist const-decl "finite_set[nat]" IL nil)) nil))("refcount" refcount applyReduce_TCC7 0 (applyReduce_TCC7-1 nil 3682124599 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil refcount nil) (applyRedex? const-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (Definition type-eq-decl nil refcount nil) (pure? def-decl "bool" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil)) nil))("refcount" refcount applyReduce_TCC6 0 (applyReduce_TCC6-1 nil 3682124599 ("" (skeep*) (("" (expand "refcount") (("" (expand "refcountStack") (("" (expand "pushlist") (("" (rewrite "count_compose") (("" (typepred "grS`count(i)") (("" (expand "refcount") (("" (replace -5) (("" (replace -1) (("" (expand "refcountStack") (("" (expand "refcountExpr" +) (("" (typepred "grS") (("" (rewrite "popit_refs") (("" (rewrite "pure_refs") (("1" (rewrite "pure_refs") (("1" (assert) nil nil)) nil) ("2" (rewrite "pureApplyRedex") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((refcountStack const-decl "nat" refcount nil) (count_compose formula-decl nil finseq_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (< const-decl "bool" reals nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (rstate type-eq-decl nil refcount nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil refcount nil) (applyRedex? const-decl "bool" IL nil) (map adt-def-decl "list[T1]" list_adt_map nil) (get const-decl "(value?)" IL nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (value? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (refcountExpr const-decl "nat" refcount nil) (Definition type-eq-decl nil refcount nil) (pure? def-decl "bool" IL nil) (popit_refs formula-decl nil reduction nil) (pureApplyRedex formula-decl nil IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pure_refs formula-decl nil IL nil) (pushlist const-decl "Stack" reduction nil) (refcount const-decl "nat" refcount nil)) nil))("refcount" refcount applyReduce_TCC5 0 (applyReduce_TCC5-1 nil 3676345135 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil refcount nil) (applyRedex? const-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (Definition type-eq-decl nil refcount nil) (pure? def-decl "bool" IL nil)) nil))("finseq_theorems" finseq_theorems count_update_TCC1 0 (count_update_TCC1-1 nil 3684271525 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcountStore_ref_TCC2 0 (refcountStore_ref_TCC2-1 nil 3685183231 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcountStore_ref_TCC1 0 (refcountStore_ref_TCC1-1 nil 3685183231 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcountStore_update_TCC1 0 (refcountStore_update_TCC1-1 nil 3692670917 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount store_update_TCC3 0 (store_update_TCC3-1 nil 3692717400 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount finite_enumeration_inverse_TCC2 0 (finite_enumeration_inverse_TCC2-1 nil 3692735784 ("" (existence-tcc) nil nil) nil nil))("refcount" refcount decr_TCC16 0 (decr_TCC16-1 nil 3685624183 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC15 0 (decr_TCC15-1 nil 3685569175 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("refcount" refcount decr_TCC14 0 (decr_TCC14-1 nil 3685100066 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC13 0 (decr_TCC13-2 "" 3692915495 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (lift-if) (("" (ground) (("" (expand "allcountStore") (("" (hide 3) (("" (expand "allcount") (("" (lift-if) (("" (ground) (("1" (use "card_is_0") (("1" (grind) (("1" (expand "emptyset") (("1" (typepred "r") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "o") (("2" (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)") (("1" (hide -1) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (decr_TCC13-1 nil 3685100066 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC12 0 (decr_TCC12-1 nil 3685100066 ("" (skeep*) (("" (lift-if) (("" (ground) (("1" (typepred "v(rS
                       WITH [`store(r)`seq(i - 1) := nil,
                             `count(refindex(subref))
                               := rS`count(refindex(subref)) - 1],
                     refindex(subref), rS`store(refindex(subref))`length)") (("1" (inst?) (("1" (ground) nil nil)) nil) ("2" (ground) (("1" (case "r = refindex(subref)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (skeep :preds? t) (("2" (case "r = refindex(subref)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil) ("2" (typepred "v(rS
               WITH [`store(r)`seq(i - 1) := nil,
                     `count(refindex(subref))
                       := rS`count(refindex(subref)) - 1],
             refindex(subref), rS`store(refindex(subref))`length)") (("1" (skeep) (("1" (inst - "r") (("1" (ground) (("1" (replace -1 :hide? t) (("1" (replace -6 :hide? t) (("1" (typepred "i") (("1" (inst - "j") (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (inst - "j") (("2" (replace -8 :hide? t) (("2" (replace -2 :hide? t) (("2" (lift-if) (("2" (ground) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "decr_TCC9") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (inst - "rS`count(refindex(subref)) - 1") (("2" (inst - "rS
                 WITH [`store(r)`seq(i - 1) := nil,
                       `count(refindex(subref))
                         := rS`count(refindex(subref)) - 1]") (("1" (assert) nil nil) ("2" (assert) (("2" (use "decr_TCC7") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (inst - "rS`count(refindex(subref)) - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (inst - "rS`count(refindex(subref)) - 1") nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (skeep) (("3" (inst - "j") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((i skolem-const-decl "{i: upto(rS`store(r)`length) |
   forall (j: below(rS`store(r)`length)):
     j >= i IMPLIES NOT ref?(rS`store(r)`seq(j))}" refcount nil) (r skolem-const-decl "(rS`domain)" refcount nil) (subref skolem-const-decl "(domainValue?(rS`domain))" refcount nil) (rS skolem-const-decl "rstate" refcount nil) (decr_TCC9 subtype-tcc nil refcount nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (allcountStore const-decl "nat" refcount nil) (lex2 const-decl "ordinal" lex2 nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (decr_TCC7 subtype-tcc nil refcount nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("refcount" refcount decr_TCC11 0 (decr_TCC11-2 "" 3685584855 ("" (skeep*) (("" (lift-if) (("" (ground) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil)) shostak) (decr_TCC11-1 nil 3685100066 ("" (termination-tcc) nil nil) nil nil))("refcount" refcount decr_TCC10 0 (decr_TCC10-1 nil 3684597206 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (flatten) (("" (hide 3) (("" (ground) (("" (hide 1) (("" (expand "allcountStore") (("" (expand "allcount") (("" (lift-if) (("" (ground) (("1" (use "card_is_0") (("1" (grind) (("1" (expand "emptyset") (("1" (typepred "r") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (replace -6 :hide? t) (("2" (assert) (("2" (expand "o") (("2" (case "(LAMBDA (x: below[card(newrS`domain)]):
                              rS WITH [`store(r)`seq(i - 1) := nil, `count(subrefindex) := newsubrefcount]`count
                                  (finite_enumeration(rS`domain)(x))) = (LAMBDA (x: below[card(rS`domain)]):
                               rS`count(finite_enumeration(rS`domain)(x))) WITH [(inverse(finite_enumeration(rS`domain))(subrefindex)) := rS`count(subrefindex) - 1]") (("1" (replace -1 :hide? t) (("1" (lemma "sigma_with[below(card(rS`domain))]") (("1" (inst - "(lambda (x: below[card(rS`domain)]):
                                  rS`count(finite_enumeration(rS`domain)(x)))
                                 WITH [(inverse(finite_enumeration(rS`domain))(subrefindex))
                                         := rS`count(subrefindex) - 1]" "(lambda (x: below[card(rS`domain)]):
                                  rS`count(finite_enumeration(rS`domain)(x)))" "rS`count(subrefindex) - 1" "card(rS`domain) - 1" "inverse(finite_enumeration(rS`domain))(subrefindex)" "0") (("1" (ground) (("1" (rewrite "inverse_surjective") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (ground) (("1" (lift-if) (("1" (ground) (("1" (replace -1 :dir RL) (("1" (rewrite "inverse_injective") (("1" (use "finite_enumeration_bij") (("1" (expand "bijective?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "decr_TCC7") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst - "subrefindex") (("2" (assert) (("2" (inst?) (("2" (ground) (("2" (rewrite "inverse_surjective") (("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (assert) nil nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (use "decr_TCC7") (("5" (assert) (("5" (inst?) (("5" (assert) (("5" (inst?) (("5" (assert) (("5" (inst?) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (allcountStore const-decl "nat" refcount nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (allcount const-decl "nat" refcount nil) (sigma_nat application-judgement "nat" sigma "reals/") (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (card_is_0 formula-decl nil finite_sets nil) (O const-decl "T3" function_props nil) (decr_TCC7 subtype-tcc nil refcount nil) (inverse_injective formula-decl nil function_inverse nil) (injective? const-decl "bool" functions nil) (newrS skolem-const-decl "rstate" refcount nil) (rS skolem-const-decl "rstate" refcount nil) (newsubrefcount skolem-const-decl "int" refcount nil) (r skolem-const-decl "(rS`domain)" refcount nil) (i skolem-const-decl "{i: upto(rS`store(r)`length) |
   forall (j: below(rS`store(r)`length)):
     j >= i IMPLIES NOT ref?(rS`store(r)`seq(j))}" refcount nil) (subrefindex skolem-const-decl "(rS`domain)" refcount nil) (T_low type-eq-decl nil sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (OR const-decl "[bool, bool -> bool]" booleans nil) (surjective? const-decl "bool" functions nil) (inverse_surjective formula-decl nil function_inverse nil) (bijective? const-decl "bool" functions nil) (finite_enumeration_bij formula-decl nil finite_enumeration "sigma_set/") (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (integer nonempty-type-from-decl nil integers nil) (sigma_with formula-decl nil sigma "reals/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_enumeration const-decl "[below[card(X)] -> (X)]" finite_enumeration "sigma_set/") (inverse const-decl "D" function_inverse nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC9 0 (decr_TCC9-1 nil 3684597206 ("" (skeep*) (("" (ground) (("1" (case "r = subrefindex") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (skeep*) (("2" (assert) (("2" (typepred "j") (("2" (assert) (("2" (case "r = subrefindex") (("1" (replace*) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil)) nil))("refcount" refcount decr_TCC8 0 (decr_TCC8-1 nil 3684597206 ("" (skeep*) (("" (ground) (("" (case "r = subrefindex") (("1" (grind) nil nil) ("2" (grind) (("2" (typepred "rS`store(r)`seq(i - 1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC7 0 (decr_TCC7-1 nil 3684597206 ("" (skeep*) (("" (ground) (("1" (typepred "rS`count(subrefindex)") (("1" (expand "refcount") (("1" (use "refcountStore_ref") (("1" (ground) (("1" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "rS`count(subrefindex)") (("2" (expand "refcount") (("2" (expand "refcountStore") (("2" (lift-if) (("2" (ground) (("1" (typepred "subref") (("1" (grind) nil nil)) nil) ("2" (expand "o") (("2" (expand "refcountArray") (("2" (case-replace "(LAMBDA (x: below[card(rS`domain)]):
                     count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                           rS`store WITH [(r)`seq(i - 1) := nil]
                               (finite_enumeration(rS`domain)(x)))) = ((LAMBDA (x: below[card(rS`domain)]):
                     count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                           rS`store(finite_enumeration(rS`domain)(x)))) WITH [(inverse(finite_enumeration(rS`domain))(r)) := count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                           rS`store(r)) - 1])") (("1" (hide -1) (("1" (lemma "sigma_with[below(card(rS`domain))]") (("1" (inst - "(lambda (x: below[card(rS`domain)]):
                           count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                                 rS`store(finite_enumeration(rS`domain)(x))))
                          WITH [(inverse(finite_enumeration(rS`domain))(r))
                                  := count(lambda u:
                                             ref?(u) AND refindex(u) = subrefindex,
                                           rS`store(r))
                                      - 1]" "_" "_" "_" "_" "_") (("1" (inst - "(lambda (x: below[card(rS`domain)]):
                             count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                                   rS`store(finite_enumeration(rS`domain)(x))))" "count(lambda u:
                                               ref?(u) AND refindex(u) = subrefindex,
                                             rS`store(r))
                                        - 1" "card(rS`domain) - 1" "(inverse(finite_enumeration(rS`domain))(r))" "0") (("1" (ground) (("1" (replace -1 :hide? t) (("1" (rewrite "inverse_surjective") (("1" (assert) nil nil) ("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (case "inverse(finite_enumeration(rS`domain))(r) = x!1") (("1" (assert) (("1" (replace -1 :dir RL) (("1" (rewrite "inverse_surjective") (("1" (assert) (("1" (rewrite "count_update") (("1" (expand "value?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "injective_inverse") (("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "count_elem[(value?)]") (("2" (ground) (("2" (inst + "i - 1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil) ("3" (use "count_elem[(value?)]") (("3" (ground) (("3" (inst + "i - 1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refcountStore_ref formula-decl nil refcount nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (O const-decl "T3" function_props nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (finite_enumeration const-decl "[below[card(X)] -> (X)]" finite_enumeration "sigma_set/") (inverse const-decl "D" function_inverse nil) (sigma_with formula-decl nil sigma "reals/") (integer nonempty-type-from-decl nil integers nil) (T_low type-eq-decl nil sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (OR const-decl "[bool, bool -> bool]" booleans nil) (finite_enumeration_bij formula-decl nil finite_enumeration "sigma_set/") (bijective? const-decl "bool" functions nil) (inverse_surjective formula-decl nil function_inverse nil) (surjective? const-decl "bool" functions nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (sigma def-decl "real" sigma "reals/") (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count_elem formula-decl nil finseq_theorems nil) (count_update formula-decl nil finseq_theorems nil) (injective_inverse formula-decl nil function_inverse nil) (refcountArray const-decl "nat" refcount nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (refcountExpr const-decl "nat" refcount nil) (count const-decl "nat" finseq_theorems nil) (refcountStack const-decl "nat" refcount nil) (sigma_nat application-judgement "nat" sigma "reals/") (refcountStore const-decl "nat" refcount nil)) nil))("refcount" refcount decr_TCC6 0 (decr_TCC6-1 nil 3684597206 ("" (termination-tcc) nil nil) ((value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil)) nil))("refcount" refcount decr_TCC5 0 (decr_TCC5-1 nil 3684597206 ("" (skeep*) (("" (typepred "subref") (("" (grind) nil nil)) nil)) nil) ((rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (= const-decl "[T, T -> boolean]" equalities nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (below type-eq-decl nil nat_types nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC4 0 (decr_TCC4-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC3 0 (decr_TCC3-1 nil 3684597206 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC2 0 (decr_TCC2-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((below type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (= const-decl "[T, T -> boolean]" equalities nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("refcount" refcount decr_TCC1 0 (decr_TCC1-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (= const-decl "[T, T -> boolean]" equalities nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("IL" IL vars_TCC2 0 (vars_TCC2-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess markvar_TCC2 0 (markvar_TCC2-1 nil 3683170974 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess markvars_markX_TCC2 0 (markvars_markX_TCC2-1 nil 3693198804 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess markvars_markX_TCC1 0 (markvars_markX_TCC1-1 nil 3693198804 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_idem_subset 0 (mark_idem_subset-1 nil 3693496691 ("" (induct "A") (("1" (skeep*) (("1" (expand "mark") (("1" (expand "markv") (("1" (grind) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil)) nil) nil shostak))("refreduction" refreduction lookupReduce_TCC26 0 (lookupReduce_TCC26-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil nil))("refreduction" refreduction lookupReduce_TCC25 0 (lookupReduce_TCC25-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil nil))("refreduction" refreduction lookupReduce_TCC24 0 (lookupReduce_TCC24-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil nil))("finite_set_theorems" |finite_set_theorems| |sigma_sigma_set| 0 (|sigma_sigma_set-1| NIL 3698607396 NIL ("" (INDUCT "X" :NAME "finite_set_induction") (("1" (GRIND :REWRITES "sigma_empty") NIL NIL) ("2" (SKEEP*) (("2" (EXPAND "Sigma" 1 1) (("2" (EXPAND "nonempty?") (("2" (ASSERT) (("2" (INST?) (("2" (REWRITE "sigma_remove") (("2" (LIFT-IF) (("2" (GROUND) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (SKEEP) (("3" (USE "sigma_sigma_set_TCC1") NIL NIL)) NIL)) NIL)) NIL) NIL ((SIGMA_SIGMA_SET_TCC1 SUBTYPE-TCC NIL FINITE_SET_THEOREMS NIL) (NONEMPTY? CONST-DECL "bool" SETS NIL) (REAL_MINUS_REAL_IS_REAL APPLICATION-JUDGEMENT "real" REALS NIL) (SIGMA_REMOVE FORMULA-DECL NIL SIGMA_SET "sigma_set/") (CHOOSE CONST-DECL "(p)" SETS NIL) (NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL) (FINITE_REMOVE APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set" FINITE_SETS NIL) (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" SIGMA_SET "sigma_set/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" COUNTABLE_PROPS "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (SIGMA_EMPTY FORMULA-DECL NIL SIGMA_SET "sigma_set/") (EMPTY? CONST-DECL "bool" SETS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (EMPTYSET CONST-DECL "set" SETS NIL) (FINITE_SET_INDUCTION FORMULA-DECL NIL FINITE_SET_THEOREMS NIL) (SIGMA CONST-DECL "real" SIGMA_SET "sigma_set/") (SIGMA DEF-DECL "nat" FINITE_SET_THEOREMS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (CONVERGENT? CONST-DECL "bool" CONVERGENCE_SET "sigma_set/")) NIL NIL NIL SHOSTAK))("finite_set_theorems" |finite_set_theorems| |sigma_sigma_set_TCC1| 0 (|sigma_sigma_set_TCC1-1| NIL 3698607394 NIL ("" (SKEEP) (("" (EXPAND "convergent?") (("" (GROUND) (("1" (USE "countable_props[nat].finite_countable") (("1" (LEMMA "countable_props[nat].finite_countable") (("1" (INST? :POLARITY? T) (("1" (USE "finite_nonzero_elts") NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "convergent?") (("2" (GROUND) (("2" (USE "finite_nonzero_elts") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((CONVERGENT? CONST-DECL "bool" CONVERGENCE_SET "sigma_set/") (CONVERGENT? CONST-DECL "bool" COUNTABLE_CONVERGENCE "sigma_set/") (FINITE_COUNTABLE JUDGEMENT-TCC NIL COUNTABLE_PROPS "sets_aux/") (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (NONZERO_ELTS CONST-DECL "set[T]" CONVERGENCE_SET "sigma_set/") (X SKOLEM-CONST-DECL "finite_set[nat]" FINITE_SET_THEOREMS NIL) (F SKOLEM-CONST-DECL "[nat -> nat]" FINITE_SET_THEOREMS NIL) (FINITE_NONZERO_ELTS FORMULA-DECL NIL FINITE_SET_THEOREMS NIL)) NIL NIL NIL NIL))("finite_set_theorems" |finite_set_theorems| |finite_nonzero_elts| 0 (|finite_nonzero_elts-1| NIL 3698607891 NIL ("" (SKEEP) (("" (CASE "subset?(nonzero_elts(f, X), X)") (("1" (FORWARD-CHAIN "finite_subset") NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) NIL ((FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (NONZERO_ELTS CONST-DECL "set[T]" CONVERGENCE_SET "sigma_set/") (SUBSET? CONST-DECL "bool" SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (FINITE_SUBSET FORMULA-DECL NIL FINITE_SETS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (/= CONST-DECL "boolean" NOTEQUAL NIL) (SUBSET_IS_PARTIAL_ORDER NAME-JUDGEMENT "(partial_order?[set[T]])" SETS_LEMMAS NIL)) NIL NIL NIL SHOSTAK))("preprocess" |preprocess| |mark_idem_subset| 0 (|mark_idem_subset-1| NIL 3693496691 NIL ("" (INDUCT "A") (("1" (SKEEP*) (("1" (EXPAND "mark") (("1" (EXPAND "markv") (("1" (GRIND) (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL) ("4" (POSTPONE) NIL NIL) ("5" (POSTPONE) NIL NIL) ("6" (POSTPONE) NIL NIL) ("7" (POSTPONE) NIL NIL) ("8" (POSTPONE) NIL NIL) ("9" (POSTPONE) NIL NIL) ("10" (POSTPONE) NIL NIL) ("11" (POSTPONE) NIL NIL) ("12" (POSTPONE) NIL NIL) ("13" (POSTPONE) NIL NIL)) NIL) NIL NIL NIL NIL NIL SHOSTAK))("rreduction" |rreduction| |allcount_TCC2| 0 (|allcount_TCC2-1| NIL 3684597206 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |allcount_TCC1| 0 (|allcount_TCC1-1| NIL 3684597206 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |refcountStore_TCC2| 0 (|refcountStore_TCC2-1| NIL 3650675711 NIL ("" (SKEEP) (("" (POSTPONE) NIL NIL)) NIL) NIL ((EMPTY_CARD FORMULA-DECL NIL FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |refcountStore_TCC1| 0 (|refcountStore_TCC1-1| NIL 3650675711 NIL ("" (SKEEP :PREDS? T) (("" (EXPAND "convergent?") (("" (GROUND) (("1" (USE "finite_countable") (("1" (CASE "subset?[(dom)](nonzero_elts(lambda (j: (dom)): refcountArray(R(j))(i),
                                restrict[nat, (dom), boolean](dom)), dom)") (("1" (FORWARD-CHAIN "countable_subset[(dom)]") NIL NIL) ("2" (HIDE -1 -2 2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "convergent?") (("2" (FLATTEN) (("2" (HIDE 2) (("2" (CASE "subset?[(dom)](nonzero_elts(lambda (j: (dom)): refcountArray(R(j))(i),
                                restrict[nat, (dom), boolean](dom)), dom)") (("1" (FORWARD-CHAIN "finite_subset[(dom)]") NIL NIL) ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((CONVERGENT? CONST-DECL "bool" CONVERGENCE_SET "sigma_set/") (CONVERGENT? CONST-DECL "bool" COUNTABLE_CONVERGENCE "sigma_set/") (FINITE_SUBSET FORMULA-DECL NIL FINITE_SETS NIL) (FINITE_COUNTABLE JUDGEMENT-TCC NIL COUNTABLE_PROPS "sets_aux/") (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (SUBSET_IS_PARTIAL_ORDER NAME-JUDGEMENT "(partial_order?[set[T]])" SETS_LEMMAS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (/= CONST-DECL "boolean" NOTEQUAL NIL) (COUNT CONST-DECL "nat" FINSEQ_THEOREMS NIL) (COUNTABLE_SUBSET FORMULA-DECL NIL COUNTABILITY "sets_aux/") (IS_COUNTABLE CONST-DECL "bool" COUNTABILITY "sets_aux/") (COUNTABLE_SET NONEMPTY-TYPE-EQ-DECL NIL COUNTABILITY "sets_aux/") (SUBSET? CONST-DECL "bool" SETS NIL) (NONZERO_ELTS CONST-DECL "set[T]" CONVERGENCE_SET "sigma_set/") (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VALUE? CONST-DECL "bool" IL NIL) (FINSEQ TYPE-EQ-DECL NIL FINITE_SEQUENCES NIL) (REFCOUNTARRAY CONST-DECL "nat" RREDUCTION NIL) (DOMAINVALUE? CONST-DECL "bool" IL NIL) (STORE TYPE-EQ-DECL NIL REDUCTION NIL) (RESTRICT CONST-DECL "R" RESTRICT NIL) (FINITE_RESTRICT APPLICATION-JUDGEMENT "finite_set[S]" RESTRICT_SET_PROPS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC13| 0 (|lookupReduce_TCC13-1| NIL 3696570131 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC12| 0 (|lookupReduce_TCC12-1| NIL 3696570131 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC11| 0 (|lookupReduce_TCC11-1| NIL 3696570131 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((GET CONST-DECL "(value?)" IL NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC10| 0 (|lookupReduce_TCC10-1| NIL 3696570131 NIL ("" (SKEEP* :PREDS? T) (("" (GROUND) (("1" (TYPEPRED "grS`count(avalindex)") (("1" (EXPAND "refcount") (("1" (EXPAND "refcountStack") (("1" (USE "count_elem[(IL.value?)]") (("1" (GROUND) (("1" (INST + "stack`length - 1 - index(avar)") (("1" (ASSERT) (("1" (EXPAND "get") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (USE "lookupReduce_TCC7") (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST - "pos") (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "refcount") (("2" (EXPAND "refcountStack") (("2" (REWRITE "count_update") (("1" (ASSERT) (("1" (LIFT-IF) (("1" (GROUND) (("1" (TYPEPRED "grS`count(avalindex)") (("1" (EXPAND "refcount") (("1" (EXPAND "refcountStack") (("1" (ASSERT) (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC9| 0 (|lookupReduce_TCC9-1| NIL 3696570131 NIL ("" (SKEEP* :PREDS? T) (("" (USE "reduction.lookupReduce_TCC6") (("" (INST - "rstate2estate(grS)" "stack") (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST - "pos") (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (GROUND) (("1" (LAZY-GRIND) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (LAZY-GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (LAZY-GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL) ("3" (HIDE 3) (("3" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL ((LOOKUPREDUCE_TCC6 SUBTYPE-TCC NIL REDUCTION NIL) (VARS_MARK_TYPE APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}" PREPROCESS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (GET CONST-DECL "(value?)" IL NIL) (EMPTYSET CONST-DECL "set" SETS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (ADD CONST-DECL "(nonempty?)" SETS NIL) (NONEMPTY_ADD_FINITE APPLICATION-JUDGEMENT "non_empty_finite_set[nat]" COUNTABILITY "sets_aux/") (MARKV CONST-DECL "(variable?)" PREPROCESS NIL) (CONSTANT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (VALUE ADT-ACCESSOR-DECL "[(constant?) -> int]" IEXPRESSION_ADT NIL) (POSITION ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]" IEXPRESSION_ADT NIL) (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" SIGMA_SET "sigma_set/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" COUNTABLE_PROPS "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set" FINITE_SETS NIL) (REFINDEX ADT-ACCESSOR-DECL "[(ref?) -> nat]" IEXPRESSION_ADT NIL) (ARRAYVALUE ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]" IEXPRESSION_ADT NIL) (LOOKUP? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (INDEX ADT-ACCESSOR-DECL "[(variable?) -> nat]" IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (EXPR SKOLEM-CONST-DECL "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}" RREDUCTION NIL) (REAL_LE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (STORE SKOLEM-CONST-DECL "Store(grS`domain)" RREDUCTION NIL) (IFF CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (GOODSTATE TYPE-EQ-DECL NIL REDUCTION NIL) (STACK SKOLEM-CONST-DECL "{S: Stack | every(domainValue?(grS`domain))(S)}" RREDUCTION NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VALUE? CONST-DECL "bool" IL NIL) (STACK TYPE-EQ-DECL NIL IL NIL) (FINSEQ TYPE-EQ-DECL NIL FINITE_SEQUENCES NIL) (EVERY CONST-DECL "bool" FINSEQ_THEOREMS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (DOMAINVALUE? CONST-DECL "bool" IL NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (REFS DEF-DECL "bool" IL NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (< CONST-DECL "bool" REALS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" REALS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (MARK DEF-DECL "IExpression" PREPROCESS NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (REF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (STORE TYPE-EQ-DECL NIL REDUCTION NIL) (REFCOUNT CONST-DECL "nat" RREDUCTION NIL) (RSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (ESTATE TYPE-EQ-DECL NIL REDUCTION NIL) (RSTATE2ESTATE CONST-DECL "estate" RREDUCTION NIL) (GOODRSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (LOOKUPREDEX? CONST-DECL "bool" IL NIL) (GRS SKOLEM-CONST-DECL "{grS | lookupRedex?(grS`redex)}" RREDUCTION NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC8| 0 (|lookupReduce_TCC8-1| NIL 3696570131 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((GET CONST-DECL "(value?)" IL NIL) (VALUE? CONST-DECL "bool" IL NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |ifReduce_TCC8| 0 (|ifReduce_TCC8-1| NIL 3696194804 NIL ("" (SKEEP* :PREDS? T) (("" (TYPEPRED "grS`count(x1)") (("" (EXPAND "refcount") (("" (EXPAND "pureIftRedex?") (("" (EXPAND "iftRedex?") (("" (GROUND) (("" (EXPAND "refcountExpr") (("" (REWRITE "pure_refs") (("1" (REWRITE "pure_refs") NIL NIL) ("2" (EXPAND "pure?" +) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((PUREIFTREDEX? CONST-DECL "bool" IL NIL) (GOODRSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (RSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (REFCOUNT CONST-DECL "nat" RREDUCTION NIL) (STORE TYPE-EQ-DECL NIL REDUCTION NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (REF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (MARK DEF-DECL "IExpression" PREPROCESS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" REALS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (< CONST-DECL "bool" REALS NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (REFS DEF-DECL "bool" IL NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (DOMAINVALUE? CONST-DECL "bool" IL NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (EVERY CONST-DECL "bool" FINSEQ_THEOREMS NIL) (FINSEQ TYPE-EQ-DECL NIL FINITE_SEQUENCES NIL) (STACK TYPE-EQ-DECL NIL IL NIL) (VALUE? CONST-DECL "bool" IL NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL) (REAL_LE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (VARS_MARK_TYPE APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}" PREPROCESS NIL) (PURE_REFS FORMULA-DECL NIL IL NIL) (PURE? DEF-DECL "bool" IL NIL) (REFCOUNTEXPR CONST-DECL "nat" RREDUCTION NIL) (IFTREDEX? CONST-DECL "bool" IL NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |ifReduce_TCC7| 0 (|ifReduce_TCC7-1| NIL 3696194804 NIL ("" (SKEEP* :PREDS? T) (("" (USE "reduction.ifReduce_TCC4") (("" (INST - "rstate2estate(grS)" "stack") (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST - "thenexpr") (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (GROUND) (("1" (LAZY-GRIND :REWRITES "purePopDepth") NIL NIL) ("2" (LAZY-GRIND :REWRITES "purePopDepth") NIL NIL) ("3" (GRIND :REWRITES "purePopDepth" :IF-MATCH NIL) NIL NIL) ("4" (EXPAND "pureIftRedex?") (("4" (EXPAND "iftRedex?") (("4" (GROUND) (("4" (EXPAND "mark" -) (("4" (DECOMPOSE-EQUALITY -) (("4" (REPLACE -22) (("4" (REPLACE -2 :DIR RL) (("4" (REWRITE "mark_release_set") (("1" (REWRITE "mark_idem") NIL NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND :REWRITES "vars_mark") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (INST -12 "i") (("5" (GROUND) (("5" (EXPAND "pureIftRedex?") (("5" (EXPAND "iftRedex?") (("5" (GROUND) (("5" (EXPAND "mark" -) (("5" (DECOMPOSE-EQUALITY -) (("5" (REPLACE -23) (("5" (REPLACE -2 :DIR RL) (("5" (REWRITE "vars_release_set") (("5" (HIDE-ALL-BUT (-1 -4 -22 2 3 5)) (("5" (GRIND :REWRITES "vars_mark") (("5" (REPLACE -1 :DIR RL) (("5" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL) ("3" (HIDE 5) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL ((IFREDUCE_TCC4 SUBTYPE-TCC NIL REDUCTION NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (VARS_RELEASE_SET FORMULA-DECL NIL PREPROCESS NIL) (ADD CONST-DECL "(nonempty?)" SETS NIL) (NONEMPTY_ADD_FINITE APPLICATION-JUDGEMENT "non_empty_finite_set[nat]" COUNTABILITY "sets_aux/") (DIFFERENCE CONST-DECL "set" SETS NIL) (RELEASE_SET DEF-DECL "IExpression" PREPROCESS NIL) (ELSEEXPR ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" IEXPRESSION_ADT NIL) (THENEXPR ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" IEXPRESSION_ADT NIL) (UNION CONST-DECL "set" SETS NIL) (MARKV CONST-DECL "(variable?)" PREPROCESS NIL) (IFT ADT-CONSTRUCTOR-DECL "[[(variable?), IExpression, IExpression] -> (ift?)]" IEXPRESSION_ADT NIL) (CONDITION ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" IEXPRESSION_ADT NIL) (IFT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (FINITE_DIFFERENCE APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_UNION APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_INTERSECTION1 APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (VARS_MARK FORMULA-DECL NIL PREPROCESS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (INTERSECTION CONST-DECL "set" SETS NIL) (EMPTY? CONST-DECL "bool" SETS NIL) (DISJOINT? CONST-DECL "bool" SETS NIL) (MARK_IDEM FORMULA-DECL NIL PREPROCESS NIL) (MARK_RELEASE_SET FORMULA-DECL NIL PREPROCESS NIL) (IFTREDEX? CONST-DECL "bool" IL NIL) (GET CONST-DECL "(value?)" IL NIL) (VARS_MARK_TYPE APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}" PREPROCESS NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (EXPR SKOLEM-CONST-DECL "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}" RREDUCTION NIL) (REAL_LE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (STORE SKOLEM-CONST-DECL "Store(grS`domain)" RREDUCTION NIL) (IFF CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (GOODSTATE TYPE-EQ-DECL NIL REDUCTION NIL) (STACK SKOLEM-CONST-DECL "{S: Stack | every(domainValue?(grS`domain))(S)}" RREDUCTION NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VALUE? CONST-DECL "bool" IL NIL) (STACK TYPE-EQ-DECL NIL IL NIL) (FINSEQ TYPE-EQ-DECL NIL FINITE_SEQUENCES NIL) (EVERY CONST-DECL "bool" FINSEQ_THEOREMS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (DOMAINVALUE? CONST-DECL "bool" IL NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (REFS DEF-DECL "bool" IL NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (< CONST-DECL "bool" REALS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" REALS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (MARK DEF-DECL "IExpression" PREPROCESS NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (REF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (STORE TYPE-EQ-DECL NIL REDUCTION NIL) (REFCOUNT CONST-DECL "nat" RREDUCTION NIL) (RSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (ESTATE TYPE-EQ-DECL NIL REDUCTION NIL) (RSTATE2ESTATE CONST-DECL "estate" RREDUCTION NIL) (GOODRSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (PUREIFTREDEX? CONST-DECL "bool" IL NIL) (GRS SKOLEM-CONST-DECL "{grS | pureIftRedex?(grS`redex)}" RREDUCTION NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("IL" IL VARS_FINITE 0 (VARS_FINITE-2 "" 3655616144 ("" (INDUCT "A") (("1" (GRIND :IF-MATCH NIL) (("1" (INST + 1 "(LAMBDA (i: (vars(variable(variable1_var!1, variable2_var!1)))): 0)") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND :IF-MATCH NIL) (("2" (INST + 0 "LAMBDA (i: (vars(constant(constant1_var!1)))): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (GRIND :IF-MATCH NIL) (("3" (INST + 0 "LAMBDA (i: (vars(nil))): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (EXPAND "vars" +) (("4" (EXPAND "is_finite" +) (("4" (INST + "length(application2_var)" "(LAMBDA (i | in_varlist(application2_var)(i)): locate(LAMBDA x: index(x) = i, application2_var))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (TYPEPRED "locate(LAMBDA x: index(x) = x1, application2_var)") (("1" (ASSERT) (("1" (TYPEPRED "locate(LAMBDA x: index(x) = x2, application2_var)") (("1" (ASSERT) (("1" (REPLACE -6 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (TYPEPRED "i") (("2" (EXPAND "in_varlist") (("2" (REWRITE "some_nth") (("2" (SKEEP) (("2" (INST?) (("2" (REWRITE "member_nth") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (EXPAND "vars" +) (("5" (LEMMA "finite_union" ("A" "vars(letexpr1_var)" "B" "(LAMBDA i: vars(letexpr2_var)(1 + i))")) (("1" (EXPAND "union") (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE -1 2) (("2" (EXPAND "is_finite") (("2" (SKEEP) (("2" (INST + "N" "(LAMBDA (j | vars(letexpr2_var)(1 + j)): f(1 + j))") (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (FORWARD-CHAIN -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("6" (SKEEP) (("6" (EXPAND "vars" +) (("6" (LEMMA "finite_union" ("A" "vars(ift1_var)" "B" "vars(ift2_var)")) (("1" (LEMMA "finite_union" ("A" "union[nat](vars(ift1_var), vars(ift2_var))" "B" "vars(ift3_var)")) (("1" (EXPAND "union") (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("7" (SKEEP) (("7" (EXPAND "vars") (("7" (EXPAND "vars") (("7" (EXPAND "is_finite" +) (("7" (INST + 3 "(LAMBDA (i | (i = index(update1_var)) OR
                         (i = index(update2_var)) OR
                          (i = index(update3_var))): IF (i = index(update1_var)) THEN 0 ELSIF (i = index(update2_var)) THEN 1 ELSE 2 ENDIF)") (("7" (EXPAND "injective?") (("7" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("8" (SKEEP) (("8" (EXPAND "vars" +) (("8" (EXPAND "is_finite" +) (("8" (INST + 2 "LAMBDA (i | vars(lookup1_var)(i) OR vars(lookup2_var)(i)): IF index(lookup1_var) = i THEN 0 ELSE 1 ENDIF") (("8" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("9" (SKEEP) (("9" (EXPAND "vars") (("9" (EXPAND "is_finite") (("9" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("10" (SKEEP) (("10" (EXPAND "vars") (("10" (EXPAND "is_finite") (("10" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("11" (SKEEP) (("11" (EXPAND "vars" +) (("11" (EXPAND "is_finite") (("11" (SKEEP) (("11" (INST + "N" "LAMBDA (i | vars(pop1_var)(1 + i)): f(i+1)") (("11" (EXPAND "injective?") (("11" (SKEEP) (("11" (FORWARD-CHAIN -1) (("11" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("12" (SKEEP) (("12" (EXPAND "vars") (("12" (EXPAND "is_finite") (("12" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("13" (SKEEP) (("13" (EXPAND "vars" +) (("13" (EXPAND "is_finite") (("13" (SKEEP*) (("13" (INST + "N!1 + 1" "LAMBDA (i | vars(release1_var)(i) OR vars(release2_var)(i)): IF vars(release2_var)(i) THEN f!1(i) ELSE N!1 ENDIF") (("1" (GRIND :IF-MATCH NIL) (("1" (FORWARD-CHAIN -4) NIL NIL) ("2" (FORWARD-CHAIN -4) NIL NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK) (VARS_FINITE-1 NIL 3652888177 ("" (INDUCT "A") (("1" (GRIND :IF-MATCH NIL) (("1" (INST + 1 "(LAMBDA (i: (vars(variable(variable1_var!1)))): 0)") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND :IF-MATCH NIL) (("2" (INST + 0 "LAMBDA (i: (vars(constant(constant1_var!1)))): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (GRIND :IF-MATCH NIL) (("3" (INST + 0 "LAMBDA (i: (vars(nil))): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (EXPAND "vars" +) (("4" (EXPAND "is_finite" +) (("4" (INST + "length(application2_var)" "(LAMBDA (i | member(variable(i), application2_var)): locate(LAMBDA x: index(x) = i, application2_var))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (TYPEPRED "locate(LAMBDA x: index(x) = x1, application2_var)") (("1" (ASSERT) (("1" (TYPEPRED "locate(LAMBDA x: index(x) = x2, application2_var)") (("1" (ASSERT) (("1" (REPLACE -6 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP :PREDS? T) (("2" (INST + "variable(i)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (EXPAND "vars" +) (("5" (LEMMA "finite_union" ("A" "vars(letexpr1_var)" "B" "(LAMBDA i: vars(letexpr2_var)(1 + i))")) (("1" (EXPAND "union") (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE -1 2) (("2" (EXPAND "is_finite") (("2" (SKEEP) (("2" (INST + "N" "(LAMBDA (j | vars(letexpr2_var)(1 + j)): f(1 + j))") (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (FORWARD-CHAIN -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("6" (SKEEP) (("6" (EXPAND "vars" +) (("6" (LEMMA "finite_union" ("A" "vars(ift1_var)" "B" "vars(ift2_var)")) (("1" (LEMMA "finite_union" ("A" "union[nat](vars(ift1_var), vars(ift2_var))" "B" "vars(ift3_var)")) (("1" (EXPAND "union") (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("7" (SKEEP) (("7" (EXPAND "vars") (("7" (EXPAND "vars") (("7" (EXPAND "is_finite" +) (("7" (INST + 3 "(LAMBDA (i | (i = index(update1_var)) OR
                     (i = index(update2_var)) OR
                      (i = index(update3_var))): IF (i = index(update1_var)) THEN 0 ELSIF (i = index(update2_var)) THEN 1 ELSE 2 ENDIF)") (("7" (EXPAND "injective?") (("7" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("8" (SKEEP) (("8" (EXPAND "vars" +) (("8" (EXPAND "is_finite" +) (("8" (INST + 2 "LAMBDA (i | vars(lookup1_var)(i) OR vars(lookup2_var)(i)): IF index(lookup1_var) = i THEN 0 ELSE 1 ENDIF") (("8" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("9" (SKEEP) (("9" (EXPAND "vars") (("9" (EXPAND "is_finite") (("9" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("10" (SKEEP) (("10" (EXPAND "vars") (("10" (EXPAND "is_finite") (("10" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("11" (SKEEP) (("11" (EXPAND "vars" +) (("11" (EXPAND "is_finite") (("11" (SKEEP) (("11" (INST + "N" "LAMBDA (i | vars(pop1_var)(1 + i)): f(i+1)") (("11" (EXPAND "injective?") (("11" (SKEEP) (("11" (FORWARD-CHAIN -1) (("11" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("12" (SKEEP) (("12" (EXPAND "vars") (("12" (EXPAND "is_finite") (("12" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("13" (SKEEP) (("13" (EXPAND "vars" +) (("13" (EXPAND "is_finite") (("13" (SKEEP*) (("13" (INST + "N + 1" "LAMBDA (i | vars(release1_var)(i) OR vars(release2_var)(i)): IF vars(release1_var)(i) THEN f(i) ELSE N ENDIF") (("1" (GRIND :IF-MATCH NIL) (("1" (FORWARD-CHAIN -3) NIL NIL) ("2" (FORWARD-CHAIN -3) NIL NIL)) NIL) ("2" (SKEEP*) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("14" (SKEEP) (("14" (EXPAND "is_finite" +) (("14" (INST + 1 "LAMBDA (i | vars(mark(mark1_var))(i)): 0") (("14" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (< CONST-DECL "bool" REALS NIL) (VARIABLE ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]" IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (CONSTANT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (CONSTANT ADT-CONSTRUCTOR-DECL "[int -> (constant?)]" IEXPRESSION_ADT NIL) (FALSE CONST-DECL "bool" BOOLEANS NIL) (NIL? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NIL ADT-CONSTRUCTOR-DECL "(nil?)" IEXPRESSION_ADT NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (INDEX ADT-ACCESSOR-DECL "[(variable?) -> nat]" IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (MEMBER DEF-DECL "bool" LIST_PROPS NIL) (LIST TYPE-DECL NIL LIST_ADT NIL) (LENGTH DEF-DECL "nat" LIST_PROPS NIL) (BELOW TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (NTH DEF-DECL "T" LIST_PROPS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (LOCATE DEF-DECL "{i: below(length(L)) | P(nth(L, length(L) - i - 1))}" FINSEQ_THEOREMS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (UNION CONST-DECL "set" SETS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (FINITE_UNION JUDGEMENT-TCC NIL FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (IF CONST-DECL "[boolean, T, T -> T]" IF_DEF NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (NNINT_PLUS_POSINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (RESTRICT CONST-DECL "R" RESTRICT NIL)) SHOSTAK))("IL" IL VARS_DECOMPOSE 0 (VARS_DECOMPOSE-1 NIL 3646034443 ("" (INDUCT-AND-SIMPLIFY "K") NIL NIL) ((NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (FILL DEF-DECL "IExpression" IL NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL) (EMPTYSET CONST-DECL "set" SETS NIL) (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" COUNTABLE_PROPS "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set" FINITE_SETS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (NNINT_PLUS_POSINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (FINITE_UNION APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (MEMBER CONST-DECL "bool" SETS NIL) (DROP CONST-DECL "finite_set[nat]" IL NIL) (UNION CONST-DECL "set" SETS NIL)) SHOSTAK))("IL" IL VARS_TCC1 0 (VARS_TCC1-1 NIL 3646033415 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL BUMPN_BUMP 0 (BUMPN_BUMP-1 NIL 3656631410 ("" (GRIND-WITH-EXT) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_PLUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (BUMPN CONST-DECL "finite_set[nat]" IL NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (BUMP CONST-DECL "finite_set[nat]" IL NIL)) SHOSTAK))("IL" IL BUMPN_UNION 0 (BUMPN_UNION-1 NIL 3656567110 ("" (GRIND-WITH-EXT) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (UNION CONST-DECL "set" SETS NIL) (BUMPN CONST-DECL "finite_set[nat]" IL NIL) (FINITE_UNION APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/")) SHOSTAK))("IL" IL DROP_BUMP 0 (DROP_BUMP-1 NIL 3656520613 ("" (GRIND-WITH-EXT) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (NNINT_PLUS_POSINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (BUMPN CONST-DECL "finite_set[nat]" IL NIL) (DROP CONST-DECL "finite_set[nat]" IL NIL) (BUMP CONST-DECL "finite_set[nat]" IL NIL)) SHOSTAK))("IL" IL DROP_TCC1 0 (DROP_TCC1-1 NIL 3656390208 ("" (GRIND :IF-MATCH NIL) (("" (INST + "N!1" "LAMBDA (i | X!1(i + 1)): f!1(i+1)") (("" (GRIND :IF-MATCH NIL) (("" (FORWARD-CHAIN -) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((NNINT_PLUS_POSINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (< CONST-DECL "bool" REALS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL)) NIL))("IL" IL BUMPN_ZERO 0 (BUMPN_ZERO-1 NIL 3656521531 ("" (GRIND-WITH-EXT) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (BUMPN CONST-DECL "finite_set[nat]" IL NIL)) SHOSTAK))("IL" IL BUMPN_TCC2 0 (BUMPN_TCC2-1 NIL 3656517434 ("" (GRIND :IF-MATCH NIL) (("" (INST + "N!1" "LAMBDA (i | i >= j!1 AND X!1(i - j!1)): f!1(i - j!1)") (("1" (SKEEPS :PREDS? T) (("1" (FORWARD-CHAIN -) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ((IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (J!1 SKOLEM-CONST-DECL "nat" IL NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (< CONST-DECL "bool" REALS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (X!1 SKOLEM-CONST-DECL "finite_set[nat]" IL NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL)) NIL))("IL" IL BUMPN_TCC1 0 (BUMPN_TCC1-1 NIL 3656517434 ("" (SUBTYPE-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (>= CONST-DECL "bool" REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL)) NIL))("IL" IL IN_VARLIST_TCC1 0 (IN_VARLIST_TCC1-1 NIL 3656276690 ("" (GRIND :IF-MATCH NIL) (("" (INST + "length(L!1)" "LAMBDA (i | some[(variable?)]
                           (LAMBDA (v: (variable?)): index(v) = i)(L!1)): locate[(variable?)]((LAMBDA (v: (variable?)): index(v) = i), L!1)") (("1" (SKEEP) (("1" (TYPEPRED "locate[(variable?)](LAMBDA (v: (variable?)): index(v) = x1, L!1)") (("1" (TYPEPRED "locate[(variable?)](LAMBDA (v: (variable?)): index(v) = x2, L!1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP :PREDS? T) (("2" (REWRITE "some_nth") (("2" (SKEEP) (("2" (INST?) (("2" (REWRITE "member_nth") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (MEMBER DEF-DECL "bool" LIST_PROPS NIL) (L!1 SKOLEM-CONST-DECL "list[(variable?)]" IL NIL) (INDEX ADT-ACCESSOR-DECL "[(variable?) -> nat]" IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (SOME ADT-DEF-DECL "boolean" LIST_ADT NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (LENGTH DEF-DECL "nat" LIST_PROPS NIL) (< CONST-DECL "bool" REALS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (BELOW TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (NTH DEF-DECL "T" LIST_PROPS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (LOCATE DEF-DECL "{i: below(length(L)) | P(nth(L, length(L) - i - 1))}" FINSEQ_THEOREMS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL) (SOME_NTH FORMULA-DECL NIL FINSEQ_THEOREMS NIL) (I_1 SKOLEM-CONST-DECL "below(length(L!1))" IL NIL) (I SKOLEM-CONST-DECL "{i | some[(variable?)](lambda (v: (variable?)): index(v) = i)(L!1)}" IL NIL) (MEMBER_NTH FORMULA-DECL NIL FINSEQ_THEOREMS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (LIST TYPE-DECL NIL LIST_ADT NIL) (EVERY ADT-DEF-DECL "boolean" LIST_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL)) NIL))("IL" IL PUREPOPDEPTH 0 (PUREPOPDEPTH-1 NIL 3646034411 ("" (INDUCT-AND-SIMPLIFY "A") NIL NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (PURE? DEF-DECL "bool" IL NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL POPDEPTH_FILL 0 (POPDEPTH_FILL-1 NIL 3646034392 ("" (INDUCT-AND-SIMPLIFY "K") NIL NIL) ((ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (FILL DEF-DECL "IExpression" IL NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL) (NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL)) SHOSTAK))("IL" IL GET_TCC1 0 (GET_TCC1-1 NIL 3646033415 ("" (SUBTYPE-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (< CONST-DECL "bool" REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (INDEX ADT-ACCESSOR-DECL "[(variable?) -> nat]" IEXPRESSION_ADT NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (VALUE? CONST-DECL "bool" IL NIL) (STACK TYPE-EQ-DECL NIL IL NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL))("IL" IL POP_TCC2 0 (POP_TCC2-1 NIL 3646033415 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL))("IL" IL POP_TCC1 0 (POP_TCC1-1 NIL 3646033415 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL))("IL" IL REFCOUNT_PURE 0 (REFCOUNT_PURE-1 NIL 3676382439 ("" (INDUCT-AND-SIMPLIFY "A") NIL NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (PURE? DEF-DECL "bool" IL NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (REFCOUNT DEF-DECL "nat" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL)) SHOSTAK))("IL" IL REFCOUNT_TCC1 0 (REFCOUNT_TCC1-1 NIL 3646033320 ("" (GRIND) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL REFS_FILL 0 (REFS_FILL-1 NIL 3646034363 ("" (INDUCT-AND-SIMPLIFY "K") (("1" (APPLY-EXTENSIONALITY) NIL NIL) ("2" (APPLY-EXTENSIONALITY) NIL NIL) ("3" (REWRITE "contextPurefill") NIL NIL)) NIL) ((POP ADT-CONSTRUCTOR-DECL "[IExpression -> (pop?)]" IEXPRESSION_ADT NIL) (POP? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (LETEXPR ADT-CONSTRUCTOR-DECL "[[IExpression, IExpression] -> (letexpr?)]" IEXPRESSION_ADT NIL) (LETEXPR? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (FILL DEF-DECL "IExpression" IL NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (REFS DEF-DECL "bool" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL)) SHOSTAK))("IL" IL PURE_REFS 0 (PURE_REFS-1 NIL 3646034342 ("" (INDUCT-AND-SIMPLIFY "A") (("" (REWRITE "pure_contextPure") NIL NIL)) NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (PURE? DEF-DECL "bool" IL NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (REFS DEF-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL REFS_TCC1 0 (REFS_TCC1-1 NIL 3646033320 ("" (TYPEPRED "IExpression_adt.<<") (("" (EXPAND "strict_well_founded?") (("" (EXPAND "strict_order?") (("" (GROUND) (("" (HIDE -1 -2) (("" (GRIND :IF-MATCH NIL) (("" (INST - "p!1") (("" (GROUND) (("1" (SKOSIMP*) (("1" (INST + "y!2") (("1" (SKEEP) (("1" (INST?) (("1" (TYPEPRED "x_1") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "y!2") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (INST + "y!1") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((WELL_FOUNDED? CONST-DECL "bool" ORDERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (>= CONST-DECL "bool" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (STRICT_ORDER? CONST-DECL "bool" ORDERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (STRICT_WELL_FOUNDED? CONST-DECL "bool" ORDERS NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL CONTEXTPUREPUREREDEX 0 (CONTEXTPUREPUREREDEX-1 NIL 3682299553 ("" (INDUCT "A") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (SKEEP*) (("4" (GRIND) NIL NIL)) NIL) ("5" (SKEEP*) (("5" (GRIND) NIL NIL)) NIL) ("6" (SKEEP*) (("6" (HIDE (-1 -2 -3)) (("6" (GRIND) (("1" (POSTPONE) NIL NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("7" (POSTPONE) NIL NIL) ("8" (POSTPONE) NIL NIL) ("9" (POSTPONE) NIL NIL) ("10" (POSTPONE) NIL NIL) ("11" (POSTPONE) NIL NIL) ("12" (POSTPONE) NIL NIL) ("13" (POSTPONE) NIL NIL)) NIL) NIL SHOSTAK))("IL" IL PUREREDEXCONTEXTPURE 0 (PUREREDEXCONTEXTPURE-1 NIL 3646130634 ("" (INDUCT "A") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (SKEEP) (("6" (EXPAND "contextPure?" +) (("6" (EXPAND "pureRedex?" -4) (("6" (SPLIT -4) (("1" (EXPAND "pureLetRedex?") (("1" (EXPAND "letRedex?") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (EXPAND "applyRedex?") (("2" (PROPAX) NIL NIL)) NIL) ("3" (EXPAND "pureIftRedex?") (("3" (EXPAND "iftRedex?") (("3" (FLATTEN) (("3" (REWRITE "pure_contextPure" +) (("3" (REWRITE "pure_contextPure" +) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL) ("7" (GRIND) NIL NIL) ("8" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("7" (GRIND) NIL NIL) ("8" (GRIND) NIL NIL) ("9" (GRIND) NIL NIL) ("10" (GRIND) NIL NIL) ("11" (GRIND) NIL NIL) ("12" (GRIND) NIL NIL) ("13" (GRIND) NIL NIL) ("14" (GRIND) NIL NIL)) NIL) ((PURE? DEF-DECL "bool" IL NIL) (PURERELEASEREDEX? CONST-DECL "bool" IL NIL) (RELEASEREDEX? CONST-DECL "bool" IL NIL) (POPREDEX? CONST-DECL "bool" IL NIL) (NEWREFREDEX? CONST-DECL "bool" IL NIL) (NEWINTREDEX? CONST-DECL "bool" IL NIL) (LOOKUPREDEX? CONST-DECL "bool" IL NIL) (UPDATEREDEX? CONST-DECL "bool" IL NIL) (PUREIFTREDEX? CONST-DECL "bool" IL NIL) (IFTREDEX? CONST-DECL "bool" IL NIL) (APPLYREDEX? CONST-DECL "bool" IL NIL) (PURELETREDEX? CONST-DECL "bool" IL NIL) (LETREDEX? CONST-DECL "bool" IL NIL) (ATOM? CONST-DECL "bool" IL NIL) (VALUE? CONST-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (PUREREDEX? CONST-DECL "bool" IL NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL PURERELEASEREDEX?_TCC1 0 (PURERELEASEREDEX?_TCC1-1 NIL 3693185170 ("" (GRIND) NIL NIL) ((RELEASEREDEX? CONST-DECL "bool" IL NIL)) NIL))("IL" IL PUREIFTREDEX?_TCC1 0 (PUREIFTREDEX?_TCC1-1 NIL 3646033320 ("" (SUBTYPE-TCC) NIL NIL) ((IFTREDEX? CONST-DECL "bool" IL NIL)) NIL))("IL" IL PURELETREDEX?_TCC1 0 (PURELETREDEX?_TCC1-1 NIL 3646033320 ("" (SUBTYPE-TCC) NIL NIL) ((VALUE? CONST-DECL "bool" IL NIL) (ATOM? CONST-DECL "bool" IL NIL) (LETREDEX? CONST-DECL "bool" IL NIL)) NIL))("IL" IL PUREAPPLYREDEX 0 (PUREAPPLYREDEX-1 NIL 3682268823 ("" (INDUCT-AND-SIMPLIFY "A") NIL NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (APPLYREDEX? CONST-DECL "bool" IL NIL) (PURE? DEF-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL CONTEXTPUREFILL 0 (CONTEXTPUREFILL-1 NIL 3646034319 ("" (INDUCT-AND-SIMPLIFY "K") NIL NIL) ((ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (FILL DEF-DECL "IExpression" IL NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (CPURE? DEF-DECL "bool" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL)) SHOSTAK))("IL" IL BUILDCONTEXTPURE_TCC5 0 (BUILDCONTEXTPURE_TCC5-1 NIL 3693185170 ("" (GRIND) NIL NIL) ((CPURE? DEF-DECL "bool" IL NIL)) NIL))("IL" IL BUILDCONTEXTPURE_TCC4 0 (BUILDCONTEXTPURE_TCC4-1 NIL 3693185170 ("" (SKEEP* :PREDS? T) (("" (TYPEPRED "v(B)") (("" (GRIND) NIL NIL)) NIL)) NIL) ((AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (CPURE? DEF-DECL "bool" IL NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL)) NIL))("IL" IL BUILDCONTEXTPURE_TCC3 0 (BUILDCONTEXTPURE_TCC3-1 NIL 3646033320 ("" (RECURSIVE-JUDGEMENT-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL)) NIL))("IL" IL BUILDCONTEXTPURE_TCC2 0 (BUILDCONTEXTPURE_TCC2-1 NIL 3646033320 ("" (SKEEP* :PREDS? T) (("" (TYPEPRED "v(B)") (("" (GRIND) NIL NIL)) NIL)) NIL) ((AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (CPURE? DEF-DECL "bool" IL NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL)) NIL))("IL" IL BUILDCONTEXTPURE_TCC1 0 (BUILDCONTEXTPURE_TCC1-1 NIL 3646033320 ("" (RECURSIVE-JUDGEMENT-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL)) NIL))("IL" IL PURE_CONTEXTPURE 0 (PURE_CONTEXTPURE-1 NIL 3646034299 ("" (INDUCT-AND-SIMPLIFY "A") NIL NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (PURE? DEF-DECL "bool" IL NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL PURE?_TCC4 0 (PURE?_TCC4-1 NIL 3693185170 ("" (SKEEP) (("" (REPLACE -1) (("" (GRIND) NIL NIL)) NIL)) NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL PURE?_TCC3 0 (PURE?_TCC3-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL PURE?_TCC2 0 (PURE?_TCC2-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL PURE?_TCC1 0 (PURE?_TCC1-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL CONTEXT_COMPOSITION 0 (CONTEXT_COMPOSITION-1 NIL 3646034275 ("" (INDUCT-AND-SIMPLIFY "K1") NIL NIL) ((ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (FILL DEF-DECL "IExpression" IL NIL) (COMPOSE DEF-DECL "IContext" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL)) SHOSTAK))("IL" IL BUILDCONTEXT_TCC5 0 (BUILDCONTEXT_TCC5-1 NIL 3646033320 ("" (GRIND) NIL NIL) ((FILL DEF-DECL "IExpression" IL NIL)) NIL))("IL" IL BUILDCONTEXT_TCC4 0 (BUILDCONTEXT_TCC4-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL BUILDCONTEXT_TCC3 0 (BUILDCONTEXT_TCC3-1 NIL 3646033320 ("" (SKOSIMP*) (("" (EXPAND "fill" +) (("" (TYPEPRED "v!1(B!1)") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((FILL DEF-DECL "IExpression" IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (STRICT_WELL_FOUNDED? CONST-DECL "bool" ORDERS NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL BUILDCONTEXT_TCC2 0 (BUILDCONTEXT_TCC2-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL BUILDCONTEXT_TCC1 0 (BUILDCONTEXT_TCC1-1 NIL 3646033320 ("" (SKOSIMP*) (("" (EXPAND "fill" +) (("" (TYPEPRED "v!1(B!1)") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((FILL DEF-DECL "IExpression" IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (STRICT_WELL_FOUNDED? CONST-DECL "bool" ORDERS NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL CONTEXT_LEMMA 0 (CONTEXT_LEMMA-1 NIL 3646034052 ("" (INDUCT "A") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (SKEEP) (("4" (INST + "hole" "application(application1_var, application2_var)") (("4" (GRIND) NIL NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (GROUND) (("1" (INST + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("1" (GRIND) NIL NIL)) NIL) ("2" (SKEEP) (("2" (INST + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (INST + "letc(K, letexpr2_var)" "B") (("3" (GRIND) NIL NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) (("4" (INST + "letc(K!1, letexpr2_var)" "B!1") (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (SKEEP) (("6" (INST + "hole" "ift(ift1_var, ift2_var, ift3_var)") (("6" (GRIND) NIL NIL)) NIL)) NIL) ("7" (SKEEP) (("7" (INST + "hole" "update(update1_var, update2_var, update3_var)") (("7" (GRIND) NIL NIL)) NIL)) NIL) ("8" (SKEEP) (("8" (INST + "hole" "lookup(lookup1_var, lookup2_var)") (("8" (GRIND) NIL NIL)) NIL)) NIL) ("9" (SKEEP) (("9" (INST + "hole" "newint(newint1_var)") (("9" (GRIND) NIL NIL)) NIL)) NIL) ("10" (SKEEP) (("10" (INST + "hole" "newref(newref1_var)") (("10" (GRIND) NIL NIL)) NIL)) NIL) ("11" (SKEEP) (("11" (GROUND) (("1" (INST + "hole" "pop(pop1_var)") (("1" (GRIND) NIL NIL)) NIL) ("2" (SKEEP) (("2" (INST + "popc(K)" "B") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("12" (SKEEP) (("12" (INST + "hole" "ref(ref1_var)") (("12" (GRIND) NIL NIL)) NIL)) NIL) ("13" (SKEEP) (("13" (INST + "hole" "release(release1_var, release2_var)") (("13" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((RELEASE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (RELEASE ADT-CONSTRUCTOR-DECL "[[(variable?), IExpression] -> (release?)]" IEXPRESSION_ADT NIL) (REF ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" IEXPRESSION_ADT NIL) (REF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (POPC? ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL) (POPC ADT-CONSTRUCTOR-DECL "[IContext -> (popc?)]" IL NIL) (POP ADT-CONSTRUCTOR-DECL "[IExpression -> (pop?)]" IEXPRESSION_ADT NIL) (POP? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NEWREF ADT-CONSTRUCTOR-DECL "[nat -> (newref?)]" IEXPRESSION_ADT NIL) (NEWREF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NEWINT ADT-CONSTRUCTOR-DECL "[nat -> (newint?)]" IEXPRESSION_ADT NIL) (NEWINT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (LOOKUP? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (LOOKUP ADT-CONSTRUCTOR-DECL "[[(variable?), (variable?)] -> (lookup?)]" IEXPRESSION_ADT NIL) (UPDATE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (UPDATE ADT-CONSTRUCTOR-DECL "[[(variable?), (variable?), (variable?)] -> (update?)]" IEXPRESSION_ADT NIL) (IFT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (IFT ADT-CONSTRUCTOR-DECL "[[(variable?), IExpression, IExpression] -> (ift?)]" IEXPRESSION_ADT NIL) (LETC? ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL) (LETC ADT-CONSTRUCTOR-DECL "[[IContext, IExpression] -> (letc?)]" IL NIL) (LETEXPR ADT-CONSTRUCTOR-DECL "[[IExpression, IExpression] -> (letexpr?)]" IEXPRESSION_ADT NIL) (LETEXPR? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (APPLICATION ADT-CONSTRUCTOR-DECL "[[nat, list[(variable?)]] -> (application?)]" IEXPRESSION_ADT NIL) (APPLICATION? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (EVERY ADT-DEF-DECL "boolean" LIST_ADT NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (LIST TYPE-DECL NIL LIST_ADT NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (HOLE ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL) (HOLE? ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL) (RELEASEREDEX? CONST-DECL "bool" IL NIL) (POPREDEX? CONST-DECL "bool" IL NIL) (NEWREFREDEX? CONST-DECL "bool" IL NIL) (NEWINTREDEX? CONST-DECL "bool" IL NIL) (LOOKUPREDEX? CONST-DECL "bool" IL NIL) (UPDATEREDEX? CONST-DECL "bool" IL NIL) (IFTREDEX? CONST-DECL "bool" IL NIL) (APPLYREDEX? CONST-DECL "bool" IL NIL) (LETREDEX? CONST-DECL "bool" IL NIL) (VALUE? CONST-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (FILL DEF-DECL "IExpression" IL NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (REDEX? CONST-DECL "bool" IL NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (ATOM? CONST-DECL "bool" IL NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL FILL_TCC2 0 (FILL_TCC2-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IContext])" IL NIL)) NIL))("IL" IL FILL_TCC1 0 (FILL_TCC1-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IContext])" IL NIL)) NIL))("rreduction" rreduction lookupReduce_TCC13 0 (lookupReduce_TCC13-1 nil 3696570131 ("" (subtype-tcc) nil nil) nil nil))("rreduction" rreduction lookupReduce_TCC12 0 (lookupReduce_TCC12-1 nil 3696570131 ("" (subtype-tcc) nil nil) nil nil))("rreduction" rreduction lookupReduce_TCC11 0 (lookupReduce_TCC11-1 nil 3696570131 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction lookupReduce_TCC10 0 (lookupReduce_TCC10-1 nil 3696570131 ("" (skeep* :preds? t) (("" (ground) (("1" (typepred "grS`count(avalindex)") (("1" (expand "refcount") (("1" (expand "refcountStack") (("1" (use "count_elem[(IL.value?)]") (("1" (ground) (("1" (inst + "stack`length - 1 - index(avar)") (("1" (assert) (("1" (expand "get") (("1" (assert) nil nil)) nil)) nil) ("2" (use "lookupReduce_TCC7") (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst - "pos") (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "refcount") (("2" (expand "refcountStack") (("2" (rewrite "count_update") (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (typepred "grS`count(avalindex)") (("1" (expand "refcount") (("1" (expand "refcountStack") (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil))("rreduction" rreduction lookupReduce_TCC9 0 (lookupReduce_TCC9-1 nil 3696570131 ("" (skeep* :preds? t) (("" (use "reduction.lookupReduce_TCC6") (("" (inst - "rstate2estate(grS)" "stack") (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst - "pos") (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (ground) (("1" (lazy-grind) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)) nil) ("2" (hide 3) (("2" (lazy-grind) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)) nil) ("2" (hide 3) (("2" (lazy-grind) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil) ("3" (hide 3) (("3" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil) ((lookupReduce_TCC6 subtype-tcc nil reduction nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (get const-decl "(value?)" IL nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (markv const-decl "(variable?)" preprocess nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (position adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (lookup? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}" rreduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (store skolem-const-decl "Store(grS`domain)" rreduction nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (stack skolem-const-decl "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (mark def-decl "IExpression" preprocess nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (estate type-eq-decl nil reduction nil) (rstate2estate const-decl "estate" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (lookupRedex? const-decl "bool" IL nil) (grS skolem-const-decl "{grS | lookupRedex?(grS`redex)}" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction lookupReduce_TCC8 0 (lookupReduce_TCC8-1 nil 3696570131 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (value? const-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction ifReduce_TCC8 0 (ifReduce_TCC8-1 nil 3696194804 ("" (skeep* :preds? t) (("" (typepred "grS`count(x1)") (("" (expand "refcount") (("" (expand "pureIftRedex?") (("" (expand "iftRedex?") (("" (ground) (("" (expand "refcountExpr") (("" (rewrite "pure_refs") (("1" (rewrite "pure_refs") nil nil) ("2" (expand "pure?" +) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pureIftRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (pure_refs formula-decl nil IL nil) (pure? def-decl "bool" IL nil) (refcountExpr const-decl "nat" rreduction nil) (iftRedex? const-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction ifReduce_TCC7 0 (ifReduce_TCC7-1 nil 3696194804 ("" (skeep* :preds? t) (("" (use "reduction.ifReduce_TCC4") (("" (inst - "rstate2estate(grS)" "stack") (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst - "thenexpr") (("1" (split) (("1" (inst?) (("1" (split) (("1" (ground) (("1" (lazy-grind :rewrites "purePopDepth") nil nil) ("2" (lazy-grind :rewrites "purePopDepth") nil nil) ("3" (grind :rewrites "purePopDepth" :if-match nil) nil nil) ("4" (expand "pureIftRedex?") (("4" (expand "iftRedex?") (("4" (ground) (("4" (expand "mark" -) (("4" (decompose-equality -) (("4" (replace -22) (("4" (replace -2 :dir RL) (("4" (rewrite "mark_release_set") (("1" (rewrite "mark_idem") nil nil) ("2" (hide-all-but 1) (("2" (grind :rewrites "vars_mark") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (inst -12 "i") (("5" (ground) (("5" (expand "pureIftRedex?") (("5" (expand "iftRedex?") (("5" (ground) (("5" (expand "mark" -) (("5" (decompose-equality -) (("5" (replace -23) (("5" (replace -2 :dir RL) (("5" (rewrite "vars_release_set") (("5" (hide-all-but (-1 -4 -22 2 3 5)) (("5" (grind :rewrites "vars_mark") (("5" (replace -1 :dir RL) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil) ("3" (hide 5) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ((ifReduce_TCC4 subtype-tcc nil reduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_release_set formula-decl nil preprocess nil) (add const-decl "(nonempty?)" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (difference const-decl "set" sets nil) (release_set def-decl "IExpression" preprocess nil) (elseexpr adt-accessor-decl "[(ift?) -> IExpression]" IExpression_adt nil) (thenexpr adt-accessor-decl "[(ift?) -> IExpression]" IExpression_adt nil) (union const-decl "set" sets nil) (markv const-decl "(variable?)" preprocess nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (condition adt-accessor-decl "[(ift?) -> (variable?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_difference application-judgement "finite_set[nat]" countability "sets_aux/") (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (finite_intersection1 application-judgement "finite_set[nat]" countability "sets_aux/") (vars_mark formula-decl nil preprocess nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil) (mark_idem formula-decl nil preprocess nil) (mark_release_set formula-decl nil preprocess nil) (iftRedex? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}" rreduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (store skolem-const-decl "Store(grS`domain)" rreduction nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (stack skolem-const-decl "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (mark def-decl "IExpression" preprocess nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (estate type-eq-decl nil reduction nil) (rstate2estate const-decl "estate" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (pureIftRedex? const-decl "bool" IL nil) (grS skolem-const-decl "{grS | pureIftRedex?(grS`redex)}" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction allcount_TCC2 0 (allcount_TCC2-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (injective? const-decl "bool" functions nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("rreduction" rreduction allcount_TCC1 0 (allcount_TCC1-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("rreduction" rreduction refcountStore_TCC2 0 (refcountStore_TCC2-1 nil 3650675711 ("" (skeep) (("" (postpone) nil nil)) nil) ((empty_card formula-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("rreduction" rreduction refcountStore_TCC1 0 (refcountStore_TCC1-1 nil 3650675711 ("" (skeep :preds? t) (("" (expand "convergent?") (("" (ground) (("1" (use "finite_countable") (("1" (case "subset?[(dom)](nonzero_elts(lambda (j: (dom)): refcountArray(R(j))(i),
                                restrict[nat, (dom), boolean](dom)), dom)") (("1" (forward-chain "countable_subset[(dom)]") nil nil) ("2" (hide -1 -2 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "convergent?") (("2" (flatten) (("2" (hide 2) (("2" (case "subset?[(dom)](nonzero_elts(lambda (j: (dom)): refcountArray(R(j))(i),
                                restrict[nat, (dom), boolean](dom)), dom)") (("1" (forward-chain "finite_subset[(dom)]") nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((convergent? const-decl "bool" convergence_set "sigma_set/") (convergent? const-decl "bool" countable_convergence "sigma_set/") (finite_subset formula-decl nil finite_sets nil) (finite_countable judgement-tcc nil countable_props "sets_aux/") (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil) (count const-decl "nat" finseq_theorems nil) (countable_subset formula-decl nil countability "sets_aux/") (is_countable const-decl "bool" countability "sets_aux/") (countable_set nonempty-type-eq-decl nil countability "sets_aux/") (subset? const-decl "bool" sets nil) (nonzero_elts const-decl "set[T]" convergence_set "sigma_set/") (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (refcountArray const-decl "nat" rreduction nil) (domainValue? const-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (restrict const-decl "R" restrict nil) (finite_restrict application-judgement "finite_set[S]" restrict_set_props nil)) nil))("rreduction" rreduction check_marked_TCC7 0 (check_marked_TCC7-1 nil 3698692883 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction rstate_TCC1 0 (rstate_TCC1-1 nil 3693496106 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction decref_noDangling 0 (decref_noDangling-1 nil 3698761544 ("" (postpone) nil nil) nil shostak))("preprocess" preprocess mark_TCC8 0 (mark_TCC8-1 nil 3683842373 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess releaset_set_top_mark 0 (releaset_set_top_mark-1 nil 3698777829 ("" (induct A) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil) ("13" (grind) nil nil)) nil) ((variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (difference const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (finite_difference application-judgement "finite_set[nat]" countability "sets_aux/") (bump const-decl "finite_set[nat]" IL nil) (markv const-decl "(variable?)" preprocess nil) (IExpression_induction formula-decl nil IExpression_adt nil) (mark def-decl "IExpression" preprocess nil) (top_releases def-decl "nat" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) shostak))("rreduction" rreduction lookupReduce_TCC8 0 (lookupReduce_TCC8-1 nil 3698757037 ("" (subtype-tcc) nil nil) nil nil))