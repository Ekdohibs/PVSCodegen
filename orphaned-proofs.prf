("intermediateLanguage" intermediateLanguage popDepth_TCC5 0 (popDepth_TCC5-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage popDepth_TCC4 0 (popDepth_TCC4-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage popDepth_TCC3 0 (popDepth_TCC3-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage popDepth_TCC2 0 (popDepth_TCC2-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage pure?_TCC4 0 (pure?_TCC4-1 nil 3645328217 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage purePopDepthContext 0 (purePopDepthContext-1 nil 3645515823 ("" (induct-and-simplify "K") (("" (postpone) nil nil)) nil) nil shostak))("intermediateLanguage" intermediateLanguage refcount_TCC4 0 (refcount_TCC4-1 nil 3645614580 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refcount_TCC3 0 (refcount_TCC3-1 nil 3645614580 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage estate_TCC1 0 (estate_TCC1-1 nil 3645702721 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage fill_TCC1 0 (fill_TCC1-1 nil 3645177900 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IContext])" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage fill_TCC2 0 (fill_TCC2-1 nil 3645177900 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IContext])" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage context_lemma 0 (context_lemma-1 nil 3645177902 ("" (induct "A") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (inst + "hole" "application(application1_var, application2_var)") (("3" (grind) nil nil)) nil)) nil) ("4" (skeep) (("4" (ground) (("1" (inst + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (inst + "letc(K, letexpr2_var)" "B") (("3" (grind) nil nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (inst + "letc(K!1, letexpr2_var)" "B!1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (inst + "hole" "ift(ift1_var, ift2_var, ift3_var)") (("5" (grind) nil nil)) nil)) nil) ("6" (skeep*) (("6" (inst + "hole" "update(update1_var, update2_var, update3_var)") (("6" (grind) nil nil)) nil)) nil) ("7" (skeep*) (("7" (inst + "hole" "lookup(lookup1_var, lookup2_var)") (("7" (grind) nil nil)) nil)) nil) ("8" (skeep) (("8" (inst + "hole" "newint(newint1_var)") (("8" (grind) nil nil)) nil)) nil) ("9" (skeep) (("9" (inst + "hole" "newref(newref1_var)") (("9" (grind) nil nil)) nil)) nil) ("10" (skeep) (("10" (ground) (("1" (inst + "hole" "pop(pop1_var)") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst + "popc(K)" "B") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("11" (skeep) (("11" (inst + "hole" "ref(ref1_var)") (("11" (grind) nil nil)) nil)) nil)) nil) ((ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (popc? adt-recognizer-decl "[IContext -> boolean]" intermediateLanguage nil) (popc adt-constructor-decl "[IContext -> (popc?)]" intermediateLanguage nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (newref adt-constructor-decl "[nat -> (newref?)]" IExpression_adt nil) (newref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (newint adt-constructor-decl "[nat -> (newint?)]" IExpression_adt nil) (newint? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lookup? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lookup adt-constructor-decl "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (update adt-constructor-decl "[[(variable?), (variable?), (variable?)] -> (update?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (letc? adt-recognizer-decl "[IContext -> boolean]" intermediateLanguage nil) (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]" intermediateLanguage nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (application adt-constructor-decl "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (hole adt-constructor-decl "(hole?)" intermediateLanguage nil) (hole? adt-recognizer-decl "[IContext -> boolean]" intermediateLanguage nil) (popRedex? const-decl "bool" intermediateLanguage nil) (newrefRedex? const-decl "bool" intermediateLanguage nil) (newintRedex? const-decl "bool" intermediateLanguage nil) (lookupRedex? const-decl "bool" intermediateLanguage nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (iftRedex? const-decl "bool" intermediateLanguage nil) (applyRedex? const-decl "bool" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (IExpression_induction formula-decl nil IExpression_adt nil) (fill def-decl "IExpression" intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (redex? const-decl "bool" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) shostak))("intermediateLanguage" intermediateLanguage buildContext_TCC1 0 (buildContext_TCC1-1 nil 3645328217 ("" (skosimp*) (("" (expand "fill" +) (("" (typepred "v!1(B!1)") (("" (assert) nil nil)) nil)) nil)) nil) ((fill def-decl "IExpression" intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil intermediateLanguage nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC2 0 (buildContext_TCC2-1 nil 3645328217 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC3 0 (buildContext_TCC3-1 nil 3645328217 ("" (skosimp*) (("" (expand "fill" +) (("" (typepred "v!1(B!1)") (("" (assert) nil nil)) nil)) nil)) nil) ((fill def-decl "IExpression" intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil intermediateLanguage nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC4 0 (buildContext_TCC4-1 nil 3645328217 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC5 0 (buildContext_TCC5-1 nil 3645328217 ("" (grind) nil nil) ((fill def-decl "IExpression" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage context_composition 0 (context_composition-1 nil 3645324754 ("" (induct-and-simplify "K1") nil nil) ((IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (fill def-decl "IExpression" intermediateLanguage nil) (compose def-decl "IContext" intermediateLanguage nil) (IContext_induction formula-decl nil intermediateLanguage nil)) shostak))("intermediateLanguage" intermediateLanguage pure?_TCC1 0 (pure?_TCC1-1 nil 3645328217 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure?_TCC2 0 (pure?_TCC2-1 nil 3645328217 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure?_TCC3 0 (pure?_TCC3-1 nil 3645328217 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure_contextPure 0 (pure_contextPure-1 nil 3645472996 ("" (induct-and-simplify "A") nil nil) ((IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IExpression_induction formula-decl nil IExpression_adt nil)) shostak))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC1 0 (buildcontextPure_TCC1-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC2 0 (buildcontextPure_TCC2-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC3 0 (buildcontextPure_TCC3-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC4 0 (buildcontextPure_TCC4-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC5 0 (buildcontextPure_TCC5-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((pure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage contextPurefill 0 (contextPurefill-1 nil 3645477567 ("" (induct-and-simplify "K") nil nil) ((IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext_induction formula-decl nil intermediateLanguage nil)) shostak))("intermediateLanguage" intermediateLanguage pureLetRedex?_TCC1 0 (pureLetRedex?_TCC1-1 nil 3645472989 ("" (subtype-tcc) nil nil) ((value? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage pureIftRedex?_TCC1 0 (pureIftRedex?_TCC1-1 nil 3645472989 ("" (subtype-tcc) nil nil) ((iftRedex? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC1 0 (refs_TCC1-1 nil 3645594035 ("" (typepred "IExpression_adt.<<") (("" (expand "strict_well_founded?") (("" (expand "strict_order?") (("" (ground) (("" (hide -1 -2) (("" (grind :if-match nil) (("" (inst - "p!1") (("" (ground) (("1" (skosimp*) (("1" (inst + "y!2") (("1" (skeep) (("1" (inst?) (("1" (typepred "x_1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "y!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (inst + "y!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (well_founded? const-decl "bool" orders nil) (contextPure? def-decl "bool" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (p!1 skolem-const-decl "pred[(contextPure?)]" intermediateLanguage nil) (y!2 skolem-const-decl "(extend[IExpression, (contextPure?), bool, FALSE](p!1))" intermediateLanguage nil) (x_1 skolem-const-decl "(p!1)" intermediateLanguage nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (strict_order? const-decl "bool" orders nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC2 0 (refs_TCC2-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC3 0 (refs_TCC3-1 nil 3645594035 ("" (skeep :preds? t) (("" (grind) nil nil)) nil) ((contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC4 0 (refs_TCC4-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC5 0 (refs_TCC5-1 nil 3645594035 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC6 0 (refs_TCC6-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC7 0 (refs_TCC7-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage pure_refs_TCC1 0 (pure_refs_TCC1-1 nil 3645614580 ("" (skeep) (("" (rewrite "pure_contextPure") nil nil)) nil) ((pure_contextPure formula-decl nil intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure_refs 0 (pure_refs-1 nil 3645614582 ("" (induct-and-simplify "A") (("" (rewrite "pure_contextPure") nil nil)) nil) ((pure_contextPure formula-decl nil intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (IExpression_induction formula-decl nil IExpression_adt nil)) shostak))("intermediateLanguage" intermediateLanguage refs_fill_TCC1 0 (refs_fill_TCC1-1 nil 3645614695 ("" (skeep) (("" (rewrite "contextPurefill") (("" (ground) nil nil)) nil)) nil) ((contextPurefill formula-decl nil intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (IContext type-decl nil intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refs_fill 0 (refs_fill-1 nil 3645614697 ("" (induct-and-simplify "K") (("1" (apply-extensionality) nil nil) ("2" (apply-extensionality) nil nil) ("3" (rewrite "contextPurefill") nil nil)) nil) ((contextPurefill formula-decl nil intermediateLanguage nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (fill def-decl "IExpression" intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (IContext type-decl nil intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (refs def-decl "bool" intermediateLanguage nil) (IContext_induction formula-decl nil intermediateLanguage nil)) shostak))("intermediateLanguage" intermediateLanguage refcount_TCC1 0 (refcount_TCC1-1 nil 3645594035 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage refcount_TCC2 0 (refcount_TCC2-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage push_TCC1 0 (push_TCC1-1 nil 3645226267 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (Stack type-eq-decl nil intermediateLanguage nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage push_TCC2 0 (push_TCC2-1 nil 3645226267 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("intermediateLanguage" intermediateLanguage pop_TCC1 0 (pop_TCC1-1 nil 3645226267 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage pop_TCC2 0 (pop_TCC2-1 nil 3645226267 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage get_TCC1 0 (get_TCC1-1 nil 3645245227 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("intermediateLanguage" intermediateLanguage popDepth_TCC1 0 (popDepth_TCC1-1 nil 3645226267 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage popdepth_fill 0 (popdepth_fill-1 nil 3645226269 ("" (induct-and-simplify "K") nil nil) ((IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (fill def-decl "IExpression" intermediateLanguage nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IContext_induction formula-decl nil intermediateLanguage nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak))("intermediateLanguage" intermediateLanguage purePopDepth 0 (purePopDepth-1 nil 3645515794 ("" (induct-and-simplify "A") nil nil) ((IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression_induction formula-decl nil IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak))("intermediateLanguage" intermediateLanguage vars_TCC1 0 (vars_TCC1-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC2 0 (vars_TCC2-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC3 0 (vars_TCC3-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC4 0 (vars_TCC4-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC5 0 (vars_TCC5-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC6 0 (vars_TCC6-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_decompose 0 (vars_decompose-1 nil 3645245511 ("" (induct-and-simplify "K") nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (fill def-decl "IExpression" intermediateLanguage nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IContext_induction formula-decl nil intermediateLanguage nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak))("intermediateLanguage" intermediateLanguage letReduce_TCC1 0 (letReduce_TCC1-1 nil 3645245508 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (pureLetRedex? const-decl "bool" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (vars def-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC2 0 (letReduce_TCC2-1 nil 3645245508 ("" (skosimp*) (("" (rewrite "contextPurefill") (("1" (typepred "A!1") (("1" (expand "contextPure?" +) (("1" (ground) (("1" (grind) (("1" (rewrite "pure_contextPure") nil nil) ("2" (rewrite "pure_contextPure") nil nil) ("3" (rewrite "pure_contextPure") nil nil) ("4" (rewrite "pure_contextPure") nil nil)) nil) ("2" (skeep) (("2" (rewrite "refs_fill") (("1" (typepred "gS!1`expr") (("1" (typepred "gS!1") (("1" (replace -) (("1" (hide -1) (("1" (inst?) (("1" (ground) (("1" (rewrite "refs_fill") (("1" (expand "pureLetRedex?") (("1" (ground) (("1" (use "pure_refs") (("1" (ground) (("1" (inst?) (("1" (expand "refs" -) (("1" (use "pure_refs") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "contextPurefill") (("2" (expand "pureLetRedex?") (("2" (ground) (("2" (expand "contextPure?" +) (("2" (rewrite "pure_contextPure") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "pureLetRedex?") (("3" (ground) (("3" (skeep) (("3" (rewrite "vars_decompose") (("3" (ground) (("1" (typepred "K!1") (("1" (typepred "gS!1") (("1" (typepred "gS!1`expr") (("1" (inst?) (("1" (inst - "i") (("1" (replace -3 :hide? t) (("1" (rewrite "vars_decompose") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "gS!1`expr") (("2" (hide -1 -2) (("2" (typepred "gS!1") (("2" (replace - :hide? t) (("2" (inst - "i") (("2" (rewrite "vars_decompose") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "A!1") (("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((contextPurefill formula-decl nil intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (pureLetRedex? const-decl "bool" intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (domainValue? const-decl "bool" intermediateLanguage nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (popDepth def-decl "nat" intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (Stack type-eq-decl nil intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (vars def-decl "bool" intermediateLanguage nil) (refs def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Store type-eq-decl nil intermediateLanguage nil) (pure_refs formula-decl nil intermediateLanguage nil) (refs_fill formula-decl nil intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (pure_contextPure formula-decl nil intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC3 0 (letReduce_TCC3-1 nil 3645245508 ("" (skosimp*) (("" (typepred "gS!1`stack") (("" (typepred "gS!1`expr") (("" (typepred "gS!1") (("" (replace - :hide? t) (("" (rewrite "popdepth_fill") (("" (typepred "A!1") (("" (hide -3) (("" (inst - "index(letrhs(A!1)) - popDepth(K!1)") (("1" (rewrite "vars_decompose") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pureLetRedex? const-decl "bool" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (domainValue? const-decl "bool" intermediateLanguage nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (Stack type-eq-decl nil intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (vars def-decl "bool" intermediateLanguage nil) (refs def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Store type-eq-decl nil intermediateLanguage nil) (popDepth def-decl "nat" intermediateLanguage nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (atom? const-decl "bool" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (K!1 skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (popDepth def-decl "nat" intermediateLanguage nil) (A!1 skolem-const-decl "(pureLetRedex?)" intermediateLanguage nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC4 0 (letReduce_TCC4-1 nil 3645245508 ("" (skosimp*) (("" (typepred "A!1") (("" (grind) nil nil)) nil)) nil) ((pureLetRedex? const-decl "bool" intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC5 0 (letReduce_TCC5-1 nil 3645477565 ("" (skosimp*) (("" (ground) (("1" (typepred "gS!1`stack") (("1" (rewrite "popdepth_fill") (("1" (typepred "gS!1") (("1" (replace - :hide? t) (("1" (rewrite "popdepth_fill") (("1" (rewrite "popDepth" +) (("1" (typepred "A!1") (("1" (expand "pureLetRedex?") (("1" (ground) (("1" (forward-chain "purePopDepth") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "i!1") (("2" (lift-if) (("2" (ground) (("1" (expand "push") (("1" (ground) (("1" (typepred "gS!1`stack") (("1" (expand "get") (("1" (inst?) (("1" (typepred "A!1") (("1" (typepred "gS!1`expr") (("1" (hide -1 -2) (("1" (typepred "gS!1") (("1" (replace - :hide? t) (("1" (assert) (("1" (inst - "index(letrhs(A!1)) - gS!1`stack`length") (("1" (rewrite "vars_decompose") (("1" (ground) (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "gS!1`stack") (("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (typepred "gS!1`stack") (("2" (grind) (("2" (typepred "gS!1`expr") (("2" (typepred "gS!1") (("2" (replace - :hide? t) (("2" (inst?) (("2" (rewrite "refs_fill") (("2" (ground) (("2" (typepred "A!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (purePopDepth formula-decl nil intermediateLanguage nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (push const-decl "Stack" intermediateLanguage nil) (get const-decl "(value?)" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (popDepth def-decl "nat" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (vars def-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (pureLetRedex? const-decl "bool" intermediateLanguage nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (gS!1 skolem-const-decl "{gS | gS`expr = fill(K!1, A!1)}" intermediateLanguage nil) (A!1 skolem-const-decl "(pureLetRedex?)" intermediateLanguage nil) (K!1 skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refs_fill formula-decl nil intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC1 0 (updateReduce_TCC1-1 nil 3645791010 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (vars def-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC2 0 (updateReduce_TCC2-1 nil 3645791010 ("" (skeep* :preds? t) (("" (replace -6 :hide? t) (("" (hide -2) (("" (inst - "index(target(A)) - stack`length") (("1" (replace -8 :hide? t) (("1" (rewrite "vars_decompose") (("1" (hide -5) (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (stack skolem-const-decl "{S: Stack |
   popDepth(gS`expr) = S`length AND
    (FORALL (i: below(S`length)): domainValue?(gS`store`domain)(S`seq(i)))}" intermediateLanguage nil) (gS skolem-const-decl "{gS | gS`expr = fill(K, A)}" intermediateLanguage nil) (K skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (domainValue? const-decl "bool" intermediateLanguage nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (vars def-decl "bool" intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (popDepth def-decl "nat" intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (A skolem-const-decl "(updateRedex?)" intermediateLanguage nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC3 0 (updateReduce_TCC3-1 nil 3645791010 ("" (skeep* :preds? t) (("" (hide -3) (("" (replace -6) (("" (replace -11) (("" (inst - "index(lhs(A)) - stack`length") (("1" (rewrite "vars_decompose") (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (get const-decl "(value?)" intermediateLanguage nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (A skolem-const-decl "(updateRedex?)" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars def-decl "bool" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (K skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (gS skolem-const-decl "{gS | gS`expr = fill(K, A)}" intermediateLanguage nil) (stack skolem-const-decl "{S: Stack |
   popDepth(gS`expr) = S`length AND
    (FORALL (i: below(S`length)): domainValue?(gS`store`domain)(S`seq(i)))}" intermediateLanguage nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC4 0 (updateReduce_TCC4-1 nil 3645791010 ("" (skeep* :preds? t) (("" (hide -3 -4 10) (("" (replace -6 :hide? t) (("" (replace -10 :hide? t) (("" (inst - "index(rhs(A)) - stack`length") (("1" (rewrite "vars_decompose") (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (get const-decl "(value?)" intermediateLanguage nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (A skolem-const-decl "(updateRedex?)" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars def-decl "bool" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (K skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (gS skolem-const-decl "{gS | gS`expr = fill(K, A)}" intermediateLanguage nil) (stack skolem-const-decl "{S: Stack |
   popDepth(gS`expr) = S`length AND
    (FORALL (i: below(S`length)): domainValue?(gS`store`domain)(S`seq(i)))}" intermediateLanguage nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC5 0 (updateReduce_TCC5-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC6 0 (updateReduce_TCC6-1 nil 3645791010 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" intermediateLanguage nil) (add const-decl "(nonempty?)" sets nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC7 0 (updateReduce_TCC7-1 nil 3645791010 ("" (skeep* :preds? t) (("" (inst - "refindex(aval)") (("" (assert) (("" (replace -14) (("" (replace -9) (("" (rewrite "refs_fill") (("" (hide-all-but (-8 2 4 -11 -15)) (("" (grind :if-match nil) (("" (inst?) (("1" (ground) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((get const-decl "(value?)" intermediateLanguage nil) (add const-decl "(nonempty?)" sets nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC8 0 (updateReduce_TCC8-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC9 0 (updateReduce_TCC9-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC10 0 (updateReduce_TCC10-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC11 0 (updateReduce_TCC11-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("IL" IL popDepth_TCC1 0 (popDepth_TCC1-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL refcount_TCC2 0 (refcount_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_fill_TCC1 0 (refs_fill_TCC1-1 nil 3646033320 ("" (skeep) (("" (rewrite "contextPurefill") (("" (ground) nil nil)) nil)) nil) ((IContext type-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (contextPurefill formula-decl nil IL nil)) nil))("IL" IL pure_refs_TCC1 0 (pure_refs_TCC1-1 nil 3646033320 ("" (skeep) (("" (rewrite "pure_contextPure") nil nil)) nil) ((IExpression type-decl nil IExpression_adt nil) (pure_contextPure formula-decl nil IL nil)) nil))("IL" IL refs_TCC9 0 (refs_TCC9-1 nil 3646130633 ("" (termination-tcc) nil nil) nil nil))("IL" IL refs_TCC8 0 (refs_TCC8-1 nil 3646130633 ("" (subtype-tcc) nil nil) nil nil))("IL" IL refs_TCC7 0 (refs_TCC7-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_TCC6 0 (refs_TCC6-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_TCC5 0 (refs_TCC5-1 nil 3646033320 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL refs_TCC4 0 (refs_TCC4-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_TCC3 0 (refs_TCC3-1 nil 3646033320 ("" (skeep :preds? t) (("" (grind) nil nil)) nil) ((contextPure? def-decl "bool" IL nil)) nil))("IL" IL refs_TCC2 0 (refs_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL push_TCC2 0 (push_TCC2-1 nil 3646033320 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("IL" IL push_TCC1 0 (push_TCC1-1 nil 3646033320 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (Stack type-eq-decl nil IL nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("finite_set_theorems" finite_set_theorems nat_fullset_infinite 0 (nat_fullset_infinite-1 nil 3649860953 ("" (induct "n") (("1" (skeep) (("1" (typepred "f(0)") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep* :preds? t) (("2" (inst + "LAMBDA (i: nat): IF f(i + 1) = 0 THEN f(0) - 1 ELSE f(i + 1) - 1 ENDIF") (("1" (expand "injective?") (("1" (skeep) (("1" (apply (repeat (lift-if))) (("1" (ground) (("1" (inst - "x1 + 1" "x2 + 1") (("1" (ground) nil nil)) nil) ("2" (inst - 0 "x2 + 1") (("2" (assert) nil nil)) nil) ("3" (inst - 0 "x1 + 1") (("3" (assert) nil nil)) nil) ("4" (inst - "x1 + 1" "x2 + 1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (j skolem-const-decl "nat" finite_set_theorems nil) (f skolem-const-decl "(injective?[nat, below(1 + j)])" finite_set_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak))("finite_set_theorems" finite_set_theorems least_out_rec_TCC5 0 (least_out_rec_TCC5-1 nil 3649907982 ("" (subtype-tcc) nil nil) nil nil))("finite_set_theorems" finite_set_theorems least_out_rec_TCC4 0 (least_out_rec_TCC4-1 nil 3649901266 ("" (skeep :preds? t) (("" (ground) (("" (skeep :preds? t) (("" (typepred "v(NS, 1 + i)") (("" (inst?) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("reduction" reduction updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3647118642 ("" (grind) nil nil) ((bool nonempty-type-eq-decl nil booleans nil) (Store type-eq-decl nil reduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) (add const-decl "(nonempty?)" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set" finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq type-eq-decl nil finite_sequences nil) (get const-decl "(value?)" IL nil) (refs def-decl "bool" IL nil) (vars def-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction" reduction pushlist_TCC1 0 (pushlist_TCC1-1 nil 3650126116 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (value? const-decl "bool" IL nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("IL" IL vars_decompose_TCC1 0 (vars_decompose_TCC1-1 nil 3650427978 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL vars_TCC9 0 (vars_TCC9-1 nil 3650427820 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL vars_TCC8 0 (vars_TCC8-1 nil 3650427820 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("reduction" reduction updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3650549580 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcount_TCC1 0 (refcount_TCC1-1 nil 3650675711 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction newrefReduce_TCC6 0 (newrefReduce_TCC6-1 nil 3650550591 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (value? const-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (domainValue? const-decl "bool" IL nil)) nil))("IL" IL vars_TCC10 0 (vars_TCC10-1 nil 3650647638 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC25 0 (mark_TCC25-1 nil 3655095779 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC24 0 (mark_TCC24-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC23 0 (mark_TCC23-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC22 0 (mark_TCC22-1 nil 3655095779 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC21 0 (mark_TCC21-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC20 0 (mark_TCC20-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC19 0 (mark_TCC19-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC18 0 (mark_TCC18-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC17 0 (mark_TCC17-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC16 0 (mark_TCC16-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC15 0 (mark_TCC15-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC14 0 (mark_TCC14-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC13 0 (mark_TCC13-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC12 0 (mark_TCC12-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC11 0 (mark_TCC11-1 nil 3655095779 ("" (grind) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC9 0 (vars_TCC9-1 nil 3650647638 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC8 0 (vars_TCC8-1 nil 3650647638 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC7 0 (vars_TCC7-1 nil 3650256398 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC6 0 (vars_TCC6-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC5 0 (vars_TCC5-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC4 0 (vars_TCC4-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("reduction" reduction newrefReduce_TCC6 0 (newrefReduce_TCC6-1 nil 3655657128 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (value? const-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (domainValue? const-decl "bool" IL nil)) nil))("preprocess" preprocess markc_TCC3 0 (markc_TCC3-1 nil 3655657330 ("" (termination-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC11 0 (mark_TCC11-1 nil 3655657330 ("" (termination-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC10 0 (mark_TCC10-1 nil 3655095779 ("" (skeep*) (("" (lemma "vars_finite") (("" (inst? :if-match all) (("" (rewrite "finite_difference[nat]") nil nil)) nil)) nil)) nil) ((vars_finite formula-decl nil IL nil) (finite_difference judgement-tcc nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC9 0 (mark_TCC9-1 nil 3655095779 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC8 0 (mark_TCC8-1 nil 3655095779 ("" (skeep*) (("" (lemma "vars_finite") (("" (inst? :if-match all) (("" (rewrite "finite_difference[nat]") nil nil)) nil)) nil)) nil) ((vars_finite formula-decl nil IL nil) (finite_difference judgement-tcc nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) nil))("preprocess" preprocess markvar_TCC2 0 (markvar_TCC2-1 nil 3655327556 ("" (subtype-tcc) nil nil) nil nil))("finite_set_theorems" finite_set_theorems finite_set_induction_TCC1 0 (finite_set_induction_TCC1-1 nil 3656130778 ("" (subtype-tcc) nil nil) nil nil))("IL" IL vars_TCC3 0 (vars_TCC3-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_fill_TCC1 0 (mark_fill_TCC1-1 nil 3656268735 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess drop_TCC1 0 (drop_TCC1-1 nil 3656388994 ("" (grind :if-match nil) (("" (inst + "N!1" "LAMBDA (i | X!1(i + 1)): f!1(i+1)") (("" (grind :if-match nil) (("" (forward-chain -) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) nil))("preprocess" preprocess bump_TCC2 0 (bump_TCC2-1 nil 3655508728 ("" (grind :if-match nil) (("" (inst + "N!1" "LAMBDA (i | i > 0 AND X!1(i - 1)): f!1(i - 1)") (("1" (skeep) (("1" (forward-chain -) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (X!1 skolem-const-decl "finite_set[nat]" preprocess nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) nil))("preprocess" preprocess bump_TCC1 0 (bump_TCC1-1 nil 3655508728 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL bump_TCC2 0 (bump_TCC2-1 nil 3656390208 ("" (grind :if-match nil) (("" (inst + "N!1" "LAMBDA (i | i > 0 AND X!1(i - 1)): f!1(i - 1)") (("1" (skeep) (("1" (forward-chain -) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (X!1 skolem-const-decl "finite_set[nat]" IL nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)) nil))("IL" IL bump_TCC1 0 (bump_TCC1-1 nil 3656390208 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL bump_drop 0 (bump_drop-1 nil 3656520497 ("" (skeep) (("" (apply-extensionality) (("" (hide 2) (("" (grind :if-match nil) (("" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("finite_set_theorems" finite_set_theorems bump_finite 0 (bump_finite-1 nil 3655675856 ("" (skeep) (("" (typepred "X") (("" (expand "is_finite") (("" (skosimp) (("" (inst + "N!1" "LAMBDA (i: (bump(X))): f!1(i+1)") (("1" (grind :if-match nil) (("1" (forward-chain -) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (bump const-decl "bool" finite_set_theorems nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("preprocess" preprocess wellformed?_TCC1 0 (wellformed?_TCC1-1 nil 3656737588 ("" (skeep) (("" (rewrite "every_nth") (("" (skeep) (("" (expand "<<") (("" (ground) (("" (rewrite "some_nth") (("" (inst + "i") (("1" (grind) nil nil) ("2" (grind) (("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every_nth formula-decl nil list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (some_nth formula-decl nil finseq_theorems nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (args adt-accessor-decl "[(application?) -> list[(variable?)]]" IExpression_adt nil) (restrict const-decl "R" restrict nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (A skolem-const-decl "IExpression" preprocess nil) (i skolem-const-decl "below(length(args))" preprocess nil) (args skolem-const-decl "list[(variable?)]" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("preprocess" preprocess wellformed_mark_TCC14 0 (wellformed_mark_TCC14-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((markvar const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC13 0 (wellformed_mark_TCC13-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil)) nil))("preprocess" preprocess wellformed_mark_TCC12 0 (wellformed_mark_TCC12-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((bump const-decl "finite_set[nat]" IL nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC11 0 (wellformed_mark_TCC11-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC10 0 (wellformed_mark_TCC10-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (markv const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC9 0 (wellformed_mark_TCC9-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (markv const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC8 0 (wellformed_mark_TCC8-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) nil nil))("preprocess" preprocess wellformed_mark_TCC7 0 (wellformed_mark_TCC7-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (countable_union application-judgement "countable_set[nat]" finite_set_theorems nil) (injective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil)) nil))("preprocess" preprocess wellformed_mark_TCC6 0 (wellformed_mark_TCC6-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (countable_union application-judgement "countable_set[nat]" finite_set_theorems nil) (injective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil)) nil))("preprocess" preprocess wellformed_mark_TCC5 0 (wellformed_mark_TCC5-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) nil nil))("preprocess" preprocess wellformed_mark_TCC4 0 (wellformed_mark_TCC4-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC3 0 (wellformed_mark_TCC3-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC2 0 (wellformed_mark_TCC2-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC1 0 (wellformed_mark_TCC1-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((markv const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("IL" IL buildcontextPure_TCC5 0 (buildcontextPure_TCC5-1 nil 3646033320 ("" (recursive-judgement-tcc) nil nil) ((cpure? def-decl "bool" IL nil)) nil))("IL" IL buildcontextPure_TCC4 0 (buildcontextPure_TCC4-1 nil 3646033320 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (cpure? def-decl "bool" IL nil)) nil))("finseq_theorems" finseq_theorems compose_append 0 (compose_append-1 nil 3676394329 ("" (postpone) nil nil) nil shostak))("finseq_theorems" finseq_theorems finseq2list2finseq 0 (finseq2list2finseq-1 nil 3676394691 ("" (induct-and-simplify "L") (("" (postpone) nil nil)) nil) nil shostak))("finseq_theorems" finseq_theorems finseq2list_append 0 (finseq2list_append-1 nil 3676428779 ("" (induct "l") (("1" (grind) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil) nil shostak))("finseq_theorems" finseq_theorems finseq2list_append_TCC3 0 (finseq2list_append_TCC3-1 nil 3676428777 ("" (subtype-tcc) nil nil) nil nil))("finseq_theorems" finseq_theorems finseq2list_append_TCC2 0 (finseq2list_append_TCC2-1 nil 3676428777 ("" (subtype-tcc) nil nil) nil nil))("finseq_theorems" finseq_theorems finseq2list_append_TCC1 0 (finseq2list_append_TCC1-1 nil 3676428777 ("" (subtype-tcc) nil nil) nil nil))("finseq_theorems" finseq_theorems finseqtolist_TCC2 0 (finseqtolist_TCC2-1 nil 3676433703 ("" (termination-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan addroundlist_TCC2 0 (addroundlist_TCC2-1 nil 3677707205 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[lrlist])" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan addroundlist_TCC1 0 (addroundlist_TCC1-1 nil 3677707205 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[lrlist])" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan treelevel_monotone 0 (treelevel_monotone-1 nil 3677729690 ("" (induct-and-simplify "X") (("" (postpone) nil nil)) nil) nil shostak))("lindstrom_scan" lindstrom_scan scan_TCC7 0 (scan_TCC7-1 nil 3677642327 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (tree type-decl nil lindstrom_scan nil) (labeleq def-decl "bool" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC6 0 (scan_TCC6-1 nil 3677642327 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (tree type-decl nil lindstrom_scan nil) (<= const-decl "bool" reals nil) (uint32 type-eq-decl nil lindstrom_scan nil) (labeleq def-decl "bool" lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (treelevel def-decl "bool" lindstrom_scan nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC5 0 (scan_TCC5-1 nil 3677642327 ("" (termination-tcc) nil nil) ((restrict const-decl "R" restrict nil) (<< adt-def-decl "(strict_well_founded?[tree])" lindstrom_scan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (uint32 type-eq-decl nil lindstrom_scan nil) (<= const-decl "bool" reals nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC4 0 (scan_TCC4-1 nil 3677642327 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (tree type-decl nil lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (<= const-decl "bool" reals nil) (uint32 type-eq-decl nil lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC3 0 (scan_TCC3-1 nil 3677642327 ("" (termination-tcc) nil nil) ((restrict const-decl "R" restrict nil) (<< adt-def-decl "(strict_well_founded?[tree])" lindstrom_scan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (uint32 type-eq-decl nil lindstrom_scan nil) (<= const-decl "bool" reals nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC28 0 (sscan_correct_TCC28-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC27 0 (sscan_correct_TCC27-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC26 0 (sscan_correct_TCC26-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC25 0 (sscan_correct_TCC25-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC24 0 (sscan_correct_TCC24-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC23 0 (sscan_correct_TCC23-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC22 0 (sscan_correct_TCC22-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC21 0 (sscan_correct_TCC21-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC20 0 (sscan_correct_TCC20-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC19 0 (sscan_correct_TCC19-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC18 0 (sscan_correct_TCC18-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC17 0 (sscan_correct_TCC17-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC16 0 (sscan_correct_TCC16-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC15 0 (sscan_correct_TCC15-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC14 0 (sscan_correct_TCC14-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC13 0 (sscan_correct_TCC13-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC12 0 (sscan_correct_TCC12-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC11 0 (sscan_correct_TCC11-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC10 0 (sscan_correct_TCC10-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC9 0 (sscan_correct_TCC9-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC8 0 (sscan_correct_TCC8-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC7 0 (sscan_correct_TCC7-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC6 0 (sscan_correct_TCC6-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC5 0 (sscan_correct_TCC5-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC4 0 (sscan_correct_TCC4-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC3 0 (sscan_correct_TCC3-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC2 0 (sscan_correct_TCC2-1 nil 3677897058 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (tree type-decl nil lindstrom_scan nil) (goodtree def-decl "bool" lindstrom_scan nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (uint32 type-eq-decl nil lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC1 0 (sscan_correct_TCC1-1 nil 3677897058 ("" (skeep :preds? t) (("" (expand "goodtree" -) (("" (assert) (("" (ground) (("1" (expand "goodtree") (("1" (lift-if) (("1" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ((goodtree def-decl "bool" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("lindstrom_scan" lindstrom_scan sscan_TCC35 0 (sscan_TCC35-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_TCC34 0 (sscan_TCC34-1 nil 3677897058 ("" (termination-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_TCC33 0 (sscan_TCC33-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction letApply_TCC7 0 (letApply_TCC7-1 nil 3683776766 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction letApply_TCC6 0 (letApply_TCC6-1 nil 3683776766 ("" (termination-tcc) nil nil) nil nil))("reduction" reduction letApply_TCC5 0 (letApply_TCC5-1 nil 3683776766 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction applyReduce_TCC4 0 (applyReduce_TCC4-1 nil 3650158977 ("" (skeeps :preds? t) (("" (typepred "popit(arity)(body)") (("" (ground) (("1" (lazy-grind) nil nil) ("2" (lazy-grind) nil nil) ("3" (rewrite "popit_popDepth") (("3" (expand "pushlist" +) (("3" (expand "o") (("3" (expand "list2finseq") (("3" (rewrite "map_length") (("3" (forward-chain "purePopDepth") (("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (Definition type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (popit def-decl "IExpression" reduction nil) (vars def-decl "finite_set[nat]" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (popit_pure rec-application-judgement "{B | (forall j: NOT refs(B)(j))}" reduction nil) (popitContextPure rec-application-judgement "(contextPure?)" reduction nil) (popit_var rec-application-judgement "{B | (forall j: vars(B)(j) = vars(A)(j + i))}" reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (popit_popDepth formula-decl nil reduction nil) (map_length formula-decl nil more_map_props nil) (get const-decl "(value?)" IL nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (drop const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (purePopDepth formula-decl nil IL nil) (below type-eq-decl nil nat_types nil) (Defs type-eq-decl nil reduction nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (pushlist const-decl "Stack" reduction nil) (O const-decl "finseq" finite_sequences nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (popDepth def-decl "nat" IL nil) (in_varlist const-decl "finite_set[nat]" IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("reduction" reduction pure_letApply_TCC2 0 (pure_letApply_TCC2-1 nil 3683818064 ("" (recursive-judgement-tcc) nil nil) nil nil))("reduction" reduction vars_letApply_TCC1 0 (vars_letApply_TCC1-1 nil 3683816779 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (in_varlist const-decl "finite_set[nat]" IL nil)) nil))("refcount" refcount applyReduce_TCC7 0 (applyReduce_TCC7-1 nil 3682124599 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil refcount nil) (applyRedex? const-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (Definition type-eq-decl nil refcount nil) (pure? def-decl "bool" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil)) nil))("refcount" refcount applyReduce_TCC6 0 (applyReduce_TCC6-1 nil 3682124599 ("" (skeep*) (("" (expand "refcount") (("" (expand "refcountStack") (("" (expand "pushlist") (("" (rewrite "count_compose") (("" (typepred "grS`count(i)") (("" (expand "refcount") (("" (replace -5) (("" (replace -1) (("" (expand "refcountStack") (("" (expand "refcountExpr" +) (("" (typepred "grS") (("" (rewrite "popit_refs") (("" (rewrite "pure_refs") (("1" (rewrite "pure_refs") (("1" (assert) nil nil)) nil) ("2" (rewrite "pureApplyRedex") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((refcountStack const-decl "nat" refcount nil) (count_compose formula-decl nil finseq_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (< const-decl "bool" reals nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (rstate type-eq-decl nil refcount nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil refcount nil) (applyRedex? const-decl "bool" IL nil) (map adt-def-decl "list[T1]" list_adt_map nil) (get const-decl "(value?)" IL nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (value? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (refcountExpr const-decl "nat" refcount nil) (Definition type-eq-decl nil refcount nil) (pure? def-decl "bool" IL nil) (popit_refs formula-decl nil reduction nil) (pureApplyRedex formula-decl nil IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pure_refs formula-decl nil IL nil) (pushlist const-decl "Stack" reduction nil) (refcount const-decl "nat" refcount nil)) nil))("refcount" refcount applyReduce_TCC5 0 (applyReduce_TCC5-1 nil 3676345135 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil refcount nil) (applyRedex? const-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (Definition type-eq-decl nil refcount nil) (pure? def-decl "bool" IL nil)) nil))("finseq_theorems" finseq_theorems count_update_TCC1 0 (count_update_TCC1-1 nil 3684271525 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcountStore_ref_TCC2 0 (refcountStore_ref_TCC2-1 nil 3685183231 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcountStore_ref_TCC1 0 (refcountStore_ref_TCC1-1 nil 3685183231 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcountStore_update_TCC1 0 (refcountStore_update_TCC1-1 nil 3692670917 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount store_update_TCC3 0 (store_update_TCC3-1 nil 3692717400 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount finite_enumeration_inverse_TCC2 0 (finite_enumeration_inverse_TCC2-1 nil 3692735784 ("" (existence-tcc) nil nil) nil nil))("refcount" refcount decr_TCC16 0 (decr_TCC16-1 nil 3685624183 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC15 0 (decr_TCC15-1 nil 3685569175 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("refcount" refcount decr_TCC14 0 (decr_TCC14-1 nil 3685100066 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC13 0 (decr_TCC13-2 "" 3692915495 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (lift-if) (("" (ground) (("" (expand "allcountStore") (("" (hide 3) (("" (expand "allcount") (("" (lift-if) (("" (ground) (("1" (use "card_is_0") (("1" (grind) (("1" (expand "emptyset") (("1" (typepred "r") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "o") (("2" (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)") (("1" (hide -1) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (decr_TCC13-1 nil 3685100066 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC12 0 (decr_TCC12-1 nil 3685100066 ("" (skeep*) (("" (lift-if) (("" (ground) (("1" (typepred "v(rS
                       WITH [`store(r)`seq(i - 1) := nil,
                             `count(refindex(subref))
                               := rS`count(refindex(subref)) - 1],
                     refindex(subref), rS`store(refindex(subref))`length)") (("1" (inst?) (("1" (ground) nil nil)) nil) ("2" (ground) (("1" (case "r = refindex(subref)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (skeep :preds? t) (("2" (case "r = refindex(subref)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil) ("2" (typepred "v(rS
               WITH [`store(r)`seq(i - 1) := nil,
                     `count(refindex(subref))
                       := rS`count(refindex(subref)) - 1],
             refindex(subref), rS`store(refindex(subref))`length)") (("1" (skeep) (("1" (inst - "r") (("1" (ground) (("1" (replace -1 :hide? t) (("1" (replace -6 :hide? t) (("1" (typepred "i") (("1" (inst - "j") (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (inst - "j") (("2" (replace -8 :hide? t) (("2" (replace -2 :hide? t) (("2" (lift-if) (("2" (ground) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "decr_TCC9") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (inst - "rS`count(refindex(subref)) - 1") (("2" (inst - "rS
                 WITH [`store(r)`seq(i - 1) := nil,
                       `count(refindex(subref))
                         := rS`count(refindex(subref)) - 1]") (("1" (assert) nil nil) ("2" (assert) (("2" (use "decr_TCC7") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (inst - "rS`count(refindex(subref)) - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (inst - "rS`count(refindex(subref)) - 1") nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (skeep) (("3" (inst - "j") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((i skolem-const-decl "{i: upto(rS`store(r)`length) |
   forall (j: below(rS`store(r)`length)):
     j >= i IMPLIES NOT ref?(rS`store(r)`seq(j))}" refcount nil) (r skolem-const-decl "(rS`domain)" refcount nil) (subref skolem-const-decl "(domainValue?(rS`domain))" refcount nil) (rS skolem-const-decl "rstate" refcount nil) (decr_TCC9 subtype-tcc nil refcount nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (allcountStore const-decl "nat" refcount nil) (lex2 const-decl "ordinal" lex2 nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (decr_TCC7 subtype-tcc nil refcount nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("refcount" refcount decr_TCC11 0 (decr_TCC11-2 "" 3685584855 ("" (skeep*) (("" (lift-if) (("" (ground) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil)) shostak) (decr_TCC11-1 nil 3685100066 ("" (termination-tcc) nil nil) nil nil))("refcount" refcount decr_TCC10 0 (decr_TCC10-1 nil 3684597206 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (flatten) (("" (hide 3) (("" (ground) (("" (hide 1) (("" (expand "allcountStore") (("" (expand "allcount") (("" (lift-if) (("" (ground) (("1" (use "card_is_0") (("1" (grind) (("1" (expand "emptyset") (("1" (typepred "r") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (replace -6 :hide? t) (("2" (assert) (("2" (expand "o") (("2" (case "(LAMBDA (x: below[card(newrS`domain)]):
                              rS WITH [`store(r)`seq(i - 1) := nil, `count(subrefindex) := newsubrefcount]`count
                                  (finite_enumeration(rS`domain)(x))) = (LAMBDA (x: below[card(rS`domain)]):
                               rS`count(finite_enumeration(rS`domain)(x))) WITH [(inverse(finite_enumeration(rS`domain))(subrefindex)) := rS`count(subrefindex) - 1]") (("1" (replace -1 :hide? t) (("1" (lemma "sigma_with[below(card(rS`domain))]") (("1" (inst - "(lambda (x: below[card(rS`domain)]):
                                  rS`count(finite_enumeration(rS`domain)(x)))
                                 WITH [(inverse(finite_enumeration(rS`domain))(subrefindex))
                                         := rS`count(subrefindex) - 1]" "(lambda (x: below[card(rS`domain)]):
                                  rS`count(finite_enumeration(rS`domain)(x)))" "rS`count(subrefindex) - 1" "card(rS`domain) - 1" "inverse(finite_enumeration(rS`domain))(subrefindex)" "0") (("1" (ground) (("1" (rewrite "inverse_surjective") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (ground) (("1" (lift-if) (("1" (ground) (("1" (replace -1 :dir RL) (("1" (rewrite "inverse_injective") (("1" (use "finite_enumeration_bij") (("1" (expand "bijective?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "decr_TCC7") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst - "subrefindex") (("2" (assert) (("2" (inst?) (("2" (ground) (("2" (rewrite "inverse_surjective") (("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (assert) nil nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (use "decr_TCC7") (("5" (assert) (("5" (inst?) (("5" (assert) (("5" (inst?) (("5" (assert) (("5" (inst?) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (allcountStore const-decl "nat" refcount nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (allcount const-decl "nat" refcount nil) (sigma_nat application-judgement "nat" sigma "reals/") (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (card_is_0 formula-decl nil finite_sets nil) (O const-decl "T3" function_props nil) (decr_TCC7 subtype-tcc nil refcount nil) (inverse_injective formula-decl nil function_inverse nil) (injective? const-decl "bool" functions nil) (newrS skolem-const-decl "rstate" refcount nil) (rS skolem-const-decl "rstate" refcount nil) (newsubrefcount skolem-const-decl "int" refcount nil) (r skolem-const-decl "(rS`domain)" refcount nil) (i skolem-const-decl "{i: upto(rS`store(r)`length) |
   forall (j: below(rS`store(r)`length)):
     j >= i IMPLIES NOT ref?(rS`store(r)`seq(j))}" refcount nil) (subrefindex skolem-const-decl "(rS`domain)" refcount nil) (T_low type-eq-decl nil sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (OR const-decl "[bool, bool -> bool]" booleans nil) (surjective? const-decl "bool" functions nil) (inverse_surjective formula-decl nil function_inverse nil) (bijective? const-decl "bool" functions nil) (finite_enumeration_bij formula-decl nil finite_enumeration "sigma_set/") (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (integer nonempty-type-from-decl nil integers nil) (sigma_with formula-decl nil sigma "reals/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_enumeration const-decl "[below[card(X)] -> (X)]" finite_enumeration "sigma_set/") (inverse const-decl "D" function_inverse nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC9 0 (decr_TCC9-1 nil 3684597206 ("" (skeep*) (("" (ground) (("1" (case "r = subrefindex") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (skeep*) (("2" (assert) (("2" (typepred "j") (("2" (assert) (("2" (case "r = subrefindex") (("1" (replace*) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil)) nil))("refcount" refcount decr_TCC8 0 (decr_TCC8-1 nil 3684597206 ("" (skeep*) (("" (ground) (("" (case "r = subrefindex") (("1" (grind) nil nil) ("2" (grind) (("2" (typepred "rS`store(r)`seq(i - 1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC7 0 (decr_TCC7-1 nil 3684597206 ("" (skeep*) (("" (ground) (("1" (typepred "rS`count(subrefindex)") (("1" (expand "refcount") (("1" (use "refcountStore_ref") (("1" (ground) (("1" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "rS`count(subrefindex)") (("2" (expand "refcount") (("2" (expand "refcountStore") (("2" (lift-if) (("2" (ground) (("1" (typepred "subref") (("1" (grind) nil nil)) nil) ("2" (expand "o") (("2" (expand "refcountArray") (("2" (case-replace "(LAMBDA (x: below[card(rS`domain)]):
                     count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                           rS`store WITH [(r)`seq(i - 1) := nil]
                               (finite_enumeration(rS`domain)(x)))) = ((LAMBDA (x: below[card(rS`domain)]):
                     count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                           rS`store(finite_enumeration(rS`domain)(x)))) WITH [(inverse(finite_enumeration(rS`domain))(r)) := count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                           rS`store(r)) - 1])") (("1" (hide -1) (("1" (lemma "sigma_with[below(card(rS`domain))]") (("1" (inst - "(lambda (x: below[card(rS`domain)]):
                           count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                                 rS`store(finite_enumeration(rS`domain)(x))))
                          WITH [(inverse(finite_enumeration(rS`domain))(r))
                                  := count(lambda u:
                                             ref?(u) AND refindex(u) = subrefindex,
                                           rS`store(r))
                                      - 1]" "_" "_" "_" "_" "_") (("1" (inst - "(lambda (x: below[card(rS`domain)]):
                             count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                                   rS`store(finite_enumeration(rS`domain)(x))))" "count(lambda u:
                                               ref?(u) AND refindex(u) = subrefindex,
                                             rS`store(r))
                                        - 1" "card(rS`domain) - 1" "(inverse(finite_enumeration(rS`domain))(r))" "0") (("1" (ground) (("1" (replace -1 :hide? t) (("1" (rewrite "inverse_surjective") (("1" (assert) nil nil) ("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (case "inverse(finite_enumeration(rS`domain))(r) = x!1") (("1" (assert) (("1" (replace -1 :dir RL) (("1" (rewrite "inverse_surjective") (("1" (assert) (("1" (rewrite "count_update") (("1" (expand "value?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "injective_inverse") (("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "count_elem[(value?)]") (("2" (ground) (("2" (inst + "i - 1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil) ("3" (use "count_elem[(value?)]") (("3" (ground) (("3" (inst + "i - 1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refcountStore_ref formula-decl nil refcount nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (O const-decl "T3" function_props nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (finite_enumeration const-decl "[below[card(X)] -> (X)]" finite_enumeration "sigma_set/") (inverse const-decl "D" function_inverse nil) (sigma_with formula-decl nil sigma "reals/") (integer nonempty-type-from-decl nil integers nil) (T_low type-eq-decl nil sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (OR const-decl "[bool, bool -> bool]" booleans nil) (finite_enumeration_bij formula-decl nil finite_enumeration "sigma_set/") (bijective? const-decl "bool" functions nil) (inverse_surjective formula-decl nil function_inverse nil) (surjective? const-decl "bool" functions nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (sigma def-decl "real" sigma "reals/") (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count_elem formula-decl nil finseq_theorems nil) (count_update formula-decl nil finseq_theorems nil) (injective_inverse formula-decl nil function_inverse nil) (refcountArray const-decl "nat" refcount nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (refcountExpr const-decl "nat" refcount nil) (count const-decl "nat" finseq_theorems nil) (refcountStack const-decl "nat" refcount nil) (sigma_nat application-judgement "nat" sigma "reals/") (refcountStore const-decl "nat" refcount nil)) nil))("refcount" refcount decr_TCC6 0 (decr_TCC6-1 nil 3684597206 ("" (termination-tcc) nil nil) ((value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil)) nil))("refcount" refcount decr_TCC5 0 (decr_TCC5-1 nil 3684597206 ("" (skeep*) (("" (typepred "subref") (("" (grind) nil nil)) nil)) nil) ((rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (= const-decl "[T, T -> boolean]" equalities nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (below type-eq-decl nil nat_types nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC4 0 (decr_TCC4-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC3 0 (decr_TCC3-1 nil 3684597206 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC2 0 (decr_TCC2-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((below type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (= const-decl "[T, T -> boolean]" equalities nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("refcount" refcount decr_TCC1 0 (decr_TCC1-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (= const-decl "[T, T -> boolean]" equalities nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("IL" IL vars_TCC2 0 (vars_TCC2-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess markvar_TCC2 0 (markvar_TCC2-1 nil 3683170974 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess markvars_markX_TCC2 0 (markvars_markX_TCC2-1 nil 3693198804 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess markvars_markX_TCC1 0 (markvars_markX_TCC1-1 nil 3693198804 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_idem_subset 0 (mark_idem_subset-1 nil 3693496691 ("" (induct "A") (("1" (skeep*) (("1" (expand "mark") (("1" (expand "markv") (("1" (grind) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil)) nil) nil shostak))("refreduction" refreduction lookupReduce_TCC26 0 (lookupReduce_TCC26-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil nil))("refreduction" refreduction lookupReduce_TCC25 0 (lookupReduce_TCC25-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil nil))("refreduction" refreduction lookupReduce_TCC24 0 (lookupReduce_TCC24-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil nil))