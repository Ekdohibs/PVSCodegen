(rreduction
 (refcountExpr_popit 0
  (refcountExpr_popit-1 nil 3683904062
   ("" (skeep)
    (("" (expand "refcountExpr") (("" (rewrite "popit_refs") nil nil))
      nil))
    nil)
   ((refcountExpr const-decl "nat" rreduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (popit_refs formula-decl nil reduction nil))
   shostak))
 (noDanglingRefs?_TCC1 0
  (noDanglingRefs?_TCC1-1 nil 3698761342 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (noDanglingRefs?_TCC2 0
  (noDanglingRefs?_TCC2-1 nil 3699126721 ("" (subtype-tcc) nil nil) nil
   nil))
 (to_topstate_TCC1 0
  (to_topstate_TCC1-1 nil 3699126721
   ("" (subtype-tcc) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil))
   nil))
 (to_topstate_TCC2 0
  (to_topstate_TCC2-1 nil 3699126721
   ("" (skeep*)
    (("" (ground)
      (("1" (skeep*)
        (("1" (typepred "rS`context")
          (("1" (rewrite refs_fill)
            (("1" (typepred "rS`redex") (("1" (grind) nil nil)) nil)
             ("2" (typepred "rS`redex")
              (("2" (use contextPurefill) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep*)
        (("2" (rewrite vars_decompose)
          (("2" (typepred "rS`redex")
            (("2" (rewrite popdepth_fill) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil)
       ("4" (rewrite popdepth_fill)
        (("4" (typepred "rS`redex") (("4" (grind) nil nil)) nil)) nil)
       ("5" (rewrite contextPurefill) nil nil)
       ("6" (rewrite mark_fill)
        (("6" (expand vars)
          (("6" (expand bumpn)
            (("6" (expand union)
              (("6" (expand member)
                (("6" (expand emptyset)
                  (("6" (typepred "rS`context")
                    (("6" (expand emptyset)
                      (("6" (rewrite -2)
                        (("6" (typepred "rS`redex")
                          (("6" (expand vars)
                            (("6" (postpone) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (to_topstate_TCC3 0
  (to_topstate_TCC3-1 nil 3699126721 ("" (subtype-tcc) nil nil) nil
   nil))
 (to_topstate_TCC4 0
  (to_topstate_TCC4-1 nil 3699126721 ("" (subtype-tcc) nil nil) nil
   nil))
 (refcountStore_ref 0
  (refcountStore_ref-1 nil 3685183232
   ("" (skeep :preds? t)
    (("" (expand "refcountStore")
      (("" (expand allcount)
        (("" (rewrite sigma_sigma_set)
          (("" (use "sigma_set[nat].sigma_gt_0")
            (("1" (ground)
              (("1" (grind) nil nil)
               ("2" (delete 2)
                (("2" (inst 1 "r")
                  (("2" (expand "refcountArray")
                    (("2"
                      (use "finseq_theorems[(IL.value?)].count_elem")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (use "finite_set_theorems.sigma_sigma_set_TCC1") nil
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" rreduction nil)
    (sigma_sigma_set formula-decl nil finite_set_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (refcountArray const-decl "nat" rreduction nil)
    (sigma_sigma_set_TCC1 subtype-tcc nil finite_set_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sigma const-decl "real" sigma_set "sigma_set/")
    (sigma const-decl "real" sigma_countable "sigma_set/")
    (limit const-decl "real" convergence_sequences "analysis/")
    (convergence const-decl "bool" convergence_sequences "analysis/")
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (sigma def-decl "real" sigma "reals/")
    (O const-decl "T3" function_props nil)
    (denumerable_enumeration const-decl "[nat -> (X)]"
     denumerable_enumeration "sigma_set/")
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (nonzero_elts const-decl "set[T]" convergence_set "sigma_set/")
    (/= const-decl "boolean" notequal nil)
    (count const-decl "nat" finseq_theorems nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (convergent? const-decl "bool" convergence_set "sigma_set/")
    (sigma_gt_0 formula-decl nil sigma_set "sigma_set/")
    (allcount const-decl "nat" rreduction nil))
   shostak))
 (refcountArray_update_TCC1 0
  (refcountArray_update_TCC1-1 nil 3692674266
   ("" (subtype-tcc) nil nil) ((value? const-decl "bool" IL nil)) nil))
 (refcountArray_update 0
  (refcountArray_update-1 nil 3692674266
   ("" (skeep :preds? t)
    (("" (expand "refcountArray")
      (("" (use "finseq_theorems[(IL.value?)].count_update")
        (("1" (rewrite -1) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((refcountArray const-decl "nat" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (count_update formula-decl nil finseq_theorems nil))
   shostak))
 (store_update_TCC1 0
  (store_update_TCC1-1 nil 3692717400 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil))
   nil))
 (store_update_TCC2 0
  (store_update_TCC2-1 nil 3692717400 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil))
 (store_update 0
  (store_update-1 nil 3692717400
   ("" (skeep)
    (("" (case "r = k") (("1" (assert) nil nil) ("2" (assert) nil nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (refcountStore_update 0
  (refcountStore_update-1 nil 3692670917
   ("" (skeep)
    (("" (expand "refcountStore")
      (("" (expand allcount)
        (("" (lemma sigma_with)
          ((""
            (inst -1 "rS`domain" _ _ "r"
             "refcountArray(rS`store WITH [(r)(seq)(j) := nil](r))(i)")
            (("1"
              (inst -1 "lambda (j_1: nat):
               IF rS`domain(j_1) THEN refcountArray(rS`store(j_1))(i)
               ELSE 0
               ENDIF" "lambda (j_1: nat):
              IF rS`domain(j_1)
                THEN refcountArray(rS`store WITH [(r)(seq)(j) := nil](j_1))
                                  (i)
              ELSE 0
              ENDIF")
              (("1" (ground)
                (("1" (rewrite refcountArray_update)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (delete 2)
                  (("2" (apply-extensionality)
                    (("1" (delete 2)
                      (("1" (lift-if)
                        (("1" (ground)
                          (("1"
                            (case "(# length := rS`store(x!1)`length,
                       seq
                         := LAMBDA (x1: below[rS`store(x!1)`length]):
                              IF x1 = j THEN nil
                              ELSE rS`store(x!1)`seq(x1)
                              ENDIF #) = rS`store(r) WITH [(seq)(j) := nil]")
                            (("1" (rewrite -1) nil nil)
                             ("2" (delete 2)
                              (("2"
                                (grind)
                                (("2" (grind-with-ext) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil) ("3" (grind) nil nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" rreduction nil)
    (sigma_with formula-decl nil finite_set_theorems nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountArray_update formula-decl nil rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (count const-decl "nat" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (refcountArray const-decl "nat" rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (allcount const-decl "nat" rreduction nil))
   shostak))
 (refcount_stack_outside_domain 0
  (refcount_stack_outside_domain-1 nil 3699029139
   ("" (skeep*)
    (("" (expand refcountStack)
      (("" (rewrite count_none_zero)
        (("" (skeep*)
          (("" (typepred "rS`stack") (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((refcountStack const-decl "nat" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (count const-decl "nat" finseq_theorems nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (value? const-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (count_none_zero formula-decl nil finseq_theorems nil))
   shostak))
 (refcount_new_TCC1 0
  (refcount_new_TCC1-1 nil 3699027941 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil))
   nil))
 (refcount_new_TCC2 0
  (refcount_new_TCC2-1 nil 3699027941 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil))
   nil))
 (refcount_new 0
  (refcount_new-1 nil 3699027941
   ("" (skeep*)
    (("" (expand refcountStore)
      (("" (replace -1)
        (("" (expand allcount)
          (("" (lemma sigma_add)
            (("" (inst?)
              (("1" (inst -1 i)
                (("1" (ground)
                  (("1" (rewrite -1)
                    (("1" (expand add 2 1)
                      (("1" (rewrite remove_add_member)
                        (("1" (rewrite sigma_zero)
                          (("1" (skeep*)
                            (("1" (lift-if)
                              (("1"
                                (ground)
                                (("1"
                                  (rewrite -3 :dir RL)
                                  (("1"
                                    (expand refcountArray 1)
                                    (("1"
                                      (rewrite count_none_zero)
                                      (("1"
                                        (skeep*)
                                        (("1"
                                          (typepred
                                           "store(x)`seq(i_1)")
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (refcountArray const-decl "nat" rreduction nil)
    (domainValue? const-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (remove_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (sigma_zero formula-decl nil finite_set_theorems nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (count_none_zero formula-decl nil finseq_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (empty? const-decl "bool" sets nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (member const-decl "bool" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (remove_add_member formula-decl nil sets_lemmas nil)
    (choose const-decl "(p)" sets nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (sigma_add formula-decl nil finite_set_theorems nil))
   shostak))
 (allcountStore_update_TCC1 0
  (allcountStore_update_TCC1-1 nil 3698768688
   ("" (skeep*)
    (("" (expand refcount)
      (("" (rewrite refcountStore_update)
        (("" (typepred "rS`count(i)")
          (("" (rewrite -1)
            (("" (expand refcount)
              (("" (lemma "refcountStore_ref") (("" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcount const-decl "nat" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (refcountStore_update formula-decl nil rreduction nil))
   nil))
 (allcountStore_update 0
  (allcountStore_update-1 nil 3698768688
   ("" (skeep*)
    (("" (expand allcountStore)
      (("" (expand allcount)
        (("" (lemma "sigma_with")
          ((""
            (inst -1 "rS`domain"
             "lambda j: IF rS`domain(j) THEN rS`count(j) ELSE 0 ENDIF"
             "lambda j:
              IF rS`domain(j)
                THEN rS`count WITH [(i) := rS`count(i) - 1](j)
              ELSE 0
              ENDIF" "i" "rS`count(i) - 1")
            (("1" (ground)
              (("1" (delete 2) (("1" (postpone) nil nil)) nil)
               ("2" (postpone) nil nil))
              nil)
             ("2" (postpone) nil nil) ("3" (postpone) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (allcountStore_decrease_TCC1 0
  (allcountStore_decrease_TCC1-1 nil 3692982211
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil))
 (allcountStore_decrease_TCC2 0
  (allcountStore_decrease_TCC2-1 nil 3692982211
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil))
 (allcountStore_decrease 0
  (allcountStore_decrease-1 nil 3692982211
   ("" (skeep* :preds? t)
    (("" (expand allcountStore)
      (("" (expand allcount)
        (("" (rewrite sigma_sigma_set)
          (("" (rewrite sigma_sigma_set)
            (("" (lemma "sigma_set[nat].sigma_lt")
              (("" (inst -1 "rS`domain" _ _)
                ((""
                  (inst -1
                   "lambda j: IF rS1`domain(j) THEN rS1`count(j) ELSE 0 ENDIF"
                   "lambda j: IF rS`domain(j) THEN rS`count(j) ELSE 0 ENDIF")
                  (("1" (ground)
                    (("1" (delete 2)
                      (("1" (skeep)
                        (("1" (inst -3 "t") (("1" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (inst 1 s) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (use sigma_sigma_set_TCC1) nil nil)
                   ("3" (use sigma_sigma_set_TCC1) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((allcountStore const-decl "nat" rreduction nil)
    (sigma_sigma_set formula-decl nil finite_set_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma_lt formula-decl nil sigma_set "sigma_set/")
    (convergent? const-decl "bool" convergence_set "sigma_set/")
    (sigma const-decl "real" sigma_set "sigma_set/")
    (sigma const-decl "real" sigma_countable "sigma_set/")
    (limit const-decl "real" convergence_sequences "analysis/")
    (convergence const-decl "bool" convergence_sequences "analysis/")
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (sigma def-decl "real" sigma "reals/")
    (O const-decl "T3" function_props nil)
    (denumerable_enumeration const-decl "[nat -> (X)]"
     denumerable_enumeration "sigma_set/")
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (nonzero_elts const-decl "set[T]" convergence_set "sigma_set/")
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_sigma_set_TCC1 subtype-tcc nil finite_set_theorems nil)
    (allcount const-decl "nat" rreduction nil))
   shostak))
 (decref_TCC1 0
  (decref_TCC1-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil))
   nil))
 (decref_TCC2 0
  (decref_TCC2-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (allcount const-decl "nat" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil))
   nil))
 (decref_TCC3 0
  (decref_TCC3-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC4 0
  (decref_TCC4-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC5 0
  (decref_TCC5-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil))
   nil))
 (decref_TCC6 0
  (decref_TCC6-1 nil 3692915538
   ("" (skeep*)
    (("" (expand "refcount")
      (("" (rewrite "refcountStore_update")
        (("1" (ground)
          (("1" (typepred "rS`count(subrefindex)")
            (("1" (replace -1 :hide? t)
              (("1" (expand "refcount")
                (("1" (use "refcountStore_ref")
                  (("1" (ground)
                    (("1" (case "ref(refindex(subref)) = subref")
                      (("1" (assert) nil nil)
                       ("2" (apply-extensionality :hide? t) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (typepred "rS`count(subrefindex)")
            (("2" (expand "refcount") (("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (case "ref(refindex(subref)) = subref")
          (("1" (assert) nil nil)
           ("2" (apply-extensionality :hide? t) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcount const-decl "nat" rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (decref_TCC7 0
  (decref_TCC7-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC8 0
  (decref_TCC8-1 nil 3692915538
   ("" (skeep*)
    (("" (replace -6 :hide? t)
      (("" (assert)
        (("" (case "r = subrefindex")
          (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC9 0
  (decref_TCC9-1 nil 3692915538
   ("" (skeep*)
    (("" (lemma "allcountStore_decrease")
      (("" (inst?) (("" (ground) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((allcountStore_decrease formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (allcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (decref_TCC10 0
  (decref_TCC10-1 nil 3692915538
   ("" (skeep*)
    (("" (rewrite -6)
      (("" (use allcountStore_update)
        (("1" (ground)
          (("1" (grind) nil nil) ("2" (grind-with-ext) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (< def-decl "bool" ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (allcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (allcountStore_update formula-decl nil rreduction nil))
   nil))
 (decref_TCC11 0
  (decref_TCC11-1 nil 3692915538
   ("" (skeep*) (("" (lift-if) (("" (ground) nil nil)) nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC12 0
  (decref_TCC12-1 nil 3692915538
   ("" (skeep*)
    (("" (rewrite "lex2_lt")
      (("" (lift-if)
        (("" (ground)
          ((""
            (typepred "v(rS
             WITH [`store(r)`seq(i - 1) := nil,
                   `count(refindex(subref))
                     := rS`count(refindex(subref)) - 1],
           refindex(subref), rS`store(refindex(subref))`length)")
            (("1" (hide -2 -3)
              (("1" (assert)
                (("1" (lemma "allcountStore_decrease")
                  (("1"
                    (inst - "rS" "rS
                       WITH [`store(r)`seq(i - 1) := nil,
                             `count(refindex(subref))
                               := rS`count(refindex(subref)) - 1]"
                     "refindex(subref)")
                    (("1" (ground) nil nil)
                     ("2" (hide -1)
                      (("2" (use "decref_TCC6")
                        (("2" (assert)
                          (("2" (inst?)
                            (("2" (assert)
                              (("2"
                                (inst?)
                                (("2"
                                  (assert)
                                  (("2" (inst?) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (hide -1) (("3" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (case "r = refindex(subref)")
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
              nil)
             ("3" (use "decref_TCC6")
              (("3" (assert)
                (("3" (inst?)
                  (("3" (assert)
                    (("3" (inst?)
                      (("3" (assert) (("3" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC13 0
  (decref_TCC13-1 nil 3692915538
   ("" (skeep*)
    (("" (ground)
      (("" (lift-if)
        (("" (ground)
          ((""
            (typepred "v(rS
                           WITH [`store(r)`seq(i - 1) := nil,
                                 `count(refindex(subref))
                                   := rS`count(refindex(subref)) - 1],
                         refindex(subref), rS`store(refindex(subref))`length)")
            (("1" (hide -2 -3)
              (("1" (lemma "allcountStore_decrease")
                (("1"
                  (inst - "rS" "rS
                                   WITH [`store(r)`seq(i - 1) := nil,
                                         `count(refindex(subref))
                                           := rS`count(refindex(subref)) - 1]"
                   "refindex(subref)")
                  (("1" (ground)
                    (("1" (typepred i)
                      (("1"
                        (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
                        (("1" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (use "decref_TCC6")
                    (("2" (assert)
                      (("2" (inst?)
                        (("2" (assert)
                          (("2" (inst?)
                            (("2" (assert) (("2" (inst?) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (hide -1) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (case "r = refindex(subref)")
              (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
             ("3" (use "decref_TCC6")
              (("3" (assert)
                (("3" (inst?)
                  (("3" (assert)
                    (("3" (inst?)
                      (("3" (assert)
                        (("3" (inst?)
                          (("3" (expand noDanglingRefs?)
                            (("3" (typepred rS) (("3" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (expand refcount)
              (("4" (rewrite refcountStore_update)
                (("1" (typepred "rS`count(refindex(subref))")
                  (("1" (rewrite -1)
                    (("1" (expand refcount)
                      (("1" (use refcountStore_ref)
                        (("1" (ground)
                          (("1" (hide-all-but (1 -4 -1))
                            (("1" (rewrite -2)
                              (("1" (grind-with-ext) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide-all-but (1 -1 -4))
                  (("2" (grind-with-ext) nil nil)) nil))
                nil))
              nil)
             ("5" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref_TCC6 subtype-tcc nil rreduction nil)
    (allcountStore_decrease formula-decl nil rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil))
   nil))
 (decref_TCC14 0
  (decref_TCC14-1 nil 3692915538
   ("" (skeep*)
    (("" (lift-if)
      (("" (prop)
        (("1"
          (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
          (("1" (delete -2 -3 -4)
            (("1" (replace -3 -1 :dir RL)
              (("1" (lemma allcountStore_decrease)
                (("1"
                  (inst -1 "rS" "rS
                       WITH [`store(r)`seq(i - 1) := nil,
                             `count(refindex(subref))
                               := rS`count(refindex(subref)) - 1]"
                   "refindex(subref)")
                  (("1" (ground) (("1" (grind) nil nil)) nil)
                   ("2" (expand refcount)
                    (("2" (rewrite refcountStore_update)
                      (("1" (typepred "rS`count(refindex(subref))")
                        (("1" (rewrite -1)
                          (("1" (expand refcount)
                            (("1" (lemma refcountStore_ref)
                              (("1"
                                (delete -4 3)
                                (("1"
                                  (delete -2)
                                  (("1"
                                    (inst
                                     -1
                                     "rS"
                                     "r"
                                     "refindex(subref)"
                                     "i - 1")
                                    (("1"
                                      (grind)
                                      (("1"
                                        (delete 3)
                                        (("1"
                                          (grind)
                                          (("1"
                                            (grind-with-ext)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but (1 -2 -5))
                        (("2" (grind-with-ext) nil nil)) nil))
                      nil))
                    nil)
                   ("3" (grind) nil nil) ("4" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil)
           ("3" (typepred rS) (("3" (grind) nil nil)) nil)
           ("4" (expand refcount)
            (("4" (rewrite refcountStore_update)
              (("1" (typepred "rS`count(refindex(subref))")
                (("1" (rewrite -1)
                  (("1" (expand refcount)
                    (("1" (lemma refcountStore_ref)
                      (("1"
                        (inst -1 "rS" "r" "refindex(subref)" "i - 1")
                        (("1" (delete -3)
                          (("1" (delete 3)
                            (("1" (grind)
                              (("1"
                                (delete 3)
                                (("1" (grind-with-ext) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind-with-ext) nil nil))
              nil))
            nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (allcountStore_decrease formula-decl nil rreduction nil))
   nil))
 (decref_TCC15 0
  (decref_TCC15-1 nil 3692972887
   ("" (skeep*)
    (("" (ground)
      (("1" (lift-if)
        (("1" (ground)
          (("1"
            (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
            (("1" (replace -6 :dir RL)
              (("1" (case "allcountStore(newrS) <= allcountStore(rS)")
                (("1" (typepred "v(newrS, r, i - 1)")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (use allcountStore_update)
                  (("2" (grind-with-ext) nil nil)) nil))
                nil))
              nil)
             ("2" (grind) nil nil)
             ("3" (typepred rS) (("3" (grind) nil nil)) nil)
             ("4" (use allcountStore_update_TCC1)
              (("4" (grind-with-ext) nil nil)) nil)
             ("5" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (lift-if) (("2" (ground) nil nil)) nil)
       ("3" (lift-if)
        (("3" (skeep*)
          (("3" (split -3)
            (("1" (flatten)
              (("1"
                (name-replace "newrS2" "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
                (("1" (typepred newrS2)
                  (("1" (inst -3 s)
                    (("1" (typepred "v(newrS, r, i - 1)")
                      (("1" (inst -3 s)
                        (("1" (hide (-8 -5 -4 -2 -1))
                          (("1" (flatten)
                            (("1" (rewrite -9)
                              (("1"
                                (rewrite -1)
                                (("1"
                                  (rewrite -4)
                                  (("1"
                                    (split 1)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (hide (-2 -3 -5))
                                      (("2"
                                        (hide -4)
                                        (("2"
                                          (hide (-3 -4))
                                          (("2"
                                            (lift-if)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (delete 2)
                          (("2" (hide-all-but (1 -5 -9))
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (rewrite -6)
                        (("2" (delete 2)
                          (("2" (use allcountStore_update)
                            (("2" (delete -4)
                              (("2" (grind-with-ext) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("3" (rewrite -6)
                        (("3" (delete -1 -2 -3)
                          (("3" (typepred newrS2)
                            (("3" (inst -3 r) (("3" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (grind) nil nil)
                       ("5" (rewrite -6) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil)
                 ("3" (typepred rS) (("3" (grind) nil nil)) nil)
                 ("4" (use allcountStore_update_TCC1)
                  (("4" (grind-with-ext) nil nil)) nil)
                 ("5" (grind) nil nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (replace -1)
                (("2" (typepred "v(rS, r, i - 1)")
                  (("1" (ground)
                    (("1" (grind) nil nil)
                     ("2" (inst -3 s) (("2" (grind) nil nil)) nil)
                     ("3" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (allcountStore_update_TCC1 subtype-tcc nil rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (allcountStore_update formula-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (decref_TCC16 0
  (decref_TCC16-1 nil 3698762473 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC17 0
  (decref_TCC17-1 nil 3698762473 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (allcount const-decl "nat" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil))
   nil))
 (mark_letApply 0
  (mark_letApply-2 "" 3698756834
   ("" (induct "L")
    (("1" (skeep*)
      (("1" (simplify)
        (("1" (expand letApply)
          (("1" (simplify)
            (("1" (expand length) (("1" (postpone) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep*)
      (("2" (expand length 1)
        (("2" (expand letApply 1)
          (("2" (expand length -2)
            (("2" (lift-if)
              (("2" (prop)
                (("1" (grind) nil nil)
                 ("2" (delete 1)
                  (("2" (expand mark 1 1)
                    (("2" (simplify)
                      (("2" (assert)
                        (("2" (apply-extensionality)
                          (("1" (delete 2)
                            (("1" (expand markvars 1)
                              (("1"
                                (expand mark 1 1)
                                (("1"
                                  (expand markv 1 1)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (lift-if)
                                      (("1"
                                        (lift-if)
                                        (("1"
                                          (expand markvar)
                                          (("1"
                                            (expand unmarkvar)
                                            (("1"
                                              (ground)
                                              (("1"
                                                (hide-all-but 1)
                                                (("1"
                                                  (grind)
                                                  (("1"
                                                    (typepred
                                                     cons1_var)
                                                    (("1"
                                                      (grind)
                                                      (("1"
                                                        (postpone)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide-all-but 1)
                                                (("2"
                                                  (postpone)
                                                  nil
                                                  nil))
                                                nil)
                                               ("3"
                                                (delete 3)
                                                (("3"
                                                  (expand union -1)
                                                  (("3"
                                                    (ground)
                                                    (("1"
                                                      (postpone)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (postpone)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("4" (postpone) nil nil)
                                               ("5" (postpone) nil nil)
                                               ("6"
                                                (postpone)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (postpone) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (mark_letApply-1 nil 3693496107
   ("" (induct "L")
    (("1" (grind)
      (("1" (lemma "mark_idem")
        (("1" (inst?) (("1" (postpone) nil nil)) nil)) nil)
       ("2" (postpone) nil nil) ("3" (postpone) nil nil))
      nil)
     ("2" (postpone) nil nil))
    nil)
   nil shostak))
 (check_marked_TCC1 0
  (check_marked_TCC1-1 nil 3698692883 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil))
 (check_marked_TCC2 0
  (check_marked_TCC2-1 nil 3698692883 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (check_marked_TCC3 0
  (check_marked_TCC3-1 nil 3698692883 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (value? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (check_marked_TCC4 0
  (check_marked_TCC4-1 nil 3698692883
   ("" (skeep* :preds? t)
    (("" (ground)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (typepred "rS`redex") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (check_marked_TCC5 0
  (check_marked_TCC5-1 nil 3698692883
   ("" (skeep*)
    (("" (expand refcount)
      (("" (typepred "rS`count(refindex(vx))")
        (("1" (rewrite -1)
          (("1" (expand refcount)
            (("1" (split)
              (("1" (expand refcountStack)
                (("1" (use "finseq_theorems[(IL.value?)].count_elem")
                  (("1" (ground)
                    (("1" (inst 1 "rS`stack`length - 1 - index(x)")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand refcountStack)
                (("2"
                  (rewrite "finseq_theorems[(IL.value?)].count_update")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (delete 2)
          (("2" (typepred "rS`stack") (("2" (grind) nil nil)) nil))
          nil)
         ("3" (propax) nil nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcount const-decl "nat" rreduction nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "(value?)" IL nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountStack const-decl "nat" rreduction nil)
    (count_update formula-decl nil finseq_theorems nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil))
   nil))
 (check_marked_TCC6 0
  (check_marked_TCC6-1 nil 3698692883
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred "rS`count(refindex(vx))")
        (("1" (rewrite -1)
          (("1" (expand refcount)
            (("1" (expand refcountStack)
              (("1" (lemma "finseq_theorems[(IL.value?)].count_elem")
                (("1" (inst?)
                  (("1" (inst?)
                    (("1" (ground)
                      (("1" (expand get)
                        (("1" (inst 1 "stack`length - 1 - index(x)")
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "rS`count(refindex(vx))")
        (("2" (rewrite -1)
          (("2" (expand refcount)
            (("2" (expand refcountStack)
              (("2" (use "finseq_theorems[(IL.value?)].count_update")
                (("1" (rewrite -1) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (check_marked_TCC7 0
  (check_marked_TCC7-1 nil 3698762473 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (release_marked_TCC1 0
  (release_marked_TCC1-1 nil 3699016249
   ("" (skeep*)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (grind)
        (("2" (grind)
          (("2" (typepred "rS`redex")
            (("2" (inst -2 "i!1") (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (expand mark)
        (("5" (typepred "rS`redex")
          (("5" (rewrite -5)
            (("5" (decompose-equality)
              (("5" (typepred "x")
                (("5" (ground)
                  (("5" (expand markv)
                    (("5" (expand union)
                      (("5" (grind-with-ext) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refs def-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (union const-decl "set" sets nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (release_marked_TCC2 0
  (release_marked_TCC2-1 nil 3699016249
   ("" (skeep*)
    (("" (typepred "rS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (expand refs 1 2) (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refcountExpr const-decl "nat" rreduction nil))
   nil))
 (applyReduce_TCC1 0
  (applyReduce_TCC1-1 nil 3676345135 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (injective? const-decl "bool" functions nil))
   nil))
 (applyReduce_TCC2 0
  (applyReduce_TCC2-1 nil 3676345135
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (applyReduce_TCC3 0
  (applyReduce_TCC3-1 nil 3676345135
   ("" (skeep*)
    ((""
      (lemma "reduction.applyReduce_TCC3" :subst
       ("gS" "rstate2estate(grS)"))
      (("1" (inst?)
        (("1" (inst - "stack")
          (("1" (split -)
            (("1" (inst - "store")
              (("1" (split -)
                (("1" (inst - "expr")
                  (("1" (split -)
                    (("1" (inst - "fun")
                      (("1" (split -)
                        (("1" (inst - "args")
                          (("1" (split -)
                            (("1" (inst - "lenargs")
                              (("1"
                                (split -)
                                (("1"
                                  (inst - "def")
                                  (("1"
                                    (split -)
                                    (("1"
                                      (inst - "arity")
                                      (("1"
                                        (split -)
                                        (("1"
                                          (inst - "body")
                                          (("1"
                                            (split -)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (split)
                                                (("1"
                                                  (skeep)
                                                  (("1"
                                                    (inst - "i")
                                                    (("1"
                                                      (ground)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         "pure_refs"
                                                         -)
                                                        (("2"
                                                          (rewrite
                                                           "pure_letApply")
                                                          (("2"
                                                            (typepred
                                                             "body")
                                                            (("2"
                                                              (hide 2)
                                                              (("2"
                                                                (rewrite
                                                                 "pure_mark")
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (skeep)
                                                  (("2"
                                                    (inst -3 "i")
                                                    (("2"
                                                      (ground)
                                                      (("1"
                                                        (rewrite
                                                         "popdepth_letApply")
                                                        (("1"
                                                          (lift-if)
                                                          (("1"
                                                            (ground)
                                                            (("1"
                                                              (rewrite
                                                               "popdepth_letApply")
                                                              (("1"
                                                                (rewrite
                                                                 "popDepth_mark")
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (rewrite
                                                               "popdepth_letApply")
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         "vars_letApply")
                                                        (("2"
                                                          (rewrite
                                                           "vars_letApply")
                                                          (("2"
                                                            (rewrite
                                                             "vars_mark")
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (rewrite
                                                   "popdepth_letApply")
                                                  (("3"
                                                    (rewrite
                                                     "popdepth_letApply")
                                                    (("3"
                                                      (rewrite
                                                       "popDepth_mark")
                                                      (("3"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("4"
                                                  (rewrite
                                                   "pure_contextPure")
                                                  (("4"
                                                    (rewrite
                                                     "pure_letApply")
                                                    (("4"
                                                      (rewrite
                                                       "pure_mark")
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("5"
                                                  (use "mark_letApply")
                                                  (("5"
                                                    (ground)
                                                    (("1"
                                                      (typepred
                                                       "grS`redex")
                                                      (("1"
                                                        (typepred
                                                         "grS")
                                                        (("1"
                                                          (expand
                                                           "applyRedex?")
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (expand
                                                               "mark"
                                                               -6)
                                                              (("1"
                                                                (decompose-equality
                                                                 -6)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (typepred
                                                       "D`seq(fun)`body")
                                                      (("2"
                                                        (lazy-grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("6"
                                                  (skeep)
                                                  (("6"
                                                    (typepred "expr")
                                                    (("6"
                                                      (rewrite
                                                       "vars_letApply")
                                                      (("6"
                                                        (inst -6 "i")
                                                        (("6"
                                                          (ground)
                                                          (("6"
                                                            (typepred
                                                             "grS")
                                                            (("6"
                                                              (expand
                                                               "applyRedex?")
                                                              (("6"
                                                                (assert)
                                                                (("6"
                                                                  (rewrite
                                                                   "vars")
                                                                  (("6"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (propax) nil nil)
                                             ("3" (propax) nil nil))
                                            nil))
                                          nil)
                                         ("2" (propax) nil nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil)
                                 ("2" (propax) nil nil)
                                 ("3" (propax) nil nil))
                                nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (hide 2) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (typepred "expr")
                      (("2" (lazy-grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (hide 2) (("2" (grind) nil nil)) nil))
                nil)
               ("2" (hide 2) (("2" (grind) nil nil)) nil))
              nil)
             ("2" (hide 2) (("2" (grind) nil nil)) nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (grind)
          (("2" (typepred "grS") (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (applyRedex? const-decl "bool" IL nil)
    (goodstate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (applyReduce_TCC3 subtype-tcc nil reduction nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (mark_letApply formula-decl nil rreduction nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (popDepth_mark formula-decl nil preprocess nil)
    (popdepth_letApply formula-decl nil reduction nil)
    (vars_mark formula-decl nil preprocess nil)
    (vars_letApply formula-decl nil reduction nil)
    (pure_letApply rec-application-judgement "(pure?)" reduction nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure_letApply recursive-judgement-axiom nil reduction nil)
    (pure_mark formula-decl nil preprocess nil)
    (pure_refs formula-decl nil IL nil)
    (length def-decl "nat" list_props nil)
    (letApply def-decl "IExpression" reduction nil)
    (emptyset const-decl "set" sets nil) (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil))
   nil))
 (applyReduce_TCC4 0
  (applyReduce_TCC4-1 nil 3676345135
   ("" (skeep*)
    (("" (expand "refcount")
      (("" (expand "refcountExpr")
        (("" (use "pure_letApply")
          (("1" (rewrite "pure_refs")
            (("1" (typepred "grS`count(x1)")
              (("1" (expand "refcount")
                (("1" (expand "refcountExpr")
                  (("1" (typepred "grS")
                    (("1" (forward-chain "pureApplyRedex")
                      (("1" (rewrite "pure_refs") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil)
           ("3" (hide 2) (("3" (rewrite "pure_mark") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (pure_letApply recursive-judgement-axiom nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (length def-decl "nat" list_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil rreduction nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (pureApplyRedex formula-decl nil IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (letApply def-decl "IExpression" reduction nil)
    (pure_refs formula-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure_mark formula-decl nil preprocess nil)
    (refcountExpr const-decl "nat" rreduction nil))
   nil))
 (ifReduce_TCC1 0
  (ifReduce_TCC1-1 nil 3683858380 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/"))
   nil))
 (ifReduce_TCC2 0
  (ifReduce_TCC2-1 nil 3683858380
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred "grS`redex")
        (("1" (inst -2 "index(condition)")
          (("1" (ground)
            (("1" (typepred "grS")
              (("1" (expand pureIftRedex?)
                (("1" (expand iftRedex?) (("1" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "grS`redex")
        (("2" (case "grS`redex = ift(condition, thenexpr, elseexpr)")
          (("1" (rewrite -1)
            (("1" (expand mark -5)
              (("1" (expand markv -5)
                (("1" (expand union -5)
                  (("1" (expand member -5)
                    (("1" (expand member -6)
                      (("1" (simplify)
                        (("1" (rewrite -6 -5)
                          (("1" (hide-all-but (-5 -6))
                            (("1" (decompose-equality)
                              (("1"
                                (replace -1 :dir RL)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind-with-ext) nil nil))
          nil))
        nil)
       ("3" (lift-if)
        (("3" (typepred "grS`redex")
          (("3"
            (case-replace
             "grS`redex = ift(condition, thenexpr, elseexpr)")
            (("1" (expand mark -6)
              (("1" (decompose-equality -6)
                (("1" (replace -1 -10 :dir RL)
                  (("1" (hide-all-but (-9 -10)) (("1" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind-with-ext) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (iftRedex? const-decl "bool" IL nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (release_set def-decl "IExpression" preprocess nil)
    (difference const-decl "set" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (empty? const-decl "bool" sets nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil))
   nil))
 (ifReduce_TCC3 0
  (ifReduce_TCC3-1 nil 3683858380
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred "grS")
        (("" (inst -3 "index(condition)")
          (("" (expand vars) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (iftRedex? const-decl "bool" IL nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (empty? const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil))
   nil))
 (ifReduce_TCC4 0
  (ifReduce_TCC4-1 nil 3683858380
   ("" (skeep*)
    (("" (typepred "grS")
      (("" (typepred "grS`redex")
        (("" (ground)
          (("1" (hide-all-but (1 -1 -6 -9 -13)) (("1" (grind) nil nil))
            nil)
           ("2" (hide-all-but (1 -2 -6 0 -13))
            (("2" (skeep)
              (("2" (inst -2 i)
                (("2" (rewrite purePopDepth)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("4" (hide-all-but (1 -6 -9 -13))
            (("4" (rewrite pure_contextPure) (("4" (grind) nil nil))
              nil))
            nil)
           ("5" (expand mark -5)
            (("5" (lift-if)
              (("5" (expand pureIftRedex?)
                (("5" (flatten)
                  (("5" (expand iftRedex?)
                    (("5" (ground)
                      (("5" (replace -16)
                        (("5" (replace -16 :dir RL)
                          (("5" (replace -12)
                            (("5" (replace -16 :dir RL)
                              (("5"
                                (replace -14 :dir RL)
                                (("5"
                                  (case
                                   "empty?(difference(vars(thenexpr),
                                 union(vars(elseexpr), grS`contextvars)))")
                                  (("1"
                                    (replace -3 -17 :dir RL)
                                    (("1"
                                      (simplify)
                                      (("1"
                                        (expand release_set -17)
                                        (("1" (ground) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (replace -2 -16 :dir RL)
                                    (("2"
                                      (simplify)
                                      (("2"
                                        (lemma eq_mark_release_set)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (iftRedex? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (purePopDepth formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (pure_contextPure formula-decl nil IL nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (markv const-decl "(variable?)" preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (eq_mark_release_set formula-decl nil preprocess nil))
   nil))
 (ifReduce_TCC5 0
  (ifReduce_TCC5-1 nil 3683858380
   ("" (skeep*)
    (("" (expand refcount)
      (("" (typepred "grS`redex")
        (("" (typepred "grS")
          (("" (expand "pureIftRedex?")
            (("" (expand "iftRedex?")
              (("" (typepred "grS`count(x1)")
                (("" (rewrite -1)
                  (("" (expand refcount)
                    (("" (expand refcountExpr)
                      (("" (expand refs 2 1)
                        (("" (flatten)
                          (("" (use pure_refs)
                            (("" (ground)
                              ((""
                                (lift-if)
                                ((""
                                  (ground)
                                  ((""
                                    (use pure_refs)
                                    (("" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pure_refs formula-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil))
   nil))
 (ifReduce_TCC6 0
  (ifReduce_TCC6-1 nil 3683858380
   ("" (skeep*)
    (("" (typepred "grS")
      (("" (typepred "grS`redex")
        (("" (ground)
          (("1" (skeep) (("1" (inst -2 i) (("1" (grind) nil nil)) nil))
            nil)
           ("2" (skeep)
            (("2" (inst -3 i)
              (("2" (rewrite purePopDepth)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("3" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("4" (rewrite pure_contextPure) (("4" (grind) nil nil)) nil)
           ("5" (expand mark -5)
            (("5" (lift-if)
              (("5" (expand pureIftRedex?)
                (("5" (expand iftRedex?)
                  (("5" (flatten)
                    (("5" (ground)
                      (("5" (replace -12)
                        (("5" (replace -14 :dir RL)
                          (("5" (replace -15 :dir RL)
                            (("5"
                              (case "empty?(difference(vars(elseexpr),
                                          union(vars(thenexpr), grS`contextvars)))")
                              (("1"
                                (replace -3 -15 :dir RL)
                                (("1"
                                  (simplify)
                                  (("1"
                                    (expand release_set -15)
                                    (("1" (ground) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (lemma eq_mark_release_set)
                                (("2"
                                  (replace -3 -15 :dir RL)
                                  (("2"
                                    (simplify)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (iftRedex? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (purePopDepth formula-decl nil IL nil)
    (pure_contextPure formula-decl nil IL nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (markv const-decl "(variable?)" preprocess nil)
    (eq_mark_release_set formula-decl nil preprocess nil))
   nil))
 (ifReduce_TCC7 0
  (ifReduce_TCC7-1 nil 3698757037
   ("" (skeep*)
    (("" (expand refcount)
      (("" (typepred "grS`redex")
        (("" (typepred "grS")
          (("" (expand "pureIftRedex?")
            (("" (expand "iftRedex?")
              (("" (typepred "grS`count(x1)")
                (("" (rewrite -1)
                  (("" (expand refcount)
                    (("" (expand refcountExpr)
                      (("" (expand refs 3 1)
                        (("" (flatten)
                          (("" (use pure_refs)
                            (("" (ground)
                              ((""
                                (lift-if)
                                ((""
                                  (ground)
                                  ((""
                                    (use pure_refs)
                                    (("" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pure_refs formula-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil))
   nil))
 (setRedex_TCC1 0
  (setRedex_TCC1-1 nil 3698784150
   ("" (subtype-tcc)
    (("1" (expand mark) (("1" (propax) nil nil)) nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)
     ("5" (grind) nil nil))
    nil)
   ((finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil))
 (setRedex_TCC2 0
  (setRedex_TCC2-1 nil 3698784150 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil))
 (setRedex_TCC3 0
  (setRedex_TCC3-1 nil 3698784150
   ("" (skeep*)
    (("" (expand refcount)
      (("" (typepred "rS`count(refindex(vv))")
        (("" (rewrite -1)
          (("" (expand refcount)
            (("" (expand refcountExpr)
              (("" (typepred "rS`redex")
                (("" (typepred rS)
                  (("" (rewrite pure_refs) (("" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pure_refs formula-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil))
   nil))
 (setRedex_TCC4 0
  (setRedex_TCC4-1 nil 3698784150
   ("" (subtype-tcc)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil))
    nil)
   ((finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil))
 (setRedex_TCC5 0
  (setRedex_TCC5-1 nil 3698784150
   ("" (skeep*)
    (("" (typepred "rS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (grind)
              (("1" (typepred rS)
                (("1" (use pure_refs) (("1" (grind) nil nil)) nil))
                nil)
               ("2" (grind)
                (("2" (typepred rS)
                  (("2" (grind)
                    (("2" (typepred vv) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pure? def-decl "bool" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure_refs formula-decl nil IL nil)
    (refcountExpr const-decl "nat" rreduction nil))
   nil))
 (lookupReduce_TCC1 0
  (lookupReduce_TCC1-1 nil 3693417317 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (injective? const-decl "bool" functions nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (lookupReduce_TCC2 0
  (lookupReduce_TCC2-1 nil 3693417317
   ("" (skeep)
    (("" (use "lookupReduce_TCC2")
      (("" (inst - "rstate2estate(grS)" "stack")
        (("1" (ground)
          (("1" (skeep*)
            (("1" (inst?)
              (("1" (ground)
                (("1" (inst?)
                  (("1" (ground)
                    (("1" (inst?)
                      (("1" (ground)
                        (("1" (inst?)
                          (("1" (ground) (("1" (inst?) nil nil)) nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (typepred "grS")
                        (("2" (typepred "expr")
                          (("2" (lazy-grind) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil))
          nil)
         ("2" (hide 2) (("2" (grind) nil nil)) nil)
         ("3" (hide 2)
          (("3" (grind)
            (("3" (typepred "grS") (("3" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupReduce_TCC2 subtype-tcc nil reduction nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (goodstate type-eq-decl nil reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (estate type-eq-decl nil reduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil))
   nil))
 (lookupReduce_TCC3 0
  (lookupReduce_TCC3-1 nil 3693417317
   ("" (skeep*)
    (("" (use "lookupReduce_TCC3")
      (("" (inst - "rstate2estate(grS)" "stack")
        (("1" (ground)
          (("1" (inst?)
            (("1" (ground)
              (("1" (inst?)
                (("1" (ground)
                  (("1" (inst?)
                    (("1" (ground)
                      (("1" (inst?)
                        (("1" (ground)
                          (("1" (inst?)
                            (("1" (ground) (("1" (inst?) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (typepred "expr")
                      (("2" (lazy-grind) nil nil)) nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil)
         ("2" (grind) nil nil)
         ("3" (typepred "grS") (("3" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((lookupReduce_TCC3 subtype-tcc nil reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (estate type-eq-decl nil reduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil))
   nil))
 (lookupReduce_TCC4 0
  (lookupReduce_TCC4-1 nil 3693417317 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC5 0
  (lookupReduce_TCC5-1 nil 3693417317 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC6 0
  (lookupReduce_TCC6-1 nil 3693417317
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (inst -2 "index(avar)")
        (("" (expand setRedex)
          (("" (simplify)
            (("" (split 1)
              (("1" (ground)
                (("1" (typepred "grS")
                  (("1" (expand lookupRedex?) (("1" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (delete (-1 -2))
                (("2" (case-replace "grS`redex = lookup(avar, pos)")
                  (("1" (expand mark -4)
                    (("1" (decompose-equality -4)
                      (("1" (expand markv -1)
                        (("1" (expand add -1)
                          (("1" (replace -1 -4 :dir RL)
                            (("1" (split)
                              (("1" (grind) nil nil)
                               ("2"
                                (typepred "rval")
                                (("2"
                                  (hide-all-but (-1 -3))
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind-with-ext) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (setRedex const-decl "rstate" rreduction nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (nonempty? const-decl "bool" sets nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (IExpression_lookup_extensionality formula-decl nil IExpression_adt
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil))
   nil))
 (lookupReduce_TCC7 0
  (lookupReduce_TCC7-1 nil 3693417317
   ("" (skeep*) (("" (typepred "grS") (("" (grind) nil nil)) nil)) nil)
   ((lookupRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure? def-decl "bool" IL nil) (get const-decl "(value?)" IL nil))
   nil))
 (newintReduce_TCC1 0
  (newintReduce_TCC1-1 nil 3699020624 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (injective? const-decl "bool" functions nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (newintReduce_TCC2 0
  (newintReduce_TCC2-1 nil 3699020624 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (least_out_rec def-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil)
    (nonempty? const-decl "bool" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (size shared-adt-accessor-decl
          "[{x: IExpression | newint?(x) OR newref?(x)} -> nat]"
          IExpression_adt nil)
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil))
   nil))
 (newintReduce_TCC3 0
  (newintReduce_TCC3-1 nil 3699020624
   ("" (skeep*) (("" (grind) nil nil)) nil)
   ((nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (mark def-decl "IExpression" preprocess nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (emptyset const-decl "set" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil) (refs def-decl "bool" IL nil))
   nil))
 (newintReduce_TCC4 0
  (newintReduce_TCC4-1 nil 3699020624 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil))
   nil))
 (newintReduce_TCC5 0
  (newintReduce_TCC5-1 nil 3699020624 ("" (subtype-tcc) nil nil)
   ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil))
   nil))
 (newintReduce_TCC6 0
  (newintReduce_TCC6-1 nil 3699020624
   ("" (skeep*)
    (("" (expand refcount)
      (("" (expand refcountExpr)
        (("" (expand refs)
          (("" (rewrite refcount_stack_outside_domain)
            (("1" (lemma refcount_new)
              (("1" (inst -1 domain newdomain newrefredex store _)
                (("1" (inst?)
                  (("1" (ground)
                    (("1" (rewrite -1)
                      (("1" (expand refcountArray)
                        (("1" (rewrite count_none_zero)
                          (("1" (grind) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (ground)
                    (("1" (grind) nil nil)
                     ("2" (skeep*)
                      (("2" (typepred "store(x1)`seq(x2)")
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (refs def-decl "bool" IL nil)
    (refcount_new formula-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (constant adt-constructor-decl "[int -> (constant?)]"
     IExpression_adt nil)
    (member const-decl "bool" sets nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_none_zero formula-decl nil finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (remove_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (newintRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (refcount_stack_outside_domain formula-decl nil rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil))
   nil))
 (newrefReduce_TCC1 0
  (newrefReduce_TCC1-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (injective? const-decl "bool" functions nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (newrefReduce_TCC2 0
  (newrefReduce_TCC2-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (least_out_rec def-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil)
    (nonempty? const-decl "bool" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (size shared-adt-accessor-decl
          "[{x: IExpression | newint?(x) OR newref?(x)} -> nat]"
          IExpression_adt nil)
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil))
   nil))
 (newrefReduce_TCC3 0
  (newrefReduce_TCC3-1 nil 3699031813
   ("" (skeep*)
    (("" (ground)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil))
      nil))
    nil)
   ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil) (refs def-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (emptyset const-decl "set" sets nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil))
   nil))
 (newrefReduce_TCC4 0
  (newrefReduce_TCC4-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil))
   nil))
 (newrefReduce_TCC5 0
  (newrefReduce_TCC5-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil))
   nil))
 (newrefReduce_TCC6 0
  (newrefReduce_TCC6-1 nil 3699031813
   ("" (skeep*)
    (("" (expand refcount)
      (("" (expand refcountExpr)
        (("" (expand refs)
          (("" (rewrite refcount_stack_outside_domain)
            (("1" (use refcount_new)
              (("1" (ground)
                (("1" (rewrite -1)
                  (("1" (expand refcountArray)
                    (("1" (rewrite count_none_zero)
                      (("1" (skeep*) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil)
               ("2" (delete 2)
                (("2" (ground)
                  (("1" (skeep*) (("1" (grind) nil nil)) nil)
                   ("2" (skeep*)
                    (("2" (typepred "store(x1)`seq(x2)")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (refs def-decl "bool" IL nil)
    (refcount_new formula-decl nil rreduction nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_none_zero formula-decl nil finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (remove_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (count const-decl "nat" finseq_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (newrefRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (refcount_stack_outside_domain formula-decl nil rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil))
   nil))
 (popReduce_TCC1 0
  (popReduce_TCC1-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (popReduce_TCC2 0
  (popReduce_TCC2-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred grS) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (atom? const-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (popReduce_TCC3 0
  (popReduce_TCC3-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (atom? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (value? const-decl "bool" IL nil) (pop const-decl "Stack" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil))
   nil))
 (popReduce_TCC4 0
  (popReduce_TCC4-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred grS)
        (("" (ground)
          (("1" (grind) nil nil)
           ("2" (skeep*)
            (("2" (inst -4 i) (("2" (grind) nil nil)) nil)) nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pop const-decl "Stack" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil))
   nil))
 (popReduce_TCC5 0
  (popReduce_TCC5-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (case-replace "grS`redex = pop(body)")
              (("1" (expand refs 1 1)
                (("1" (expand refcountStack)
                  (("1" (rewrite count_decompose)
                    (("1" (lift-if)
                      (("1" (ground)
                        (("1" (delete 1)
                          (("1" (typepred grS)
                            (("1" (expand noDanglingRefs?)
                              (("1"
                                (inst -2 0)
                                (("1"
                                  (expand head)
                                  (("1"
                                    (ground)
                                    (("1"
                                      (replace -5)
                                      (("1"
                                        (expand vars -1)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (typepred "grS`redex")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (rewrite -2)
                          (("2"
                            (case-replace
                             "tail(grS`stack) = pop(grS`stack)")
                            (("2" (expand tail)
                              (("2"
                                (expand pop)
                                (("2" (grind-with-ext) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (replace -2)
                          (("3"
                            (case-replace
                             "tail(grS`stack) = pop(grS`stack)")
                            (("3" (grind-with-ext) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "grS`redex")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (grind-with-ext) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (IExpression_pop_extensionality formula-decl nil IExpression_adt
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count_decompose formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (> const-decl "bool" reals nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (atom? const-decl "bool" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (head const-decl "T" finseq_theorems nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pop const-decl "Stack" IL nil) (neStack type-eq-decl nil IL nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountStack const-decl "nat" rreduction nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (popReduce_TCC6 0
  (popReduce_TCC6-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred "grS")
        (("" (expand popRedex?)
          (("" (ground)
            (("1" (expand atom?) (("1" (propax) nil nil)) nil)
             ("2" (expand atom?)
              (("2" (inst -5 "index(body) - 1")
                (("1" (case-replace "grS`redex = pop(body)")
                  (("1" (expand vars -6)
                    (("1" (expand drop -6) (("1" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (grind-with-ext) nil nil))
                  nil)
                 ("2" (postpone) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (popReduce_TCC7 0
  (popReduce_TCC7-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (value? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (popReduce_TCC8 0
  (popReduce_TCC8-1 nil 3699031813 ("" (subtype-tcc) nil nil) nil nil))
 (popReduce_TCC9 0
  (popReduce_TCC9-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (popReduce_TCC10 0
  (popReduce_TCC10-1 nil 3699033156 ("" (subtype-tcc) nil nil) nil
   nil))
 (popReduce_TCC11 0
  (popReduce_TCC11-1 nil 3699033156 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (atom? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil) (pop const-decl "Stack" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (popReduce_TCC12 0
  (popReduce_TCC12-1 nil 3699033156 ("" (subtype-tcc) nil nil) nil
   nil))
 (popReduce_TCC13 0
  (popReduce_TCC13-1 nil 3699033156 ("" (subtype-tcc) nil nil) nil
   nil))
 (popReduce_TCC14 0
  (popReduce_TCC14-1 nil 3699033156 ("" (subtype-tcc) nil nil) nil
   nil))
 (popReduce_TCC15 0
  (popReduce_TCC15-1 nil 3699033156 ("" (subtype-tcc) nil nil) nil
   nil))
 (releaseReduce_TCC1 0
  (releaseReduce_TCC1-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (releaseRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (releaseReduce_TCC2 0
  (releaseReduce_TCC2-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (inst -2 "index(x)")
        (("" (ground)
          (("" (typepred "grS") (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (releaseRedex? const-decl "bool" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil))
   nil))
 (releaseReduce_TCC3 0
  (releaseReduce_TCC3-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred grS)
        (("" (inst -4 "index(x)") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (releaseRedex? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (releaseReduce_TCC4 0
  (releaseReduce_TCC4-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (value? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (releaseReduce_TCC5 0
  (releaseReduce_TCC5-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred "grS")
        (("" (ground)
          (("1" (grind) nil nil)
           ("2" (skeep*)
            (("2" (inst -5 i)
              (("2" (rewrite purePopDepth)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("3" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("4" (use pure_contextPure) (("4" (grind) nil nil)) nil)
           ("5"
            (case-replace "grS`redex = release(x, rexpr(grS`redex))")
            (("1" (simplify)
              (("1" (expand mark -8)
                (("1" (decompose-equality -8) nil nil)) nil))
              nil)
             ("2" (grind-with-ext) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (purePopDepth formula-decl nil IL nil)
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil))
   nil))
 (releaseReduce_TCC6 0
  (releaseReduce_TCC6-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred stack)
      (("" (grind)
        (("" (typepred "grS`redex")
          (("" (inst -2 "index(rvar(grS`redex))")
            (("" (grind)
              (("" (typepred grS) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Stack type-eq-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (releaseRedex? const-decl "bool" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil))
   nil))
 (releaseReduce_TCC7 0
  (releaseReduce_TCC7-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`count(refindex(vx))")
      (("1" (rewrite -1)
        (("1" (expand refcount)
          (("1" (expand refcountExpr)
            (("1"
              (case-replace "grS`redex = release(x, rexpr(grS`redex))")
              (("1" (simplify)
                (("1" (expand refs 1 1)
                  (("1" (expand refs 1 2)
                    (("1" (split)
                      (("1" (expand refcountStack)
                        (("1"
                          (use "finseq_theorems[(value?)].count_elem")
                          (("1" (ground)
                            (("1" (grind) nil nil)
                             ("2"
                              (inst 1 "stack`length - index(x) - 1")
                              (("1" (grind) nil nil)
                               ("2"
                                (typepred "grS`redex")
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand refcountStack)
                        (("2"
                          (rewrite
                           "finseq_theorems[(value?)].count_update")
                          (("1" (grind) nil nil)
                           ("2" (typepred "grS`redex")
                            (("2" (grind) nil nil)) nil)
                           ("3" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind-with-ext) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "grS`stack")
        (("2" (delete 2)
          (("2" (grind)
            (("2" (typepred "grS`redex")
              (("2" (delete 2)
                (("2" (inst -2 "index(rvar(grS`redex))")
                  (("2" (typepred grS) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (propax) nil nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (union const-decl "set" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "(nonempty?)" sets nil)
    (count const-decl "nat" finseq_theorems nil)
    (get const-decl "(value?)" IL nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountStack const-decl "nat" rreduction nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_update formula-decl nil finseq_theorems nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (releaseRedex? const-decl "bool" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/"))
   nil))
 (releaseReduce_TCC8 0
  (releaseReduce_TCC8-1 nil 3699031813
   ("" (skeep*)
    (("" (expand noDanglingRefs?)
      (("" (skeep*)
        (("" (typepred "grS`redex")
          (("" (typepred "grS") (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (releaseRedex? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil))
 (releaseReduce_TCC9 0
  (releaseReduce_TCC9-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (releaseReduce_TCC10 0
  (releaseReduce_TCC10-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred grS)
        (("" (ground)
          (("1" (grind) nil nil)
           ("2" (skeep*)
            (("2" (inst -5 i)
              (("2" (rewrite purePopDepth)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("3" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("4" (rewrite pure_contextPure) (("4" (grind) nil nil)) nil)
           ("5"
            (case-replace "grS`redex = release(x, rexpr(grS`redex))")
            (("1" (expand mark -8)
              (("1" (simplify) (("1" (decompose-equality -8) nil nil))
                nil))
              nil)
             ("2" (grind-with-ext) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (purePopDepth formula-decl nil IL nil)
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil))
   nil))
 (releaseReduce_TCC11 0
  (releaseReduce_TCC11-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (typepred "grS") (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (refcountExpr const-decl "nat" rreduction nil))
   nil))
 (letReduce_TCC1 0
  (letReduce_TCC1-1 nil 3699107903 ("" (subtype-tcc) nil nil)
   ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (atom? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (letReduce_TCC2 0
  (letReduce_TCC2-1 nil 3699107903
   ("" (skeep*)
    (("" (typepred grS)
      (("" (typepred "grS`redex") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil))
   nil))
 (letReduce_TCC3 0
  (letReduce_TCC3-1 nil 3699107903
   ("" (skeep*)
    (("" (typepred "grS`stack")
      (("" (typepred "grS`redex")
        (("" (typepred grS) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (atom? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (singleton const-decl "(singleton?)" sets nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (markv const-decl "(variable?)" preprocess nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil))
   nil))
 (letReduce_TCC4 0
  (letReduce_TCC4-1 nil 3699107903
   ("" (skeep*)
    (("" (typepred grS)
      (("" (typepred "grS`redex")
        (("" (ground)
          (("1" (skeep*)
            (("1"
              (case-replace
               "grS`redex = letexpr(letrhs(expr), body(expr))")
              (("1" (expand refs -3)
                (("1" (replace -14)
                  (("1" (lift-if)
                    (("1" (expand refs -2)
                      (("1" (expand refs -2 1)
                        (("1" (expand pureLetRedex?)
                          (("1" (use pure_refs) (("1" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind-with-ext) nil nil))
              nil))
            nil)
           ("2" (replace -12)
            (("2" (skeep*)
              (("2" (lift-if 1)
                (("2" (lift-if -1)
                  (("2" (expand popDepth 1)
                    (("2" (expand popDepth 1 1)
                      (("2" (rewrite purePopDepth 1)
                        (("1" (expand vars -1)
                          (("1" (expand drop -1)
                            (("1" (expand vars -1 1)
                              (("1"
                                (inst -3 "i")
                                (("1"
                                  (case-replace
                                   "grS`redex = letexpr(letrhs(expr), body(expr))")
                                  (("1"
                                    (expand vars -4)
                                    (("1"
                                      (expand union -4)
                                      (("1"
                                        (expand drop -4)
                                        (("1"
                                          (expand member -4)
                                          (("1"
                                            (expand add -2)
                                            (("1"
                                              (expand push)
                                              (("1"
                                                (expand add 1)
                                                (("1"
                                                  (postpone)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (postpone) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (postpone) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (postpone) nil nil) ("4" (postpone) nil nil)
           ("5" (postpone) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (letReduce_TCC5 0
  (letReduce_TCC5-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil nil))
 (letReduce_TCC6 0
  (letReduce_TCC6-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil nil))
 (letReduce_TCC7 0
  (letReduce_TCC7-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil nil))
 (letReduce_TCC8 0
  (letReduce_TCC8-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil nil))
 (letReduce_TCC9 0
  (letReduce_TCC9-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil nil))
 (letReduce_TCC10 0
  (letReduce_TCC10-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (letReduce_TCC11 0
  (letReduce_TCC11-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC1 0
  (updateReduce_TCC1-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC2 0
  (updateReduce_TCC2-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC3 0
  (updateReduce_TCC3-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC4 0
  (updateReduce_TCC4-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC5 0
  (updateReduce_TCC5-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC6 0
  (updateReduce_TCC6-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC7 0
  (updateReduce_TCC7-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC8 0
  (updateReduce_TCC8-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC9 0
  (updateReduce_TCC9-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC10 0
  (updateReduce_TCC10-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC11 0
  (updateReduce_TCC11-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC12 0
  (updateReduce_TCC12-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC13 0
  (updateReduce_TCC13-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC14 0
  (updateReduce_TCC14-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC15 0
  (updateReduce_TCC15-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC16 0
  (updateReduce_TCC16-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC17 0
  (updateReduce_TCC17-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC18 0
  (updateReduce_TCC18-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil)))

