(rreduction
 (refcountExpr_popit 0
  (refcountExpr_popit-1 nil 3683904062
   ("" (skeep)
    (("" (expand "refcountExpr") (("" (rewrite "popit_refs") nil nil))
      nil))
    nil)
   ((refcountExpr const-decl "nat" rreduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (popit_refs formula-decl nil reduction nil))
   shostak))
 (noDanglingRefs?_TCC1 0
  (noDanglingRefs?_TCC1-1 nil 3698761342 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (to_topstate_TCC1 0
  (to_topstate_TCC1-1 nil 3699126721
   ("" (subtype-tcc) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil))
 (to_topstate_TCC2 0
  (to_topstate_TCC2-1 nil 3699126721
   ("" (skeep*)
    (("" (ground)
      (("1" (skeep*)
        (("1" (typepred "rS`context")
          (("1" (rewrite refs_fill)
            (("1" (typepred "rS`redex") (("1" (grind) nil nil)) nil)
             ("2" (typepred "rS`redex")
              (("2" (use contextPurefill) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep*)
        (("2" (rewrite vars_decompose)
          (("2" (typepred "rS`redex")
            (("2" (rewrite popdepth_fill) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil)
       ("4" (rewrite popdepth_fill)
        (("4" (typepred "rS`redex") (("4" (grind) nil nil)) nil)) nil)
       ("5" (rewrite contextPurefill) nil nil)
       ("6" (rewrite mark_fill)
        (("6" (expand bumpn)
          (("6" (expand union)
            (("6" (expand member)
              (("6" (typepred "rS`context")
                (("6" (expand cvars 1 1)
                  (("6" (rewrite -2)
                    (("6" (expand cvars 1 2)
                      (("6" (expand emptyset)
                        (("6" (typepred "rS`redex")
                          (("6"
                            (case-replace
                             "{x: nat | cvars(rS`context)(x)} = cvars(rS`context)")
                            (("1" (grind) nil nil)
                             ("2" (grind-with-ext) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (contextPurefill formula-decl nil IL nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (refs_fill formula-decl nil IL nil)
    (vars_decompose formula-decl nil IL nil)
    (popdepth_fill formula-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (mark_fill formula-decl nil preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (to_topstate_TCC3 0
  (to_topstate_TCC3-1 nil 3699126721
   ("" (skeep*)
    (("" (typepred "rS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (rewrite refs_fill)
              (("" (use contextPurefill)
                (("" (typepred "rS`context")
                  (("" (typepred "rS`redex") (("" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refs_fill formula-decl nil IL nil)
    (contextPurefill formula-decl nil IL nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (to_topstate_TCC4 0
  (to_topstate_TCC4-1 nil 3699126721 ("" (subtype-tcc) nil nil) nil
   nil))
 (to_topstate_dangling 0
  (to_topstate_dangling-1 nil 3699296735
   ("" (skeep* :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (skeep* :preds? t)
        (("" (expand to_topstate)
          (("" (rewrite cvars_fill) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (below type-eq-decl nil naturalnumbers nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (cvars_fill formula-decl nil preprocess nil))
   nil))
 (refcountStore_ref 0
  (refcountStore_ref-1 nil 3685183232
   ("" (skeep :preds? t)
    (("" (expand "refcountStore")
      (("" (expand allcount)
        (("" (rewrite sigma_sigma_set)
          (("" (use "sigma_set[nat].sigma_gt_0")
            (("1" (ground)
              (("1" (grind) nil nil)
               ("2" (delete 2)
                (("2" (inst 1 "r")
                  (("2" (expand "refcountArray")
                    (("2"
                      (use "finseq_theorems[(IL.value?)].count_elem")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (use "finite_set_theorems.sigma_sigma_set_TCC1") nil
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" rreduction nil)
    (sigma_sigma_set formula-decl nil finite_set_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (refcountArray const-decl "nat" rreduction nil)
    (sigma_sigma_set_TCC1 subtype-tcc nil finite_set_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sigma const-decl "real" sigma_set "sigma_set/")
    (sigma const-decl "real" sigma_countable "sigma_set/")
    (limit const-decl "real" convergence_sequences "analysis/")
    (convergence const-decl "bool" convergence_sequences "analysis/")
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (sigma def-decl "real" sigma "reals/")
    (O const-decl "T3" function_props nil)
    (denumerable_enumeration const-decl "[nat -> (X)]"
     denumerable_enumeration "sigma_set/")
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (nonzero_elts const-decl "set[T]" convergence_set "sigma_set/")
    (/= const-decl "boolean" notequal nil)
    (count const-decl "nat" finseq_theorems nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (convergent? const-decl "bool" convergence_set "sigma_set/")
    (sigma_gt_0 formula-decl nil sigma_set "sigma_set/")
    (allcount const-decl "nat" rreduction nil))
   shostak))
 (refcountArray_update_TCC1 0
  (refcountArray_update_TCC1-1 nil 3692674266
   ("" (subtype-tcc) nil nil) ((value? const-decl "bool" IL nil)) nil))
 (refcountArray_update 0
  (refcountArray_update-1 nil 3692674266
   ("" (skeep :preds? t)
    (("" (expand "refcountArray")
      (("" (use "finseq_theorems[(IL.value?)].count_update")
        (("1" (rewrite -1) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((refcountArray const-decl "nat" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (count_update formula-decl nil finseq_theorems nil))
   shostak))
 (store_update_TCC1 0
  (store_update_TCC1-1 nil 3692717400 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil))
   nil))
 (store_update_TCC2 0
  (store_update_TCC2-1 nil 3692717400 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil))
 (store_update 0
  (store_update-1 nil 3692717400
   ("" (skeep)
    (("" (case "r = k") (("1" (assert) nil nil) ("2" (assert) nil nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (refcountStore_update 0
  (refcountStore_update-1 nil 3692670917
   ("" (skeep)
    (("" (expand "refcountStore")
      (("" (expand allcount)
        (("" (lemma sigma_with)
          ((""
            (inst -1 "rS`domain" _ _ "r"
             "refcountArray(rS`store WITH [(r)(seq)(j) := nil](r))(i)")
            (("1"
              (inst -1 "lambda (j_1: nat):
               IF rS`domain(j_1) THEN refcountArray(rS`store(j_1))(i)
               ELSE 0
               ENDIF" "lambda (j_1: nat):
              IF rS`domain(j_1)
                THEN refcountArray(rS`store WITH [(r)(seq)(j) := nil](j_1))
                                  (i)
              ELSE 0
              ENDIF")
              (("1" (ground)
                (("1" (rewrite refcountArray_update)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (delete 2)
                  (("2" (apply-extensionality)
                    (("1" (delete 2)
                      (("1" (lift-if)
                        (("1" (ground)
                          (("1"
                            (case "(# length := rS`store(x!1)`length,
                       seq
                         := LAMBDA (x1: below[rS`store(x!1)`length]):
                              IF x1 = j THEN nil
                              ELSE rS`store(x!1)`seq(x1)
                              ENDIF #) = rS`store(r) WITH [(seq)(j) := nil]")
                            (("1" (rewrite -1) nil nil)
                             ("2" (delete 2)
                              (("2"
                                (grind)
                                (("2" (grind-with-ext) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil) ("3" (grind) nil nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" rreduction nil)
    (sigma_with formula-decl nil finite_set_theorems nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountArray_update formula-decl nil rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (count const-decl "nat" finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (refcountArray const-decl "nat" rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (allcount const-decl "nat" rreduction nil))
   shostak))
 (refcount_stack_outside_domain 0
  (refcount_stack_outside_domain-1 nil 3699029139
   ("" (skeep*)
    (("" (expand refcountStack)
      (("" (rewrite count_none_zero)
        (("" (skeep*)
          (("" (typepred "rS`stack") (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((refcountStack const-decl "nat" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (count const-decl "nat" finseq_theorems nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (value? const-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (count_none_zero formula-decl nil finseq_theorems nil))
   shostak))
 (refcount_new_TCC1 0
  (refcount_new_TCC1-1 nil 3699027941 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil))
   nil))
 (refcount_new_TCC2 0
  (refcount_new_TCC2-1 nil 3699027941 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil))
   nil))
 (refcount_new 0
  (refcount_new-1 nil 3699027941
   ("" (skeep*)
    (("" (expand refcountStore)
      (("" (replace -1)
        (("" (expand allcount)
          (("" (lemma sigma_add)
            (("" (inst?)
              (("1" (inst -1 i)
                (("1" (ground)
                  (("1" (rewrite -1)
                    (("1" (expand add 2 1)
                      (("1" (rewrite remove_add_member)
                        (("1" (rewrite sigma_zero)
                          (("1" (skeep*)
                            (("1" (lift-if)
                              (("1"
                                (ground)
                                (("1"
                                  (rewrite -3 :dir RL)
                                  (("1"
                                    (expand refcountArray 1)
                                    (("1"
                                      (rewrite count_none_zero)
                                      (("1"
                                        (skeep*)
                                        (("1"
                                          (typepred
                                           "store(x)`seq(i_1)")
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (refcountArray const-decl "nat" rreduction nil)
    (domainValue? const-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (remove_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (sigma_zero formula-decl nil finite_set_theorems nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (count_none_zero formula-decl nil finseq_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (empty? const-decl "bool" sets nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (member const-decl "bool" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (remove_add_member formula-decl nil sets_lemmas nil)
    (choose const-decl "(p)" sets nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (sigma_add formula-decl nil finite_set_theorems nil))
   shostak))
 (allcountStore_update_TCC1 0
  (allcountStore_update_TCC1-1 nil 3698768688
   ("" (skeep*)
    (("" (expand refcount)
      (("" (rewrite refcountStore_update)
        (("" (typepred "rS`count(i)")
          (("" (rewrite -1)
            (("" (expand refcount)
              (("" (lemma "refcountStore_ref") (("" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (allcountStore_update 0
  (allcountStore_update-1 nil 3698768688
   ("" (skeep*)
    (("" (expand allcountStore)
      (("" (expand allcount)
        (("" (lemma "sigma_with")
          ((""
            (inst -1 "rS`domain"
             "lambda j: IF rS`domain(j) THEN rS`count(j) ELSE 0 ENDIF"
             "lambda j:
              IF rS`domain(j)
                THEN rS`count WITH [(i) := rS`count(i) - 1](j)
              ELSE 0
              ENDIF" "i" "rS`count(i) - 1")
            (("1" (ground)
              (("1" (delete 2) (("1" (postpone) nil nil)) nil)
               ("2" (postpone) nil nil))
              nil)
             ("2" (postpone) nil nil) ("3" (postpone) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (allcountStore_decrease_TCC1 0
  (allcountStore_decrease_TCC1-1 nil 3692982211
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil))
 (allcountStore_decrease_TCC2 0
  (allcountStore_decrease_TCC2-1 nil 3692982211
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil))
 (allcountStore_decrease 0
  (allcountStore_decrease-1 nil 3692982211
   ("" (skeep* :preds? t)
    (("" (expand allcountStore)
      (("" (expand allcount)
        (("" (rewrite sigma_sigma_set)
          (("" (rewrite sigma_sigma_set)
            (("" (lemma "sigma_set[nat].sigma_lt")
              (("" (inst -1 "rS`domain" _ _)
                ((""
                  (inst -1
                   "lambda j: IF rS1`domain(j) THEN rS1`count(j) ELSE 0 ENDIF"
                   "lambda j: IF rS`domain(j) THEN rS`count(j) ELSE 0 ENDIF")
                  (("1" (ground)
                    (("1" (delete 2)
                      (("1" (skeep)
                        (("1" (inst -3 "t") (("1" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (inst 1 s) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (use sigma_sigma_set_TCC1) nil nil)
                   ("3" (use sigma_sigma_set_TCC1) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((allcountStore const-decl "nat" rreduction nil)
    (sigma_sigma_set formula-decl nil finite_set_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma_lt formula-decl nil sigma_set "sigma_set/")
    (convergent? const-decl "bool" convergence_set "sigma_set/")
    (sigma const-decl "real" sigma_set "sigma_set/")
    (sigma const-decl "real" sigma_countable "sigma_set/")
    (limit const-decl "real" convergence_sequences "analysis/")
    (convergence const-decl "bool" convergence_sequences "analysis/")
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (sigma def-decl "real" sigma "reals/")
    (O const-decl "T3" function_props nil)
    (denumerable_enumeration const-decl "[nat -> (X)]"
     denumerable_enumeration "sigma_set/")
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (nonzero_elts const-decl "set[T]" convergence_set "sigma_set/")
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_sigma_set_TCC1 subtype-tcc nil finite_set_theorems nil)
    (allcount const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (decref_TCC1 0
  (decref_TCC1-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_TCC2 0
  (decref_TCC2-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (allcount const-decl "nat" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_TCC3 0
  (decref_TCC3-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil))
   nil))
 (decref_TCC4 0
  (decref_TCC4-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC5 0
  (decref_TCC5-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil))
   nil))
 (decref_TCC6 0
  (decref_TCC6-1 nil 3692915538
   ("" (skeep*)
    (("" (expand "refcount")
      (("" (rewrite "refcountStore_update")
        (("1" (ground)
          (("1" (typepred "rS`count(subrefindex)")
            (("1" (replace -1 :hide? t)
              (("1" (expand "refcount")
                (("1" (use "refcountStore_ref")
                  (("1" (ground)
                    (("1" (case "ref(refindex(subref)) = subref")
                      (("1" (assert) nil nil)
                       ("2" (apply-extensionality :hide? t) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (typepred "rS`count(subrefindex)")
            (("2" (expand "refcount") (("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (case "ref(refindex(subref)) = subref")
          (("1" (assert) nil nil)
           ("2" (apply-extensionality :hide? t) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_TCC7 0
  (decref_TCC7-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC8 0
  (decref_TCC8-1 nil 3692915538
   ("" (skeep*)
    (("" (replace -6 :hide? t) (("" (assert) nil nil)) nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_TCC9 0
  (decref_TCC9-1 nil 3692915538
   ("" (skeep*)
    (("" (lemma "allcountStore_decrease")
      (("" (inst?) (("" (ground) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((allcountStore_decrease formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (allcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_TCC10 0
  (decref_TCC10-1 nil 3692915538
   ("" (skeep*)
    (("" (rewrite -6)
      (("" (use allcountStore_update)
        (("1" (ground)
          (("1" (grind) nil nil) ("2" (grind-with-ext) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (< def-decl "bool" ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (allcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (allcountStore_update formula-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_TCC11 0
  (decref_TCC11-1 nil 3692915538
   ("" (skeep*) (("" (lift-if) (("" (ground) nil nil)) nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_TCC12 0
  (decref_TCC12-1 nil 3692915538
   ("" (skeep*) (("" (lift-if) (("" (ground) nil nil)) nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_TCC13 0
  (decref_TCC13-1 nil 3692915538
   ("" (skeep*)
    (("" (ground)
      (("" (lift-if)
        (("" (ground)
          ((""
            (typepred "v(rS
                           WITH [`store(r)`seq(i - 1) := nil,
                                 `count(refindex(subref))
                                   := rS`count(refindex(subref)) - 1],
                         refindex(subref), rS`store(refindex(subref))`length)")
            (("1" (hide -2 -3)
              (("1" (lemma "allcountStore_decrease")
                (("1"
                  (inst - "rS" "rS
                                   WITH [`store(r)`seq(i - 1) := nil,
                                         `count(refindex(subref))
                                           := rS`count(refindex(subref)) - 1]"
                   "refindex(subref)")
                  (("1" (ground)
                    (("1" (typepred i)
                      (("1"
                        (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
                        (("1" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (use "decref_TCC6")
                    (("2" (assert)
                      (("2" (inst?)
                        (("2" (assert)
                          (("2" (inst?)
                            (("2" (assert) (("2" (inst?) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (hide -1) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (case "r = refindex(subref)")
              (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
             ("3" (use "decref_TCC6")
              (("3" (assert)
                (("3" (inst?)
                  (("3" (assert)
                    (("3" (inst?)
                      (("3" (assert)
                        (("3" (inst?)
                          (("3" (expand noDanglingRefs?)
                            (("3" (typepred rS) (("3" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (expand refcount)
              (("4" (rewrite refcountStore_update)
                (("1" (typepred "rS`count(refindex(subref))")
                  (("1" (rewrite -1)
                    (("1" (expand refcount)
                      (("1" (use refcountStore_ref)
                        (("1" (ground)
                          (("1" (hide-all-but (1 -4 -1))
                            (("1" (rewrite -2)
                              (("1" (grind-with-ext) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide-all-but (1 -1 -4))
                  (("2" (grind-with-ext) nil nil)) nil))
                nil))
              nil)
             ("5" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref_TCC6 subtype-tcc nil rreduction nil)
    (allcountStore_decrease formula-decl nil rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_TCC14 0
  (decref_TCC14-1 nil 3692915538
   ("" (skeep*)
    (("" (lift-if)
      (("" (prop)
        (("1"
          (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
          (("1" (delete -2 -3 -4)
            (("1" (replace -3 -1 :dir RL)
              (("1" (lemma allcountStore_decrease)
                (("1"
                  (inst -1 "rS" "rS
                       WITH [`store(r)`seq(i - 1) := nil,
                             `count(refindex(subref))
                               := rS`count(refindex(subref)) - 1]"
                   "refindex(subref)")
                  (("1" (ground) (("1" (grind) nil nil)) nil)
                   ("2" (expand refcount)
                    (("2" (rewrite refcountStore_update)
                      (("1" (typepred "rS`count(refindex(subref))")
                        (("1" (rewrite -1)
                          (("1" (expand refcount)
                            (("1" (lemma refcountStore_ref)
                              (("1"
                                (delete -4 3)
                                (("1"
                                  (delete -2)
                                  (("1"
                                    (inst
                                     -1
                                     "rS"
                                     "r"
                                     "refindex(subref)"
                                     "i - 1")
                                    (("1"
                                      (grind)
                                      (("1"
                                        (delete 3)
                                        (("1"
                                          (grind)
                                          (("1"
                                            (grind-with-ext)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but (1 -2 -5))
                        (("2" (grind-with-ext) nil nil)) nil))
                      nil))
                    nil)
                   ("3" (grind) nil nil) ("4" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil)
           ("3" (typepred rS) (("3" (grind) nil nil)) nil)
           ("4" (expand refcount)
            (("4" (rewrite refcountStore_update)
              (("1" (typepred "rS`count(refindex(subref))")
                (("1" (rewrite -1)
                  (("1" (expand refcount)
                    (("1" (lemma refcountStore_ref)
                      (("1"
                        (inst -1 "rS" "r" "refindex(subref)" "i - 1")
                        (("1" (delete -3)
                          (("1" (delete 3)
                            (("1" (grind)
                              (("1"
                                (delete 3)
                                (("1" (grind-with-ext) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind-with-ext) nil nil))
              nil))
            nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (allcountStore_decrease formula-decl nil rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_TCC15 0
  (decref_TCC15-1 nil 3692972887
   ("" (skeep*)
    (("" (ground)
      (("1" (lift-if)
        (("1" (ground)
          (("1"
            (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
            (("1" (replace -6 :dir RL)
              (("1" (case "allcountStore(newrS) <= allcountStore(rS)")
                (("1" (typepred "v(newrS, r, i - 1)")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (use allcountStore_update)
                  (("2" (grind-with-ext) nil nil)) nil))
                nil))
              nil)
             ("2" (grind) nil nil)
             ("3" (typepred rS) (("3" (grind) nil nil)) nil)
             ("4" (use allcountStore_update_TCC1)
              (("4" (grind-with-ext) nil nil)) nil)
             ("5" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (lift-if) (("2" (ground) nil nil)) nil)
       ("3" (lift-if)
        (("3" (skeep*)
          (("3" (split -3)
            (("1" (flatten)
              (("1"
                (name-replace "newrS2" "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
                (("1" (typepred newrS2)
                  (("1" (inst -3 s)
                    (("1" (typepred "v(newrS, r, i - 1)")
                      (("1" (inst -3 s)
                        (("1" (hide (-8 -5 -4 -2 -1))
                          (("1" (flatten)
                            (("1" (rewrite -9)
                              (("1"
                                (rewrite -1)
                                (("1"
                                  (rewrite -4)
                                  (("1"
                                    (split 1)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (hide (-2 -3 -5))
                                      (("2"
                                        (hide -4)
                                        (("2"
                                          (hide (-3 -4))
                                          (("2"
                                            (lift-if)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (delete 2)
                          (("2" (hide-all-but (1 -5 -9))
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (rewrite -6)
                        (("2" (delete 2)
                          (("2" (use allcountStore_update)
                            (("2" (delete -4)
                              (("2" (grind-with-ext) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("3" (rewrite -6)
                        (("3" (delete -1 -2 -3)
                          (("3" (typepred newrS2)
                            (("3" (inst -3 r) (("3" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (grind) nil nil)
                       ("5" (rewrite -6) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil)
                 ("3" (typepred rS) (("3" (grind) nil nil)) nil)
                 ("4" (use allcountStore_update_TCC1)
                  (("4" (grind-with-ext) nil nil)) nil)
                 ("5" (grind) nil nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (replace -1)
                (("2" (typepred "v(rS, r, i - 1)")
                  (("1" (ground)
                    (("1" (grind) nil nil)
                     ("2" (inst -3 s) (("2" (grind) nil nil)) nil)
                     ("3" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (allcountStore_update_TCC1 subtype-tcc nil rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (allcountStore_update formula-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_TCC16 0
  (decref_TCC16-1 nil 3698762473 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC17 0
  (decref_TCC17-1 nil 3698762473 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (allcount const-decl "nat" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (letApply_TCC1 0
  (letApply_TCC1-1 nil 3699206216 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (letApply_TCC2 0
  (letApply_TCC2-1 nil 3699206216 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (letApply_TCC3 0
  (letApply_TCC3-1 nil 3699206216 ("" (subtype-tcc) nil nil) nil nil))
 (letApply_TCC4 0
  (letApply_TCC4-1 nil 3699206216 ("" (subtype-tcc) nil nil) nil nil))
 (letApply_TCC5 0
  (letApply_TCC5-1 nil 3699206216
   ("" (skeep*)
    (("" (rewrite map_length)
      (("" (typepred args)
        (("" (grind)
          (("" (expand length -2) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (map_length formula-decl nil more_map_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil))
 (letApply_TCC6 0
  (letApply_TCC6-1 nil 3699206216 ("" (termination-tcc) nil nil) nil
   nil))
 (letApply_TCC7 0
  (letApply_TCC7-1 nil 3699206216
   ("" (subtype-tcc) (("" (grind) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil))
   nil))
 (pure_letApply_TCC1 0
  (pure_letApply_TCC1-1 nil 3699206216
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil))
 (pure_letApply_TCC2 0
  (pure_letApply_TCC2-1 nil 3699206216
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil))
 (bump_varlist_TCC1 0
  (bump_varlist_TCC1-1 nil 3699274146 ("" (subtype-tcc) nil nil) nil
   nil))
 (bump_varlist_TCC2 0
  (bump_varlist_TCC2-1 nil 3699274146 ("" (subtype-tcc) nil nil) nil
   nil))
 (bump_varlist 0
  (bump_varlist-1 nil 3699274147
   ("" (skeep*)
    (("" (expand in_varlist)
      (("" (apply-extensionality 1)
        (("1" (delete 2)
          (("1" (rewrite some_map)
            (("1" (expand bump)
              (("1" (expand bumpn)
                (("1" (expand o)
                  (("1" (rewrite some_nth)
                    (("1" (rewrite some_nth)
                      (("1" (iff)
                        (("1" (ground)
                          (("1" (grind) nil nil)
                           ("2" (skeep*) (("2" (grind) nil nil)) nil)
                           ("3" (skeep*) (("3" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (delete 2)
          (("2"
            (case-replace "{i |
              some[(variable?)](lambda (v: (variable?)): index(v) = i)(L)} = in_varlist(L)")
            (("1" (grind) nil nil)
             ("2" (expand in_varlist) (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)
    (O const-decl "T3" function_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (some_map formula-decl nil finseq_theorems nil)
    (TRUE const-decl "bool" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (vars_letApply 0
  (vars_letApply-1 nil 3699282159
   ("" (induct i)
    (("1" (skeep* :preds? t)
      (("1" (expand letApply)
        (("1" (case "args = null")
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil)
     ("2" (skeep*)
      (("2" (expand letApply 1)
        (("2" (expand vars 1 2)
          (("2" (expand vars 1 3)
            (("2" (expand vars 1 4)
              (("2" (expand drop)
                (("2" (expand add)
                  (("2" (expand member)
                    (("2" (expand union)
                      (("2" (expand member)
                        (("2" (expand in_varlist 1)
                          (("2" (name "hd" "car(args)")
                            (("2" (name "tl" "cdr(args)")
                              (("2"
                                (case-replace "args = cons(hd, tl)")
                                (("1"
                                  (simplify)
                                  (("1"
                                    (expand some)
                                    (("1"
                                      (typepred hd)
                                      (("1"
                                        (expand vars 1 1)
                                        (("1"
                                          (expand singleton 1)
                                          (("1"
                                            (rewrite -5)
                                            (("1"
                                              (rewrite bump_varlist)
                                              (("1"
                                                (expand bump)
                                                (("1"
                                                  (expand bumpn)
                                                  (("1"
                                                    (expand
                                                     in_varlist
                                                     1)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind-with-ext) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton const-decl "(singleton?)" sets nil)
    (bump_varlist formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (letApply def-decl "IExpression" rreduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (popdepth_letApply 0
  (popdepth_letApply-1 nil 3699282706
   ("" (induct i)
    (("1" (skeep :preds? t) (("1" (grind) nil nil)) nil)
     ("2" (skeep* :preds? t) (("2" (grind) nil nil)) nil)
     ("3" (grind) nil nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (letApply def-decl "IExpression" rreduction nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   shostak))
 (mark_letApply_cons_TCC1 0
  (mark_letApply_cons_TCC1-1 nil 3699212334 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)) nil))
 (mark_letApply_cons_TCC2 0
  (mark_letApply_cons_TCC2-1 nil 3699212334
   ("" (skeep*) (("" (rewrite map_length) nil nil)) nil)
   ((TRUE const-decl "bool" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (map_length formula-decl nil more_map_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil))
 (mark_letApply_cons 0
  (mark_letApply_cons-1 nil 3699212334
   ("" (skeep*)
    (("" (expand letApply 1 1)
      (("" (rewrite vars_mark)
        (("1" (lift-if)
          (("1" (ground)
            (("1" (expand mark 2 1)
              (("1" (decompose-equality)
                (("1" (expand mark)
                  (("1" (expand markv)
                    (("1" (expand union)
                      (("1" (expand drop)
                        (("1" (expand member)
                          (("1" (expand vars 1 1)
                            (("1" (expand add)
                              (("1"
                                (expand member)
                                (("1"
                                  (rewrite vars_letApply)
                                  (("1"
                                    (expand in_varlist)
                                    (("1"
                                      (rewrite some_map)
                                      (("1"
                                        (expand o)
                                        (("1"
                                          (lift-if)
                                          (("1"
                                            (lift-if)
                                            (("1"
                                              (lift-if)
                                              (("1" (ground) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand vars 1 1)
                  (("2" (expand add)
                    (("2" (expand mark 1 1)
                      (("2" (decompose-equality)
                        (("2" (expand markv)
                          (("2" (lift-if)
                            (("2" (ground)
                              (("2"
                                (expand union)
                                (("2"
                                  (expand bump)
                                  (("2"
                                    (expand bumpn)
                                    (("2"
                                      (expand member)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand mark 1 1)
              (("2" (decompose-equality)
                (("2" (expand mark)
                  (("2" (expand markv)
                    (("2" (expand union)
                      (("2" (expand drop)
                        (("2" (expand member)
                          (("2" (rewrite vars_letApply 1)
                            (("2" (expand in_varlist 1)
                              (("2"
                                (rewrite some_map 1)
                                (("2"
                                  (expand o)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (rewrite map_length) nil nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letApply def-decl "IExpression" rreduction nil)
    (map_length formula-decl nil more_map_props nil)
    (mark def-decl "IExpression" preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (vars_letApply formula-decl nil rreduction nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (some_map formula-decl nil finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (O const-decl "T3" function_props nil)
    (markv const-decl "(variable?)" preprocess nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (vars_mark formula-decl nil preprocess nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (mark_letApply 0
  (mark_letApply-5 "" 3699274034
   ("" (measure-induct "length(L)" "L")
    (("" (skolem 1 "L")
      (("" (flatten)
        (("" (skeep*)
          (("" (case-replace "L = null")
            (("1" (expand length 1)
              (("1" (expand letApply 1)
                (("1" (use mark_repeat)
                  (("1" (split -1)
                    (("1" (propax) nil nil) ("2" (grind) nil nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (name "hd" "car(L)")
              (("1" (name "tl" "cdr(L)")
                (("1" (case-replace "L = cons(hd, tl)")
                  (("1" (expand length 2)
                    (("1" (rewrite mark_letApply_cons)
                      (("1" (rewrite vars_mark)
                        (("1" (expand letApply 2 4)
                          (("1" (expand markvars 2)
                            (("1" (simplify)
                              (("1"
                                (rewrite vars_letApply)
                                (("1"
                                  (rewrite vars_letApply)
                                  (("1"
                                    (rewrite markvars_bump)
                                    (("1"
                                      (rewrite markvars_varlist)
                                      (("1"
                                        (ground)
                                        (("1"
                                          (name
                                           "u"
                                           "NOT (in_varlist(map(lambda x: x WITH [`index := 1 + index(x)])
                             (tl))
                         (0)
                OR vars(mark(emptyset)(A))(length(tl)))")
                                          (("1"
                                            (replace -1)
                                            (("1"
                                              (case-replace "u = TRUE")
                                              (("1"
                                                (decompose-equality 3)
                                                (("1"
                                                  (lift-if)
                                                  (("1"
                                                    (lift-if)
                                                    (("1"
                                                      (lift-if)
                                                      (("1"
                                                        (split 1)
                                                        (("1"
                                                          (flatten 1)
                                                          (("1"
                                                            (split 1)
                                                            (("1"
                                                              (grind-with-ext)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (flatten
                                                               1)
                                                              (("2"
                                                                (rewrite
                                                                 vars_mark
                                                                 -1)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (split 4)
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (grind-with-ext)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (decompose-equality)
                                                  (("2"
                                                    (inst
                                                     -3
                                                     " map(lambda y: y WITH [`index := 1 + index(y)])(tl)")
                                                    (("2"
                                                      (split -3)
                                                      (("1"
                                                        (rewrite
                                                         map_length)
                                                        (("1"
                                                          (rewrite -1)
                                                          (("1"
                                                            (rewrite
                                                             bump_varlist)
                                                            (("1"
                                                              (hide-all-but
                                                               (1 -4))
                                                              (("1"
                                                                (skeep*)
                                                                (("1"
                                                                  (expand
                                                                   bump)
                                                                  (("1"
                                                                    (expand
                                                                     bumpn)
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (inst
                                                                         -4
                                                                         "i"
                                                                         "j-1")
                                                                        (("1"
                                                                          (expand
                                                                           in_varlist)
                                                                          (("1"
                                                                            (expand
                                                                             some
                                                                             -4)
                                                                            (("1"
                                                                              (grind)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         map_length)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (case-replace
                                                 "u = FALSE")
                                                (("1"
                                                  (decompose-equality
                                                   2)
                                                  (("1"
                                                    (lift-if)
                                                    (("1"
                                                      (lift-if)
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (split 1)
                                                          (("1"
                                                            (flatten 1)
                                                            (("1"
                                                              (split 1)
                                                              (("1"
                                                                (grind-with-ext)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (flatten
                                                                 1)
                                                                (("2"
                                                                  (rewrite
                                                                   vars_mark)
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (flatten)
                                                            (("2"
                                                              (split 4)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (grind-with-ext)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (inst
                                                     -3
                                                     "map(lambda y: y WITH [`index := 1 + index(y)])(tl)")
                                                    (("2"
                                                      (split -3)
                                                      (("1"
                                                        (rewrite
                                                         map_length)
                                                        (("1"
                                                          (rewrite -1)
                                                          (("1"
                                                            (hide-all-but
                                                             (1 -4))
                                                            (("1"
                                                              (skeep*)
                                                              (("1"
                                                                (rewrite
                                                                 bump_varlist)
                                                                (("1"
                                                                  (expand
                                                                   bump)
                                                                  (("1"
                                                                    (expand
                                                                     bumpn)
                                                                    (("1"
                                                                      (inst
                                                                       -3
                                                                       "i"
                                                                       "j - 1")
                                                                      (("1"
                                                                        (expand
                                                                         in_varlist)
                                                                        (("1"
                                                                          (expand
                                                                           some
                                                                           -3)
                                                                          (("1"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         map_length)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (rewrite map_length)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (rewrite map_length) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (rewrite map_length) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind-with-ext) nil nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (mark_letApply_cons formula-decl nil rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (markvars_varlist formula-decl nil preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (bump_varlist formula-decl nil rreduction nil)
    (map_length formula-decl nil more_map_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (markvars_bump formula-decl nil preprocess nil)
    (vars_letApply formula-decl nil rreduction nil)
    (vars_mark formula-decl nil preprocess nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (TRUE const-decl "bool" booleans nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (mark_repeat formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (letApply def-decl "IExpression" rreduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak)
  (mark_letApply-4 "" 3699215143
   ("" (measure-induct "length(L)" "L")
    (("" (skolem 1 "L")
      (("" (flatten)
        (("" (skeep*)
          (("" (case-replace "L = null")
            (("1" (expand length 1)
              (("1" (expand letApply 1)
                (("1" (use mark_repeat) (("1" (postpone) nil nil))
                  nil))
                nil))
              nil)
             ("2" (postpone) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (mark_letApply-3 "" 3699209434
   ("" (measure-induct "length(L)" "L")
    (("" (skolem 1 ("L"))
      (("" (flatten)
        (("" (skeep*)
          (("" (expand letApply 1)
            (("" (lift-if)
              (("" (split)
                (("1" (use mark_repeat) (("1" (postpone) nil nil)) nil)
                 ("2" (postpone) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (mark_letApply-2 "" 3698756834
   ("" (measure-induct+ "length(L)" ("L"))
    (("" (name-replace "L" "x!1")
      (("" (skeep*)
        (("" (expand letApply 1)
          (("" (lift-if)
            (("" (split)
              (("1" (use mark_repeat)
                (("1" (flatten)
                  (("1" (split -1)
                    (("1" (propax) nil nil)
                     ("2" (skeep*)
                      (("2" (inst -4 i) (("2" (grind) nil nil)) nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (name "hd" "car(L)")
                (("1" (name "tl" "cdr(L)")
                  (("1" (case-replace "L = cons(hd, tl)")
                    (("1" (flatten)
                      (("1" (lift-if)
                        (("1" (lift-if)
                          (("1" (rewrite vars_letApply)
                            (("1" (rewrite vars_letApply)
                              (("1"
                                (expand markvars 2)
                                (("1"
                                  (simplify)
                                  (("1"
                                    (rewrite markvars_bump)
                                    (("1"
                                      (rewrite markvars_varlist)
                                      (("1"
                                        (rewrite vars_mark)
                                        (("1"
                                          (expand length 2 1)
                                          (("1"
                                            (split)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (expand mark 3 1)
                                                (("1"
                                                  (decompose-equality
                                                   3)
                                                  (("1"
                                                    (expand mark 1 1)
                                                    (("1"
                                                      (expand
                                                       markv
                                                       1
                                                       1)
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (lift-if)
                                                          (("1"
                                                            (lift-if)
                                                            (("1"
                                                              (split 1)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (split
                                                                   1)
                                                                  (("1"
                                                                    (grind-with-ext)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (expand
                                                                       union
                                                                       -1)
                                                                      (("2"
                                                                        (expand
                                                                         drop
                                                                         -1)
                                                                        (("2"
                                                                          (expand
                                                                           vars
                                                                           -1)
                                                                          (("2"
                                                                            (expand
                                                                             add
                                                                             -1)
                                                                            (("2"
                                                                              (expand
                                                                               member)
                                                                              (("2"
                                                                                (expand
                                                                                 length
                                                                                 -1)
                                                                                (("2"
                                                                                  (rewrite
                                                                                   vars_letApply)
                                                                                  (("1"
                                                                                    (expand
                                                                                     in_varlist)
                                                                                    (("1"
                                                                                      (rewrite
                                                                                       some_map)
                                                                                      (("1"
                                                                                        (expand
                                                                                         o)
                                                                                        (("1"
                                                                                          (rewrite
                                                                                           vars_mark)
                                                                                          (("1"
                                                                                            (grind)
                                                                                            (("1"
                                                                                              (inst?
                                                                                               -4)
                                                                                              (("1"
                                                                                                (grind)
                                                                                                nil
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil)
                                                                                   ("2"
                                                                                    (rewrite
                                                                                     map_length)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (split
                                                                   2)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (expand
                                                                       union
                                                                       2)
                                                                      (("1"
                                                                        (expand
                                                                         drop
                                                                         2)
                                                                        (("1"
                                                                          (expand
                                                                           vars
                                                                           2)
                                                                          (("1"
                                                                            (expand
                                                                             length
                                                                             2)
                                                                            (("1"
                                                                              (expand
                                                                               add
                                                                               2)
                                                                              (("1"
                                                                                (expand
                                                                                 member
                                                                                 2)
                                                                                (("1"
                                                                                  (rewrite
                                                                                   vars_letApply)
                                                                                  (("1"
                                                                                    (expand
                                                                                     in_varlist)
                                                                                    (("1"
                                                                                      (rewrite
                                                                                       some_map)
                                                                                      (("1"
                                                                                        (expand
                                                                                         o)
                                                                                        (("1"
                                                                                          (rewrite
                                                                                           vars_mark)
                                                                                          (("1"
                                                                                            (grind)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (grind-with-ext)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (expand vars 1 1)
                                                    (("2"
                                                      (expand add 1 1)
                                                      (("2"
                                                        (expand
                                                         mark
                                                         1
                                                         1)
                                                        (("2"
                                                          (decompose-equality
                                                           1)
                                                          (("1"
                                                            (expand
                                                             markv)
                                                            (("1"
                                                              (lift-if)
                                                              (("1"
                                                                (split)
                                                                (("1"
                                                                  (expand
                                                                   length
                                                                   1)
                                                                  (("1"
                                                                    (expand
                                                                     union
                                                                     1)
                                                                    (("1"
                                                                      (expand
                                                                       member
                                                                       1)
                                                                      (("1"
                                                                        (expand
                                                                         bump
                                                                         1)
                                                                        (("1"
                                                                          (expand
                                                                           bumpn
                                                                           1)
                                                                          (("1"
                                                                            (rewrite
                                                                             vars_letApply)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (propax)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             length
                                                             1)
                                                            (("2"
                                                              (inst
                                                               -2
                                                               "map(lambda x: x WITH [(index) := 1 + index(x)])(tl)")
                                                              (("2"
                                                                (inst?
                                                                 -2)
                                                                (("2"
                                                                  (inst?
                                                                   -2)
                                                                  (("2"
                                                                    (split
                                                                     -2)
                                                                    (("1"
                                                                      (rewrite
                                                                       map_length)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (rewrite
                                                                       map_length)
                                                                      (("2"
                                                                        (expand
                                                                         length
                                                                         -2)
                                                                        (("2"
                                                                          (skeep*)
                                                                          (("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("3"
                                                                      (rewrite
                                                                       map_length)
                                                                      (("3"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (expand length 1)
                                                (("2"
                                                  (split 1)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand mark 3 1)
                                                      (("1"
                                                        (decompose-equality)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (expand mark 1 1)
                                                      (("2"
                                                        (decompose-equality)
                                                        (("1"
                                                          (expand
                                                           mark
                                                           1
                                                           1)
                                                          (("1"
                                                            (expand
                                                             markv)
                                                            (("1"
                                                              (lift-if)
                                                              (("1"
                                                                (lift-if)
                                                                (("1"
                                                                  (lift-if)
                                                                  (("1"
                                                                    (split)
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (split
                                                                         1)
                                                                        (("1"
                                                                          (grind-with-ext)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (expand
                                                                             union
                                                                             -1)
                                                                            (("2"
                                                                              (expand
                                                                               drop
                                                                               -1)
                                                                              (("2"
                                                                                (expand
                                                                                 member
                                                                                 -1)
                                                                                (("2"
                                                                                  (rewrite
                                                                                   vars_letApply)
                                                                                  (("1"
                                                                                    (expand
                                                                                     in_varlist)
                                                                                    (("1"
                                                                                      (rewrite
                                                                                       some_map)
                                                                                      (("1"
                                                                                        (expand
                                                                                         o)
                                                                                        (("1"
                                                                                          (rewrite
                                                                                           vars_mark)
                                                                                          (("1"
                                                                                            (split
                                                                                             -1)
                                                                                            (("1"
                                                                                              (propax)
                                                                                              nil
                                                                                              nil)
                                                                                             ("2"
                                                                                              (inst?
                                                                                               -6)
                                                                                              (("2"
                                                                                                (grind)
                                                                                                nil
                                                                                                nil))
                                                                                              nil)
                                                                                             ("3"
                                                                                              (propax)
                                                                                              nil
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil)
                                                                                   ("2"
                                                                                    (rewrite
                                                                                     map_length)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (expand
                                                                         union
                                                                         1)
                                                                        (("2"
                                                                          (expand
                                                                           drop
                                                                           1)
                                                                          (("2"
                                                                            (expand
                                                                             member)
                                                                            (("2"
                                                                              (rewrite
                                                                               vars_letApply)
                                                                              (("2"
                                                                                (expand
                                                                                 in_varlist)
                                                                                (("2"
                                                                                  (rewrite
                                                                                   some_map
                                                                                   1)
                                                                                  (("2"
                                                                                    (expand
                                                                                     o)
                                                                                    (("2"
                                                                                      (split
                                                                                       2)
                                                                                      (("1"
                                                                                        (flatten)
                                                                                        (("1"
                                                                                          (grind)
                                                                                          nil
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (grind-with-ext)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (rewrite
                                                           vars_letApply)
                                                          (("1"
                                                            (lift-if)
                                                            (("1"
                                                              (split)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (inst?
                                                                   -5)
                                                                  (("1"
                                                                    (inst?
                                                                     -5)
                                                                    (("1"
                                                                      (split
                                                                       -5)
                                                                      (("1"
                                                                        (rewrite
                                                                         map_length)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (rewrite
                                                                         map_length)
                                                                        (("2"
                                                                          (split
                                                                           -3)
                                                                          (("1"
                                                                            (expand
                                                                             in_varlist)
                                                                            (("1"
                                                                              (rewrite
                                                                               some_map)
                                                                              (("1"
                                                                                (expand
                                                                                 o)
                                                                                (("1"
                                                                                  (rewrite
                                                                                   some_nth)
                                                                                  (("1"
                                                                                    (grind)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (postpone)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("3"
                                                                        (postpone)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (postpone)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (postpone)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (postpone) nil nil)
                               ("3" (postpone) nil nil))
                              nil)
                             ("2" (postpone) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (postpone) nil nil))
                    nil))
                  nil)
                 ("2" (postpone) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (mark_letApply-1 nil 3693496107
   ("" (induct "L")
    (("1" (grind)
      (("1" (lemma "mark_idem")
        (("1" (inst?) (("1" (postpone) nil nil)) nil)) nil)
       ("2" (postpone) nil nil) ("3" (postpone) nil nil))
      nil)
     ("2" (postpone) nil nil))
    nil)
   nil shostak))
 (mark_letApply_weak 0
  (mark_letApply_weak-1 nil 3699274870
   ("" (skeep*)
    (("" (use mark_letApply)
      (("" (split -1)
        (("1" (propax) nil nil)
         ("2" (skeep*) (("2" (grind) nil nil)) nil)
         ("3" (skeep*) (("3" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((mark_letApply formula-decl nil rreduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length def-decl "nat" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/"))
   shostak))
 (check_marked_TCC1 0
  (check_marked_TCC1-1 nil 3698692883 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil))
 (check_marked_TCC2 0
  (check_marked_TCC2-1 nil 3698692883 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (check_marked_TCC3 0
  (check_marked_TCC3-1 nil 3698692883 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (value? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (check_marked_TCC4 0
  (check_marked_TCC4-1 nil 3698692883
   ("" (skeep* :preds? t) (("" (ground) (("" (grind) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (check_marked_TCC5 0
  (check_marked_TCC5-1 nil 3698692883
   ("" (skeep*)
    (("" (expand refcount)
      (("" (typepred "rS`count(refindex(vx))")
        (("1" (rewrite -1)
          (("1" (expand refcount)
            (("1" (split)
              (("1" (expand refcountStack)
                (("1" (use "finseq_theorems[(IL.value?)].count_elem")
                  (("1" (ground)
                    (("1" (inst 1 "rS`stack`length - 1 - index(x)")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand refcountStack)
                (("2"
                  (rewrite "finseq_theorems[(IL.value?)].count_update")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (delete 2)
          (("2" (typepred "rS`stack") (("2" (grind) nil nil)) nil))
          nil)
         ("3" (propax) nil nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (refcount const-decl "nat" rreduction nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "(value?)" IL nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountStack const-decl "nat" rreduction nil)
    (count_update formula-decl nil finseq_theorems nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (check_marked_TCC6 0
  (check_marked_TCC6-1 nil 3698692883
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred "rS`count(refindex(vx))")
        (("1" (rewrite -1)
          (("1" (expand refcount)
            (("1" (expand refcountStack)
              (("1" (lemma "finseq_theorems[(IL.value?)].count_elem")
                (("1" (inst?)
                  (("1" (inst?)
                    (("1" (ground)
                      (("1" (expand get)
                        (("1" (inst 1 "stack`length - 1 - index(x)")
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "rS`count(refindex(vx))")
        (("2" (rewrite -1)
          (("2" (expand refcount)
            (("2" (expand refcountStack)
              (("2" (use "finseq_theorems[(IL.value?)].count_update")
                (("1" (rewrite -1) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (check_marked_TCC7 0
  (check_marked_TCC7-1 nil 3698762473 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (release_marked_TCC1 0
  (release_marked_TCC1-1 nil 3699016249
   ("" (skeep*)
    (("" (ground)
      (("1" (expand refs)
        (("1" (typepred "rS`redex") (("1" (propax) nil nil)) nil)) nil)
       ("2" (expand vars)
        (("2" (expand popDepth)
          (("2" (typepred "rS`redex")
            (("2" (skeep)
              (("2" (inst -2 i) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("3" (expand popDepth 1 1)
        (("3" (typepred "rS`redex") (("3" (propax) nil nil)) nil)) nil)
       ("4" (expand popDepth 1 1)
        (("4" (typepred "rS`redex") (("4" (propax) nil nil)) nil)) nil)
       ("5" (expand contextPure?) (("5" (propax) nil nil)) nil)
       ("6" (expand mark)
        (("6" (typepred "rS`redex")
          (("6" (replace -6)
            (("6" (decompose-equality 1)
              (("6" (expand markv)
                (("6" (lift-if)
                  (("6" (ground)
                    (("1" (expand union)
                      (("1" (typepred x) (("1" (grind) nil nil)) nil))
                      nil)
                     ("2" (grind-with-ext) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refs def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil))
   nil))
 (release_marked_TCC2 0
  (release_marked_TCC2-1 nil 3699016249
   ("" (skeep*)
    (("" (typepred "rS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (expand refs 1 2) (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil))
 (applyReduce_TCC1 0
  (applyReduce_TCC1-1 nil 3676345135 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (injective? const-decl "bool" functions nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (applyRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (applyReduce_TCC2 0
  (applyReduce_TCC2-1 nil 3676345135
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (applyReduce_TCC3 0
  (applyReduce_TCC3-1 nil 3676345135
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred "grS`redex")
        (("1" (skeep)
          (("1" (use pure_refs)
            (("1" (use pure_letApply)
              (("1" (grind) nil nil)
               ("2" (typepred "body")
                (("2" (use pure_mark) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (rewrite popdepth_letApply)
          (("2" (lift-if)
            (("2" (rewrite vars_letApply)
              (("2" (rewrite vars_mark)
                (("2" (typepred grS)
                  (("2" (rewrite purePopDepth)
                    (("1" (rewrite purePopDepth)
                      (("1" (typepred body)
                        (("1" (typepred "grS`redex")
                          (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (grind) nil nil)
                       ("3" (typepred body)
                        (("3" (case "arity = 0")
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (rewrite pure_mark) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (skeep*)
        (("3" (rewrite purePopDepth)
          (("1" (typepred "grS`redex")
            (("1" (inst -3 i)
              (("1" (split -3)
                (("1" (grind) nil nil) ("2" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (typepred grS)
            (("2" (use pure_letApply)
              (("2" (rewrite pure_mark) nil nil)) nil))
            nil))
          nil))
        nil)
       ("4" (rewrite purePopDepth)
        (("1" (typepred "grS`redex") (("1" (grind) nil nil)) nil)
         ("2" (use pure_letApply) (("2" (rewrite pure_mark) nil nil))
          nil))
        nil)
       ("5" (use pure_contextPure)
        (("5" (use pure_letApply)
          (("1" (ground) nil nil) ("2" (rewrite pure_mark) nil nil))
          nil))
        nil)
       ("6" (use mark_letApply_weak)
        (("6" (ground)
          (("1" (rewrite -10)
            (("1" (rewrite -12)
              (("1" (rewrite -1)
                (("1"
                  (case-replace
                   "markvars(cvars(grS`context))(args) = args")
                  (("1" (typepred "grS`redex")
                    (("1" (typepred grS)
                      (("1"
                        (case-replace
                         "grS`redex = application(fun, args)")
                        (("1" (expand mark -8)
                          (("1" (decompose-equality -8) nil nil)) nil)
                         ("2" (grind-with-ext) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (typepred body) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mark_letApply_weak formula-decl nil rreduction nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (IExpression_application_extensionality formula-decl nil
     IExpression_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (pure_contextPure formula-decl nil IL nil)
    (vars_mark formula-decl nil preprocess nil)
    (purePopDepth formula-decl nil IL nil)
    (some adt-def-decl "boolean" list_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (Defs type-eq-decl nil rreduction nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (vars_letApply formula-decl nil rreduction nil)
    (popdepth_letApply formula-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure_refs formula-decl nil IL nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (length def-decl "nat" list_props nil)
    (letApply def-decl "IExpression" rreduction nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure_mark formula-decl nil preprocess nil)
    (def skolem-const-decl "Definition" rreduction nil)
    (body skolem-const-decl
          "{A | pure?(A) AND (forall i: vars(A)(i) IMPLIES i < def`arity)}"
          rreduction nil)
    (pure_letApply recursive-judgement-axiom nil rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil))
   nil))
 (applyReduce_TCC4 0
  (applyReduce_TCC4-1 nil 3676345135
   ("" (skeep*)
    (("" (expand "refcount")
      (("" (expand "refcountExpr")
        (("" (use "pure_letApply")
          (("1" (rewrite "pure_refs")
            (("1" (typepred "grS`count(x1)")
              (("1" (expand "refcount")
                (("1" (expand "refcountExpr")
                  (("1" (typepred "grS")
                    (("1" (forward-chain "pureApplyRedex")
                      (("1" (rewrite "pure_refs") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil)
           ("3" (hide 2) (("3" (rewrite "pure_mark") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (pure_mark formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure_refs formula-decl nil IL nil)
    (letApply def-decl "IExpression" rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureApplyRedex formula-decl nil IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (body skolem-const-decl
          "{A | pure?(A) AND (forall i: vars(A)(i) IMPLIES i < def`arity)}"
          rreduction nil)
    (def skolem-const-decl "Definition" rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (arity skolem-const-decl "nat" rreduction nil)
    (args skolem-const-decl "list[(variable?)]" rreduction nil)
    (length def-decl "nat" list_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pure_letApply recursive-judgement-axiom nil rreduction nil)
    (refcount const-decl "nat" rreduction nil))
   nil))
 (ifReduce_TCC1 0
  (ifReduce_TCC1-1 nil 3683858380 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (ifReduce_TCC2 0
  (ifReduce_TCC2-2 "" 3699283733
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred "grS`redex")
        (("1" (inst -2 "index(condition)")
          (("1" (ground)
            (("1" (typepred "grS")
              (("1" (expand pureIftRedex?)
                (("1" (expand iftRedex?)
                  (("1" (rewrite purePopDepth 2)
                    (("1" (rewrite purePopDepth 2)
                      (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "grS`redex")
              (("2"
                (case-replace
                 "grS`redex = ift(condition, thenexpr, elseexpr)")
                (("1" (grind) nil nil) ("2" (grind-with-ext) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "grS`redex")
        (("2" (case "grS`redex = ift(condition, thenexpr, elseexpr)")
          (("1" (rewrite -1)
            (("1" (expand mark -6)
              (("1" (expand markv -6)
                (("1" (expand union -6)
                  (("1" (expand member)
                    (("1" (decompose-equality -6)
                      (("1" (replace -1 -10 :dir RL)
                        (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind-with-ext) nil nil))
          nil))
        nil)
       ("3" (expand member)
        (("3" (typepred "grS`redex")
          (("3"
            (case-replace
             "grS`redex = ift(condition, thenexpr, elseexpr)")
            (("1" (expand mark -7)
              (("1" (decompose-equality -7)
                (("1" (expand markv -1)
                  (("1" (replace -1 -11 :dir RL)
                    (("1" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind-with-ext) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (release_set def-decl "IExpression" preprocess nil)
    (TRUE const-decl "bool" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (purePopDepth formula-decl nil IL nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (iftRedex? const-decl "bool" IL nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak)
  (ifReduce_TCC2-1 nil 3683858380
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred "grS`redex")
        (("1" (inst -2 "index(condition)")
          (("1" (ground)
            (("1" (typepred "grS")
              (("1" (expand pureIftRedex?)
                (("1" (expand iftRedex?) (("1" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "grS`redex")
        (("2" (case "grS`redex = ift(condition, thenexpr, elseexpr)")
          (("1" (rewrite -1)
            (("1" (expand mark -5)
              (("1" (expand markv -5)
                (("1" (expand union -5)
                  (("1" (expand member -5)
                    (("1" (expand member -6)
                      (("1" (simplify)
                        (("1" (rewrite -6 -5)
                          (("1" (hide-all-but (-5 -6))
                            (("1" (decompose-equality)
                              (("1"
                                (replace -1 :dir RL)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind-with-ext) nil nil))
          nil))
        nil)
       ("3" (lift-if)
        (("3" (typepred "grS`redex")
          (("3"
            (case-replace
             "grS`redex = ift(condition, thenexpr, elseexpr)")
            (("1" (expand mark -6)
              (("1" (decompose-equality -6)
                (("1" (replace -1 -10 :dir RL)
                  (("1" (hide-all-but (-9 -10)) (("1" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind-with-ext) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (iftRedex? const-decl "bool" IL nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (release_set def-decl "IExpression" preprocess nil)
    (difference const-decl "set" sets nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (empty? const-decl "bool" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (ifReduce_TCC3 0
  (ifReduce_TCC3-1 nil 3683858380
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred "grS")
        (("" (inst -3 "index(condition)")
          (("" (expand vars) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (iftRedex? const-decl "bool" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil))
   nil))
 (ifReduce_TCC4 0
  (ifReduce_TCC4-1 nil 3683858380
   ("" (skeep*)
    (("" (typepred "grS")
      (("" (typepred "grS`redex")
        (("" (ground)
          (("1" (hide-all-but (1 -1 -7 -10 -14))
            (("1" (grind) nil nil)) nil)
           ("2" (hide-all-but (1 -2 -7 -10 -14))
            (("2" (skeep*)
              (("2" (rewrite purePopDepth)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("3" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("4" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("5" (rewrite pure_contextPure) (("5" (grind) nil nil)) nil)
           ("6"
            (case-replace
             "grS`redex = ift(condition, thenexpr, elseexpr)")
            (("1" (expand mark -7)
              (("1" (decompose-equality -7)
                (("1"
                  (case-replace
                   "difference(vars(thenexpr), union(vars(elseexpr), cvars(grS`context))) = emptyset")
                  (("1" (grind) nil nil)
                   ("2" (hide-all-but (1 -3))
                    (("2" (use eq_mark_release_set)
                      (("2" (split -1)
                        (("1" (grind-with-ext) nil nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind-with-ext) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (release_set def-decl "IExpression" preprocess nil)
    (difference const-decl "set" sets nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (eq_mark_release_set formula-decl nil preprocess nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (pure_contextPure formula-decl nil IL nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (purePopDepth formula-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (iftRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil))
   nil))
 (ifReduce_TCC5 0
  (ifReduce_TCC5-1 nil 3683858380
   ("" (skeep*)
    (("" (expand refcount)
      (("" (typepred "grS`redex")
        (("" (typepred "grS")
          (("" (expand "pureIftRedex?")
            (("" (expand "iftRedex?")
              (("" (typepred "grS`count(x1)")
                (("" (rewrite -1)
                  (("" (expand refcount)
                    (("" (expand refcountExpr)
                      (("" (expand refs 2 1)
                        (("" (flatten)
                          (("" (use pure_refs)
                            (("" (ground)
                              ((""
                                (lift-if)
                                ((""
                                  (ground)
                                  ((""
                                    (use pure_refs)
                                    (("" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure_refs formula-decl nil IL nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (refcount const-decl "nat" rreduction nil))
   nil))
 (ifReduce_TCC6 0
  (ifReduce_TCC6-1 nil 3683858380
   ("" (skeep*)
    (("" (typepred "grS")
      (("" (typepred "grS`redex")
        (("" (ground)
          (("1" (hide-all-but (1 -1 -7 -10 -12))
            (("1" (grind) nil nil)) nil)
           ("2" (skeep)
            (("2" (rewrite purePopDepth)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil)
           ("3" (skeep*)
            (("3" (rewrite purePopDepth)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil)
           ("4" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("5" (rewrite pure_contextPure) (("5" (grind) nil nil)) nil)
           ("6"
            (case-replace
             "grS`redex = ift(condition, thenexpr, elseexpr)")
            (("1" (expand mark -7)
              (("1" (decompose-equality -7)
                (("1"
                  (case-replace
                   "difference(vars(elseexpr), union(vars(thenexpr), cvars(grS`context))) = emptyset")
                  (("1" (grind) nil nil)
                   ("2" (lemma eq_mark_release_set)
                    (("2" (grind-with-ext) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind-with-ext) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (release_set def-decl "IExpression" preprocess nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (eq_mark_release_set formula-decl nil preprocess nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (pure_contextPure formula-decl nil IL nil)
    (empty? const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (purePopDepth formula-decl nil IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (iftRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil))
   nil))
 (ifReduce_TCC7 0
  (ifReduce_TCC7-1 nil 3698757037
   ("" (skeep*)
    (("" (expand refcount)
      (("" (typepred "grS`redex")
        (("" (typepred "grS")
          (("" (expand "pureIftRedex?")
            (("" (expand "iftRedex?")
              (("" (typepred "grS`count(x1)")
                (("" (rewrite -1)
                  (("" (expand refcount)
                    (("" (expand refcountExpr)
                      (("" (expand refs 3 1)
                        (("" (flatten)
                          (("" (use pure_refs)
                            (("" (ground)
                              ((""
                                (lift-if)
                                ((""
                                  (ground)
                                  ((""
                                    (use pure_refs)
                                    (("" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure_refs formula-decl nil IL nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (refcount const-decl "nat" rreduction nil))
   nil))
 (setRedex_TCC1 0
  (setRedex_TCC1-1 nil 3698784150
   ("" (skeep*)
    (("" (typepred "rS")
      (("" (grind)
        (("1" (typepred "rS`redex") (("1" (grind) nil nil)) nil)
         ("2" (typepred "rS`redex")
          (("2" (inst -3 "i!1") (("2" (grind) nil nil)) nil)) nil)
         ("3" (typepred "vv") (("3" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil))
 (setRedex_TCC2 0
  (setRedex_TCC2-1 nil 3698784150 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (setRedex_TCC3 0
  (setRedex_TCC3-1 nil 3698784150
   ("" (skeep*)
    (("" (expand refcount)
      (("" (typepred "rS`count(refindex(vv))")
        (("" (rewrite -1)
          (("" (expand refcount)
            (("" (expand refcountExpr)
              (("" (typepred "rS`redex")
                (("" (typepred rS)
                  (("" (rewrite pure_refs) (("" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure_refs formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcount const-decl "nat" rreduction nil))
   nil))
 (setRedex_TCC4 0
  (setRedex_TCC4-1 nil 3698784150
   ("" (skeep* :preds? t)
    (("" (ground)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (typepred "rS`redex")
        (("3" (skeep) (("3" (inst -3 i) (("3" (grind) nil nil)) nil))
          nil))
        nil)
       ("4" (typepred "rS`redex") (("4" (grind) nil nil)) nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pure? def-decl "bool" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (emptyset const-decl "set" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refs def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil))
   nil))
 (setRedex_TCC5 0
  (setRedex_TCC5-1 nil 3698784150
   ("" (skeep*)
    (("" (typepred "rS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (grind)
              (("1" (typepred rS)
                (("1" (use pure_refs) (("1" (grind) nil nil)) nil))
                nil)
               ("2" (grind)
                (("2" (typepred rS)
                  (("2" (grind)
                    (("2" (typepred vv) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (pure_refs formula-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil))
   nil))
 (lookupReduce_TCC1 0
  (lookupReduce_TCC1-1 nil 3693417317 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (injective? const-decl "bool" functions nil)
    (lookupRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (lookupReduce_TCC2 0
  (lookupReduce_TCC2-1 nil 3693417317
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (inst -2 "index(avar)")
        (("" (typepred grS) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil))
   nil))
 (lookupReduce_TCC3 0
  (lookupReduce_TCC3-1 nil 3693417317
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred grS)
        (("" (inst -3 "index(pos)") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (markv const-decl "(variable?)" preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil))
   nil))
 (lookupReduce_TCC4 0
  (lookupReduce_TCC4-1 nil 3693417317 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (lookupRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (lookupReduce_TCC5 0
  (lookupReduce_TCC5-1 nil 3693417317 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (lookupRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (lookupReduce_TCC6 0
  (lookupReduce_TCC6-1 nil 3693417317
   ("" (skeep*)
    (("" (ground)
      (("1" (expand setRedex)
        (("1" (simplify)
          (("1" (typepred "grS`redex")
            (("1" (typepred grS)
              (("1" (inst -3 "index(avar)")
                (("1" (typepred "rval") (("1" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand setRedex)
        (("2" (simplify)
          (("2" (expand member)
            (("2" (typepred "rval") (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil)
       ("3" (expand setRedex)
        (("3" (expand member)
          (("3" (typepred "grS`redex")
            (("3" (case-replace "grS`redex = lookup(avar, pos)")
              (("1" (expand mark -7)
                (("1" (decompose-equality -7)
                  (("1" (replace -1 -10 :dir RL)
                    (("1" (grind) nil nil)) nil))
                  nil))
                nil)
               ("2" (grind-with-ext) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IExpression_lookup_extensionality formula-decl nil IExpression_adt
     nil)
    (nonempty? const-decl "bool" sets nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (setRedex const-decl "rstate" rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (grS skolem-const-decl "{grS | lookupRedex?(grS`redex)}" rreduction
     nil)
    (get const-decl "(value?)" IL nil)
    (markv const-decl "(variable?)" preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (lookupReduce_TCC7 0
  (lookupReduce_TCC7-1 nil 3693417317
   ("" (skeep*) (("" (typepred "grS") (("" (grind) nil nil)) nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (get const-decl "(value?)" IL nil) (pure? def-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil))
   nil))
 (newintReduce_TCC1 0
  (newintReduce_TCC1-1 nil 3699020624 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (injective? const-decl "bool" functions nil)
    (newintRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (newintReduce_TCC2 0
  (newintReduce_TCC2-1 nil 3699020624 ("" (subtype-tcc) nil nil)
   ((member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (below type-eq-decl nil naturalnumbers nil)
    (size!1 skolem-const-decl "nat" rreduction nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (size shared-adt-accessor-decl
          "[{x: IExpression | newint?(x) OR newref?(x)} -> nat]"
          IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (grS!1 skolem-const-decl "{grS | newintRedex?(grS`redex)}"
     rreduction nil)
    (x!1 skolem-const-decl "nat" rreduction nil)
    (nonempty? const-decl "bool" sets nil)
    (N!2 skolem-const-decl "nat" rreduction nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil)
    (least_out_rec def-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (newintRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (newintReduce_TCC3 0
  (newintReduce_TCC3-1 nil 3699020624
   ("" (skeep*)
    (("" (grind)
      (("1" (typepred "grS`redex") (("1" (grind) nil nil)) nil)
       ("2" (typepred "grS`redex")
        (("2" (inst -3 "i!1") (("2" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (newintRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mark def-decl "IExpression" preprocess nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (emptyset const-decl "set" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (refs def-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (newintReduce_TCC4 0
  (newintReduce_TCC4-1 nil 3699020624 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (newintRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (newintReduce_TCC5 0
  (newintReduce_TCC5-1 nil 3699020624 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil))
   nil))
 (newintReduce_TCC6 0
  (newintReduce_TCC6-1 nil 3699020624
   ("" (skeep*)
    (("" (expand refcount)
      (("" (expand refcountExpr)
        (("" (expand refs)
          (("" (rewrite refcount_stack_outside_domain)
            (("1" (lemma refcount_new)
              (("1" (inst -1 domain newdomain newrefredex store _)
                (("1" (inst?)
                  (("1" (ground)
                    (("1" (rewrite -1)
                      (("1" (expand refcountArray)
                        (("1" (rewrite count_none_zero)
                          (("1" (grind) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (ground)
                    (("1" (grind) nil nil)
                     ("2" (skeep*)
                      (("2" (typepred "store(x1)`seq(x2)")
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcount_stack_outside_domain formula-decl nil rreduction nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (grS skolem-const-decl "{grS | newintRedex?(grS`redex)}" rreduction
     nil)
    (domain skolem-const-decl "finite_set[nat]" rreduction nil)
    (store skolem-const-decl "Store(grS`domain)" rreduction nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (remove const-decl "set" sets nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (remove_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (refcountArray const-decl "nat" rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (count const-decl "nat" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count_none_zero formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (member const-decl "bool" sets nil)
    (newdomain skolem-const-decl "non_empty_finite_set[nat]" rreduction
     nil)
    (constant adt-constructor-decl "[int -> (constant?)]"
     IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (size skolem-const-decl "nat" rreduction nil)
    (refcount_new formula-decl nil rreduction nil)
    (refs def-decl "bool" IL nil)
    (refcount const-decl "nat" rreduction nil))
   nil))
 (newrefReduce_TCC1 0
  (newrefReduce_TCC1-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (injective? const-decl "bool" functions nil)
    (newrefRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (newrefReduce_TCC2 0
  (newrefReduce_TCC2-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (below type-eq-decl nil naturalnumbers nil)
    (size!1 skolem-const-decl "nat" rreduction nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (size shared-adt-accessor-decl
          "[{x: IExpression | newint?(x) OR newref?(x)} -> nat]"
          IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (grS!1 skolem-const-decl "{grS | newrefRedex?(grS`redex)}"
     rreduction nil)
    (x!1 skolem-const-decl "nat" rreduction nil)
    (nonempty? const-decl "bool" sets nil)
    (N!2 skolem-const-decl "nat" rreduction nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil)
    (least_out_rec def-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (newrefRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (newrefReduce_TCC3 0
  (newrefReduce_TCC3-1 nil 3699031813
   ("" (skeep*)
    (("" (ground)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind)
        (("3" (typepred "grS`redex")
          (("3" (inst -3 "i!1") (("3" (grind) nil nil)) nil)) nil))
        nil)
       ("4" (grind)
        (("4" (typepred "grS`redex") (("4" (grind) nil nil)) nil)) nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (emptyset const-decl "set" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (refs def-decl "bool" IL nil) (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil))
   nil))
 (newrefReduce_TCC4 0
  (newrefReduce_TCC4-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (newrefRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (newrefReduce_TCC5 0
  (newrefReduce_TCC5-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil))
   nil))
 (newrefReduce_TCC6 0
  (newrefReduce_TCC6-1 nil 3699031813
   ("" (skeep*)
    (("" (expand refcount)
      (("" (expand refcountExpr)
        (("" (expand refs)
          (("" (rewrite refcount_stack_outside_domain)
            (("1" (use refcount_new)
              (("1" (ground)
                (("1" (rewrite -1)
                  (("1" (expand refcountArray)
                    (("1" (rewrite count_none_zero)
                      (("1" (skeep*) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil)
               ("2" (delete 2)
                (("2" (ground)
                  (("1" (skeep*) (("1" (grind) nil nil)) nil)
                   ("2" (skeep*)
                    (("2" (typepred "store(x1)`seq(x2)")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcount_stack_outside_domain formula-decl nil rreduction nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (count const-decl "nat" finseq_theorems nil)
    (/= const-decl "boolean" notequal nil)
    (remove const-decl "set" sets nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (remove_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count_none_zero formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (member const-decl "bool" sets nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (grS skolem-const-decl "{grS | newrefRedex?(grS`redex)}" rreduction
     nil)
    (domain skolem-const-decl "finite_set[nat]" rreduction nil)
    (store skolem-const-decl "Store(grS`domain)" rreduction nil)
    (size skolem-const-decl "nat" rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (newdomain skolem-const-decl "non_empty_finite_set[nat]" rreduction
     nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (refcount_new formula-decl nil rreduction nil)
    (refs def-decl "bool" IL nil)
    (refcount const-decl "nat" rreduction nil))
   nil))
 (popReduce_TCC1 0
  (popReduce_TCC1-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (atom? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (popReduce_TCC2 0
  (popReduce_TCC2-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred grS) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (popReduce_TCC3 0
  (popReduce_TCC3-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (pop const-decl "Stack" IL nil) (value? const-decl "bool" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (atom? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (popReduce_TCC4 0
  (popReduce_TCC4-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (ground)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skeep) (("3" (inst -4 i) (("3" (grind) nil nil)) nil))
        nil)
       ("4" (grind) nil nil) ("5" (grind) nil nil)
       ("6" (grind) nil nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pop const-decl "Stack" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil))
   nil))
 (popReduce_TCC5 0
  (popReduce_TCC5-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (expand refcountStack)
              (("" (case-replace "grS`redex = pop(body)")
                (("1" (expand refs 2 1)
                  (("1"
                    (case-replace
                     "grS`stack = add(stack(stack`length - 1), pop(stack))")
                    (("1" (rewrite count_add)
                      (("1" (lift-if)
                        (("1" (ground)
                          (("1" (expand noDanglingRefs?)
                            (("1" (inst -13 0)
                              (("1"
                                (split -13)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil)
                                 ("3" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (expand add 1)
                      (("2" (expand pop 1)
                        (("2" (replace -12)
                          (("2" (hide-all-but (-6 -14 1))
                            (("2" (grind-with-ext) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind-with-ext) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil) (neStack type-eq-decl nil IL nil)
    (pop const-decl "Stack" IL nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (grS skolem-const-decl
     "{grS | popRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (count_add formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (IExpression_pop_extensionality formula-decl nil IExpression_adt
     nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (refcountStack const-decl "nat" rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (popReduce_TCC6 0
  (popReduce_TCC6-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred "grS")
        (("" (expand popRedex?)
          (("" (ground)
            (("1" (expand atom?) (("1" (propax) nil nil)) nil)
             ("2" (expand atom?)
              (("2" (case-replace "grS`redex = pop(body)")
                (("1" (expand vars -6)
                  (("1" (expand drop -6)
                    (("1" (expand popDepth -6)
                      (("1" (inst -6 "index(body) - 1")
                        (("1" (grind) nil nil)
                         ("2" (expand popDepth -7 1)
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind-with-ext) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (atom? const-decl "bool" IL nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (body skolem-const-decl "IExpression" rreduction nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (IExpression_pop_extensionality formula-decl nil IExpression_adt
     nil)
    (markv const-decl "(variable?)" preprocess nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (popReduce_TCC7 0
  (popReduce_TCC7-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred stack)
      (("" (grind)
        (("" (typepred "grS`redex")
          (("" (typepred grS)
            (("" (inst -4 "index(pbody(grS`redex)) - 1")
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (grS skolem-const-decl
     "{grS | popRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction
     nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Stack type-eq-decl nil IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (popReduce_TCC8 0
  (popReduce_TCC8-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (value? const-decl "bool" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (atom? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (popReduce_TCC9 0
  (popReduce_TCC9-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred "grS")
        (("" (inst -4 "index(body) - 1")
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (singleton const-decl "(singleton?)" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (body skolem-const-decl "IExpression" rreduction nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (popReduce_TCC10 0
  (popReduce_TCC10-1 nil 3699033156 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (value? const-decl "bool" IL nil))
   nil))
 (popReduce_TCC11 0
  (popReduce_TCC11-1 nil 3699033156
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred grS) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (popReduce_TCC12 0
  (popReduce_TCC12-1 nil 3699033156
   ("" (skeep* :preds? t)
    (("" (expand every)
      (("" (expand pop 3)
        (("" (skeep :preds? t)
          (("" (expand pop -1)
            (("" (lift-if)
              (("" (typepred "grS`stack") (("" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pop const-decl "Stack" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Stack type-eq-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil) (neStack type-eq-decl nil IL nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (atom? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (every const-decl "bool" finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (popReduce_TCC13 0
  (popReduce_TCC13-1 nil 3699033156
   ("" (skeep* :preds? t)
    (("" (ground)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skeep*) (("3" (inst -6 i) (("3" (grind) nil nil)) nil))
        nil)
       ("4" (grind) nil nil) ("5" (grind) nil nil)
       ("6" (grind) nil nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pop const-decl "Stack" IL nil) (refs def-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (grS skolem-const-decl
     "{grS | popRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction
     nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil))
   nil))
 (popReduce_TCC14 0
  (popReduce_TCC14-1 nil 3699033156
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountStack)
            ((""
              (case-replace "pop(grS`stack
                    WITH [(seq)(stack`length - 1 - index(body)) := nil]) = IF index(body) = 0 THEN pop(grS`stack) ELSE pop(grS`stack) WITH [(seq)(stack`length - 1 - index(body)) := nil] ENDIF")
              (("1"
                (case "grS`stack = add(stack`seq(stack`length - 1), pop(stack))")
                (("1" (replace -1 3)
                  (("1" (rewrite count_add)
                    (("1" (replace -1 3 :dir RL)
                      (("1" (lift-if)
                        (("1" (lift-if)
                          (("1" (replace -15)
                            (("1" (simplify)
                              (("1"
                                (lift-if)
                                (("1"
                                  (simplify)
                                  (("1"
                                    (rewrite count_update)
                                    (("1"
                                      (simplify)
                                      (("1"
                                        (expand pop)
                                        (("1"
                                          (expand refcountExpr)
                                          (("1"
                                            (case-replace
                                             "refs(grS`redex)(x1) = FALSE")
                                            (("1"
                                              (lift-if)
                                              (("1"
                                                (lift-if)
                                                (("1"
                                                  (lift-if)
                                                  (("1"
                                                    (lift-if)
                                                    (("1"
                                                      (lift-if)
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (lift-if)
                                                          (("1"
                                                            (lift-if)
                                                            (("1"
                                                              (simplify)
                                                              (("1"
                                                                (expand
                                                                 get)
                                                                (("1"
                                                                  (replace
                                                                   -21
                                                                   :dir
                                                                   RL)
                                                                  (("1"
                                                                    (ground)
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (grind)
                                                                      nil
                                                                      nil)
                                                                     ("3"
                                                                      (expand
                                                                       noDanglingRefs?)
                                                                      (("3"
                                                                        (inst
                                                                         -18
                                                                         0)
                                                                        (("1"
                                                                          (grind)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("4"
                                                                      (expand
                                                                       noDanglingRefs?)
                                                                      (("4"
                                                                        (inst
                                                                         -15
                                                                         0)
                                                                        (("1"
                                                                          (grind)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("5"
                                                                      (grind)
                                                                      nil
                                                                      nil)
                                                                     ("6"
                                                                      (grind)
                                                                      nil
                                                                      nil)
                                                                     ("7"
                                                                      (grind)
                                                                      nil
                                                                      nil)
                                                                     ("8"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (delete 4)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (case "index(body) = 0")
                                      (("1"
                                        (replace -1)
                                        (("1"
                                          (expand refcountExpr)
                                          (("1"
                                            (ground)
                                            (("1" (grind) nil nil)
                                             ("2" (grind) nil nil)
                                             ("3" (grind) nil nil)
                                             ("4" (grind) nil nil)
                                             ("5" (grind) nil nil)
                                             ("6" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (delete 5)
                                        (("2"
                                          (inst -7 "index(body) - 1")
                                          (("1" (grind) nil nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 4) (("2" (grind-with-ext) nil nil)) nil)
                 ("3" (grind) nil nil) ("4" (grind) nil nil))
                nil)
               ("2" (delete 4)
                (("2" (lift-if)
                  (("2" (expand pop)
                    (("2" (ground)
                      (("1" (apply-extensionality 1) nil nil)
                       ("2" (apply-extensionality 2)
                        (("1" (lift-if) (("1" (propax) nil nil)) nil)
                         ("2" (grind) nil nil)
                         ("3" (inst -5 "index(body) - 1")
                          (("3" (grind) nil nil)) nil)
                         ("4" (grind) nil nil)
                         ("5" (inst -5 "index(body) - 1")
                          (("5" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil)
               ("4" (inst -5 "index(body) - 1")
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
               ("5" (grind) nil nil) ("6" (grind) nil nil)
               ("7" (grind) nil nil) ("8" (grind) nil nil)
               ("9" (inst -5 "index(body) - 1")
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (refcountStack const-decl "nat" rreduction nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_add formula-decl nil finseq_theorems nil)
    (below type-eq-decl nil naturalnumbers nil)
    (count_update formula-decl nil finseq_theorems nil)
    (FALSE const-decl "bool" booleans nil)
    (get const-decl "(value?)" IL nil)
    (grS skolem-const-decl
     "{grS | popRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (atom? const-decl "bool" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (body skolem-const-decl "IExpression" rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (markv const-decl "(variable?)" preprocess nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pop const-decl "Stack" IL nil) (neStack type-eq-decl nil IL nil)
    (> const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (popReduce_TCC15 0
  (popReduce_TCC15-1 nil 3699033156
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (get const-decl "(value?)" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (singleton const-decl "(singleton?)" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (popReduce_TCC16 0
  (popReduce_TCC16-1 nil 3699301654
   ("" (skeep* :preds? t)
    (("" (expand every)
      (("" (expand pop)
        (("" (skeep* :preds? t)
          (("" (expand pop)
            (("" (inst? -12)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pop const-decl "Stack" IL nil) (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (> const-decl "bool" reals nil) (neStack type-eq-decl nil IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (grS skolem-const-decl
     "{grS | popRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (i skolem-const-decl "below(pop(grS`stack)`length)" rreduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (every const-decl "bool" finseq_theorems nil))
   nil))
 (popReduce_TCC17 0
  (popReduce_TCC17-1 nil 3699301654
   ("" (skeep* :preds? t)
    (("" (ground)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skeep*) (("3" (inst -6 i) (("3" (grind) nil nil)) nil))
        nil)
       ("4" (grind) nil nil) ("5" (grind) nil nil)
       ("6" (grind) nil nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pop const-decl "Stack" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (refs def-decl "bool" IL nil) (get const-decl "(value?)" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (grS skolem-const-decl
     "{grS | popRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction
     nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil))
   nil))
 (popReduce_TCC18 0
  (popReduce_TCC18-1 nil 3699301654
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (get const-decl "(value?)" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil))
   nil))
 (popReduce_TCC19 0
  (popReduce_TCC19-1 nil 3699301654
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(refindex(value))")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountStack)
            ((""
              (case "grS`stack = add(grS`stack`seq(grS`stack`length - 1), pop(grS`stack))")
              (("1" (replace -1 4)
                (("1" (rewrite count_add)
                  (("1" (replace -1 4 :dir RL)
                    (("1" (expand refcountExpr)
                      (("1"
                        (case-replace
                         "refs(value)(refindex(value)) = TRUE")
                        (("1"
                          (case-replace
                           "refs(grS`redex)(refindex(value)) = FALSE")
                          (("1" (lift-if)
                            (("1" (lift-if)
                              (("1"
                                (lift-if)
                                (("1"
                                  (simplify)
                                  (("1"
                                    (split 5)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand noDanglingRefs?)
                                        (("1"
                                          (inst -14 0)
                                          (("1" (grind) nil nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (expand noDanglingRefs?)
                                        (("2"
                                          (inst -12 0)
                                          (("1" (grind) nil nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete 5) (("2" (grind-with-ext) nil nil)) nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountStack const-decl "nat" rreduction nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (markv const-decl "(variable?)" preprocess nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (TRUE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (singleton const-decl "(singleton?)" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (get const-decl "(value?)" IL nil) (atom? const-decl "bool" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (below type-eq-decl nil naturalnumbers nil)
    (grS skolem-const-decl
     "{grS | popRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction
     nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FALSE const-decl "bool" booleans nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (count_add formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil) (neStack type-eq-decl nil IL nil)
    (pop const-decl "Stack" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil))
   nil))
 (popReduce_TCC20 0
  (popReduce_TCC20-1 nil 3699301654
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (get const-decl "(value?)" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (popDepth def-decl "nat" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (singleton const-decl "(singleton?)" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers
     nil))
   nil))
 (popReduce_TCC21 0
  (popReduce_TCC21-1 nil 3699301654 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (pop const-decl "Stack" IL nil) (get const-decl "(value?)" IL nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (grS!1 skolem-const-decl
     "{grS | popRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction
     nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (popReduce_TCC22 0
  (popReduce_TCC22-1 nil 3699301654
   ("" (skeep* :preds? t)
    (("" (ground)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skeep*) (("3" (inst -6 i) (("3" (grind) nil nil)) nil))
        nil)
       ("4" (grind) nil nil) ("5" (grind) nil nil)
       ("6" (grind) nil nil) ("7" (grind) nil nil)
       ("8" (grind) nil nil)
       ("9" (skeep*) (("9" (inst -6 i) (("9" (grind) nil nil)) nil))
        nil)
       ("10" (grind) nil nil) ("11" (grind) nil nil)
       ("12" (grind) nil nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pop const-decl "Stack" IL nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil))
   nil))
 (popReduce_TCC23 0
  (popReduce_TCC23-1 nil 3699301654
   ("" (skeep*)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountStack)
            ((""
              (case "grS`stack = add(grS`stack`seq(grS`stack`length - 1), pop(grS`stack))")
              (("1" (replace -1)
                (("1" (rewrite count_add)
                  (("1" (replace -1 :dir RL)
                    (("1" (typepred grS)
                      (("1" (expand noDanglingRefs?)
                        (("1" (inst -2 0)
                          (("1" (expand refcountExpr)
                            (("1"
                              (case-replace
                               "refs(grS`redex)(x1) = FALSE")
                              (("1"
                                (case-replace
                                 "refs(value)(x1) = FALSE")
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (simplify)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (delete 6)
                                  (("2"
                                    (typepred value)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (delete 6)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred "grS`redex")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (typepred "grS`redex")
                (("2" (grind-with-ext)
                  (("1" (typepred "grS`redex")
                    (("1" (typepred grS) (("1" (grind) nil nil)) nil))
                    nil)
                   ("2" (typepred grS) (("2" (grind) nil nil)) nil)
                   ("3" (typepred grS) (("3" (grind) nil nil)) nil)
                   ("4" (typepred grS) (("4" (grind) nil nil)) nil))
                  nil))
                nil)
               ("3" (typepred grS)
                (("3" (typepred "grS`redex") (("3" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountStack const-decl "nat" rreduction nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (count const-decl "nat" finseq_theorems nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (atom? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (FALSE const-decl "bool" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (grS skolem-const-decl
     "{grS | popRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction
     nil)
    (count_add formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil) (neStack type-eq-decl nil IL nil)
    (pop const-decl "Stack" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (releaseReduce_TCC1 0
  (releaseReduce_TCC1-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (releaseRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (releaseReduce_TCC2 0
  (releaseReduce_TCC2-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (inst -2 "index(x)")
        (("" (ground)
          (("" (typepred "grS") (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (releaseReduce_TCC3 0
  (releaseReduce_TCC3-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred stack)
      (("" (grind)
        (("" (typepred "grS`redex")
          (("" (inst -2 "index(rvar(grS`redex))")
            (("" (typepred grS) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (grS skolem-const-decl
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Stack type-eq-decl nil IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (releaseReduce_TCC4 0
  (releaseReduce_TCC4-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (inst -2 "index(x)")
        (("" (typepred grS) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (releaseReduce_TCC5 0
  (releaseReduce_TCC5-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred "grS") (("" (ground) (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (releaseRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (releaseReduce_TCC6 0
  (releaseReduce_TCC6-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (ground)
        (("1" (skeep*) (("1" (grind) nil nil)) nil)
         ("2" (skeep*) (("2" (grind) nil nil)) nil)
         ("3" (skeep*) (("3" (grind) nil nil)) nil)
         ("4" (grind) nil nil) ("5" (grind) nil nil)
         ("6" (case-replace "grS`redex = release(x, rexpr(grS`redex))")
          (("1" (expand mark -7)
            (("1" (simplify) (("1" (decompose-equality -7) nil nil))
              nil))
            nil)
           ("2" (grind-with-ext) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (releaseRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (grS skolem-const-decl
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (union const-decl "set" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (releaseReduce_TCC7 0
  (releaseReduce_TCC7-1 nil 3699031813
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (every const-decl "bool" finseq_theorems nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (releaseReduce_TCC8 0
  (releaseReduce_TCC8-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`count(refindex(vx))")
      (("1" (rewrite -1)
        (("1" (expand refcount)
          (("1" (expand refcountExpr)
            (("1"
              (case-replace "grS`redex = release(x, rexpr(grS`redex))")
              (("1" (simplify)
                (("1" (expand refs 1 2)
                  (("1" (expand refs 1 1)
                    (("1" (expand refcountStack)
                      (("1" (rewrite count_update)
                        (("1" (split)
                          (("1"
                            (lemma
                             "finseq_theorems[(value?)].count_elem")
                            (("1" (inst?)
                              (("1"
                                (inst?)
                                (("1"
                                  (split -1)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (inst
                                     1
                                     "grS`stack`length - index(x) - 1")
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (typepred "grS`redex")
                                      (("2"
                                        (inst -2 "index(x)")
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil)
                         ("2" (typepred "grS`redex")
                          (("2" (inst -2 "index(x)")
                            (("2" (grind) nil nil)) nil))
                          nil)
                         ("3" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind-with-ext) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "grS`stack")
        (("2" (grind)
          (("1" (typepred "grS`redex")
            (("1" (delete 2 3)
              (("1"
                (case-replace
                 "grS`redex = release(x, rexpr(grS`redex))")
                (("1" (inst -3 "index(x)") (("1" (grind) nil nil)) nil)
                 ("2" (grind-with-ext) nil nil))
                nil))
              nil))
            nil)
           ("2" (delete 2 3 4)
            (("2" (typepred "grS`redex")
              (("2"
                (case-replace
                 "grS`redex = release(x, rexpr(grS`redex))")
                (("1" (inst -3 "index(x)") (("1" (grind) nil nil)) nil)
                 ("2" (grind-with-ext) nil nil))
                nil))
              nil))
            nil)
           ("3" (typepred "grS`redex")
            (("3"
              (case-replace "grS`redex = release(x, rexpr(grS`redex))")
              (("1" (inst -3 "index(x)") (("1" (grind) nil nil)) nil)
               ("2" (grind-with-ext) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (propax) nil nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_update formula-decl nil finseq_theorems nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (grS skolem-const-decl
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (x skolem-const-decl "(variable?)" rreduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (get const-decl "(value?)" IL nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (refcountStack const-decl "nat" rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil))
   nil))
 (releaseReduce_TCC9 0
  (releaseReduce_TCC9-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (skeep* :preds? t)
        (("" (lift-if)
          (("" (ground)
            (("" (inst -7 i)
              (("" (ground)
                (("1"
                  (case-replace
                   "grS`redex = release(x, rexpr(grS`redex))")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (releaseRedex? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (grS skolem-const-decl
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (releaseReduce_TCC10 0
  (releaseReduce_TCC10-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred grS) (("" (ground) nil nil)) nil)) nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (releaseReduce_TCC11 0
  (releaseReduce_TCC11-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (ground)
        (("1" (skeep*) (("1" (grind) nil nil)) nil)
         ("2" (skeep*) (("2" (grind) nil nil)) nil)
         ("3" (skeep*) (("3" (grind) nil nil)) nil)
         ("4" (grind) nil nil) ("5" (grind) nil nil)
         ("6" (case-replace "grS`redex = release(x, rexpr(grS`redex))")
          (("1" (expand mark -7)
            (("1" (decompose-equality -7) nil nil)) nil)
           ("2" (grind-with-ext) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (releaseRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (releaseReduce_TCC12 0
  (releaseReduce_TCC12-1 nil 3699276705
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (releaseRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (grS skolem-const-decl
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil))
 (letReduce_TCC1 0
  (letReduce_TCC1-1 nil 3699107903 ("" (grind) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (atom? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (letReduce_TCC2 0
  (letReduce_TCC2-1 nil 3699107903 ("" (grind) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (atom? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (letReduce_TCC3 0
  (letReduce_TCC3-1 nil 3699107903
   ("" (skeep*)
    (("" (typepred "stack")
      (("" (grind)
        (("" (typepred "grS`redex")
          (("" (typepred "grS")
            (("" (inst -3 "index(letrhs(grS`redex))")
              (("" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (grS skolem-const-decl "{grS | pureLetRedex?(grS`redex)}"
     rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (letRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Stack type-eq-decl nil IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil))
   nil))
 (letReduce_TCC4 0
  (letReduce_TCC4-1 nil 3699107903
   ("" (skeep*)
    (("" (expand every)
      (("" (skeep*)
        (("" (expand push)
          (("" (expand add)
            (("" (lift-if)
              (("" (split 1)
                (("1" (grind) nil nil)
                 ("2" (typepred "stack") (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Stack type-eq-decl nil IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (push const-decl "Stack" IL nil)
    (every const-decl "bool" finseq_theorems nil))
   nil))
 (letReduce_TCC5 0
  (letReduce_TCC5-1 nil 3699107903
   ("" (skeep*)
    (("" (split 1)
      (("1" (skeep*)
        (("1" (replace -7)
          (("1" (lift-if)
            (("1" (split -1)
              (("1" (expand refs)
                (("1" (expand refs)
                  (("1" (typepred "grS`redex")
                    (("1" (typepred "grS")
                      (("1" (inst -2 i)
                        (("1" (delete -3 -4 -5 -6 -7)
                          (("1" (expand pureLetRedex?)
                            (("1" (ground)
                              (("1"
                                (use pure_refs)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand refs)
                (("2" (ground)
                  (("2" (use pure_refs)
                    (("2" (typepred grS) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep*)
        (("2" (replace -7)
          (("2" (lift-if)
            (("2" (expand popDepth)
              (("2" (expand popDepth 1 1)
                (("2" (rewrite purePopDepth 1)
                  (("1" (expand push 1)
                    (("1" (expand add)
                      (("1" (expand vars -1)
                        (("1" (expand drop -1)
                          (("1" (expand vars -1 1)
                            (("1" (expand add -1)
                              (("1"
                                (expand member -1)
                                (("1"
                                  (case
                                   "vars(body(expr))(1+i) OR index(letrhs(expr)) = i")
                                  (("1"
                                    (typepred "grS`redex")
                                    (("1"
                                      (typepred grS)
                                      (("1"
                                        (inst -3 i)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (typepred grS) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (skeep*)
        (("3" (typepred "grS`redex")
          (("3" (inst -3 i)
            (("3" (rewrite -13)
              (("3" (lift-if)
                (("3" (expand popDepth 1 1)
                  (("3" (expand push)
                    (("3" (expand add)
                      (("3" (expand popDepth 1 1)
                        (("3" (expand popDepth 1 3)
                          (("3" (rewrite purePopDepth 1)
                            (("1" (grind) nil nil)
                             ("2" (typepred grS)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (replace -6)
        (("4" (lift-if)
          (("4" (expand popDepth 1 1)
            (("4" (expand popDepth 1 1)
              (("4" (expand popDepth 1 3)
                (("4" (expand push)
                  (("4" (expand add)
                    (("4" (rewrite purePopDepth)
                      (("1" (typepred "grS`redex")
                        (("1" (grind) nil nil)) nil)
                       ("2" (typepred grS) (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (replace -6)
        (("5" (lift-if)
          (("5" (expand contextPure?)
            (("5" (expand contextPure? 1 1)
              (("5" (use pure_contextPure)
                (("5" (grind)
                  (("1" (typepred grS) (("1" (grind) nil nil)) nil)
                   ("2" (typepred grS) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("6" (lift-if)
        (("6" (split -6)
          (("1" (flatten)
            (("1" (replace -2)
              (("1" (expand mark 1)
                (("1" (expand mark 1)
                  (("1" (decompose-equality 1)
                    (("1" (decompose-equality 1)
                      (("1" (expand markv)
                        (("1" (lift-if)
                          (("1" (split)
                            (("1" (flatten)
                              (("1"
                                (expand union)
                                (("1"
                                  (expand bump)
                                  (("1"
                                    (expand bumpn)
                                    (("1"
                                      (expand member)
                                      (("1"
                                        (typepred "grS`redex")
                                        (("1"
                                          (typepred grS)
                                          (("1"
                                            (case-replace
                                             "grS`redex = letexpr(letrhs(expr), body(expr))")
                                            (("1"
                                              (expand mark -8)
                                              (("1"
                                                (decompose-equality -8)
                                                (("1"
                                                  (expand mark -1)
                                                  (("1"
                                                    (expand markv -1)
                                                    (("1"
                                                      (expand union -1)
                                                      (("1"
                                                        (expand
                                                         drop
                                                         -1)
                                                        (("1"
                                                          (expand
                                                           member)
                                                          (("1"
                                                            (simplify)
                                                            (("1"
                                                              (ground)
                                                              (("1"
                                                                (replace
                                                                 -2
                                                                 :dir
                                                                 RL)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (replace
                                                                 -2
                                                                 :dir
                                                                 RL)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (grind-with-ext)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (typepred "grS`redex")
                        (("2"
                          (case-replace
                           "grS`redex = letexpr(letrhs(expr), body(expr))")
                          (("1" (expand mark -7)
                            (("1" (decompose-equality -7)
                              (("1"
                                (lift-if -2)
                                (("1"
                                  (split -2)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (case
                                       "top_releases(release(variable(0, TRUE),
              mark(bump(cvars(grS`context)))(body(expr))))
       = top_releases(body(expr))")
                                      (("1"
                                        (expand top_releases -1 1)
                                        (("1"
                                          (rewrite top_releases_mark)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide-all-but (1 -1))
                                        (("2"
                                          (replace -1)
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind-with-ext) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (replace -1)
              (("2" (expand mark)
                (("2" (decompose-equality 2)
                  (("2" (typepred "grS`redex")
                    (("2" (typepred "grS")
                      (("2"
                        (case-replace
                         "grS`redex = letexpr(letrhs(expr), body(expr))")
                        (("1" (expand mark -8)
                          (("1" (decompose-equality -8)
                            (("1" (lift-if -2)
                              (("1"
                                (split -2)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (case
                                     "top_releases(release(variable(0, TRUE),
              mark(bump(cvars(grS`context)))(body(expr))))
       = top_releases(body(expr))")
                                    (("1"
                                      (expand top_releases -1 1)
                                      (("1"
                                        (rewrite top_releases_mark)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2" (rewrite -1) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind-with-ext) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_pop_extensionality formula-decl nil IExpression_adt
     nil)
    (top_releases_mark formula-decl nil preprocess nil)
    (top_releases def-decl "nat" preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (push const-decl "Stack" IL nil)
    (member const-decl "bool" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (union const-decl "set" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (add const-decl "(nonempty?)" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (purePopDepth formula-decl nil IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (refs def-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure_refs formula-decl nil IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (letReduce_TCC6 0
  (letReduce_TCC6-1 nil 3699107903 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (letReduce_TCC7 0
  (letReduce_TCC7-1 nil 3699107903
   ("" (skeep*)
    (("" (typepred "grS`count(refindex(value))")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (typepred "grS")
              ((""
                (case-replace
                 "grS`redex = letexpr(letrhs(expr), body(expr))")
                (("1" (expand refs 2 1)
                  (("1"
                    (case-replace
                     "refs(letrhs(expr))(refindex(value)) = FALSE")
                    (("1"
                      (case-replace
                       "refs(nredex)(refindex(value)) = FALSE")
                      (("1" (expand refcountStack)
                        (("1" (expand push)
                          (("1" (rewrite count_add)
                            (("1" (simplify) (("1" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete 3)
                        (("2" (replace -10)
                          (("2" (lift-if)
                            (("2" (expand refs 1)
                              (("2"
                                (expand refs 1 1)
                                (("2"
                                  (use pure_refs)
                                  (("2"
                                    (typepred grS)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind-with-ext) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (pure_refs formula-decl nil IL nil)
    (refcountStack const-decl "nat" rreduction nil)
    (count_add formula-decl nil finseq_theorems nil)
    (atom? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (count const-decl "nat" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (push const-decl "Stack" IL nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil))
   nil))
 (letReduce_TCC8 0
  (letReduce_TCC8-1 nil 3699107903
   ("" (skeep*)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountStack)
            (("" (expand push)
              (("" (rewrite count_add)
                (("" (ground)
                  (("" (replace -1)
                    (("" (simplify)
                      (("" (expand refcountExpr)
                        (("" (case-replace "refs(nredex)(x1) = FALSE")
                          (("1" (lift-if)
                            (("1" (ground)
                              (("1"
                                (case-replace
                                 "grS`redex = letexpr(letrhs(expr), body(expr))")
                                (("1"
                                  (expand refs -2)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (grind-with-ext) nil nil))
                                nil)
                               ("2"
                                (case-replace
                                 "grS`redex = letexpr(letrhs(expr), body(expr))")
                                (("1"
                                  (expand refs -2)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (grind-with-ext) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (replace -6)
                            (("2" (delete 3)
                              (("2"
                                (lift-if)
                                (("2"
                                  (expand refs)
                                  (("2"
                                    (expand refs 1 1)
                                    (("2"
                                      (use pure_refs)
                                      (("2"
                                        (typepred grS)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountStack const-decl "nat" rreduction nil)
    (count_add formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pure_refs formula-decl nil IL nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (push const-decl "Stack" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil))
   nil))
 (letReduce_TCC9 0
  (letReduce_TCC9-1 nil 3699107903 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (value? const-decl "bool" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (atom? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (letReduce_TCC10 0
  (letReduce_TCC10-1 nil 3699107903
   ("" (skeep*)
    (("" (expand every)
      (("" (skeep*)
        (("" (expand push)
          (("" (expand add)
            (("" (lift-if)
              (("" (split)
                (("1" (flatten)
                  (("1" (typepred "grS`redex")
                    (("1" (expand domainValue?)
                      (("1" (flatten)
                        (("1" (inst? -1)
                          (("1" (typepred grS) (("1" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (typepred stack) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (atom? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (push const-decl "Stack" IL nil)
    (every const-decl "bool" finseq_theorems nil))
   nil))
 (letReduce_TCC11 0
  (letReduce_TCC11-1 nil 3699107903
   ("" (skeep*)
    (("" (split)
      (("1" (expand refs)
        (("1" (use pure_refs)
          (("1" (typepred "grS") (("1" (grind) nil nil)) nil)) nil))
        nil)
       ("2" (expand vars)
        (("2" (expand drop)
          (("2" (expand popDepth)
            (("2" (expand push)
              (("2" (expand add)
                (("2" (skeep*)
                  (("2" (typepred "grS`redex")
                    (("2" (inst -2 i)
                      (("2" (rewrite purePopDepth 1)
                        (("1" (typepred grS) (("1" (grind) nil nil))
                          nil)
                         ("2" (typepred grS) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (skeep*)
        (("3" (expand popDepth 1 1)
          (("3" (rewrite purePopDepth)
            (("1" (typepred "grS`redex")
              (("1" (expand push)
                (("1" (expand add)
                  (("1" (inst -3 i) (("1" (grind) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (typepred grS) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("4" (expand popDepth 1 1)
        (("4" (rewrite purePopDepth)
          (("1" (typepred "grS`redex") (("1" (grind) nil nil)) nil)
           ("2" (typepred grS) (("2" (grind) nil nil)) nil))
          nil))
        nil)
       ("5" (expand contextPure?)
        (("5" (use pure_contextPure)
          (("5" (grind)
            (("5" (typepred grS) (("5" (grind) nil nil)) nil)) nil))
          nil))
        nil)
       ("6" (expand mark)
        (("6" (decompose-equality)
          (("6" (typepred "grS`redex")
            (("6"
              (case-replace
               "grS`redex = letexpr(letrhs(expr), body(expr))")
              (("1" (expand mark -7)
                (("1" (decompose-equality -7)
                  (("1" (lift-if -2)
                    (("1" (split -2)
                      (("1" (grind) nil nil)
                       ("2"
                        (case "top_releases(release(variable(0, TRUE),
              mark(bump(cvars(grS`context)))(body(expr))))
       = top_releases(body(expr))")
                        (("1" (expand top_releases -1 1)
                          (("1" (rewrite top_releases_mark)
                            (("1" (grind) nil nil)) nil))
                          nil)
                         ("2" (flatten)
                          (("2" (replace -1) (("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind-with-ext) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (top_releases def-decl "nat" preprocess nil)
    (top_releases_mark formula-decl nil preprocess nil)
    (TRUE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (IExpression_pop_extensionality formula-decl nil IExpression_adt
     nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pure_contextPure formula-decl nil IL nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (purePopDepth formula-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (push const-decl "Stack" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (refs def-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (letRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (pure_refs formula-decl nil IL nil))
   nil))
 (letReduce_TCC12 0
  (letReduce_TCC12-1 nil 3699276705
   ("" (skeep*)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountStack)
            (("" (expand push)
              (("" (rewrite count_add)
                (("" (expand refcountExpr)
                  (("" (expand refs 2 2)
                    (("" (case-replace "refs(body(expr))(x1) = FALSE")
                      (("1" (typepred "grS")
                        (("1"
                          (case-replace
                           "grS`redex = letexpr(letrhs(expr), body(expr))")
                          (("1" (expand refs 3 1)
                            (("1" (lift-if)
                              (("1"
                                (lift-if)
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (replace -4)
                                    (("1"
                                      (ground)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil)
                                       ("3" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind-with-ext) nil nil))
                          nil))
                        nil)
                       ("2" (use pure_refs)
                        (("2" (typepred grS) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountStack const-decl "nat" rreduction nil)
    (count_add formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (pure_refs formula-decl nil IL nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (count const-decl "nat" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (atom? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (push const-decl "Stack" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil))
   nil))
 (count_copy_TCC1 0
  (count_copy_TCC1-1 nil 3699369652 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (injective? const-decl "bool" functions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (<= const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (count_copy_TCC2 0
  (count_copy_TCC2-1 nil 3699369652
   ("" (skeep*) (("" (grind) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (count_copy_TCC3 0
  (count_copy_TCC3-1 nil 3699369652 ("" (termination-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (count_copy_TCC4 0
  (count_copy_TCC4-1 nil 3699369652 ("" (subtype-tcc) nil nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (injective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (<= const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (count_copy_def_TCC1 0
  (count_copy_def_TCC1-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (count_copy_def 0
  (count_copy_def-1 nil 3699371811 ("" (postpone) nil nil) nil
   shostak))
 (updateReduce_TCC1 0
  (updateReduce_TCC1-1 nil 3699107903 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (injective? const-decl "bool" functions nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (updateReduce_TCC2 0
  (updateReduce_TCC2-1 nil 3699107903
   ("" (skeep* :preds? t)
    (("" (inst -2 "index(target(expr))") (("" (grind) nil nil)) nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_TCC3 0
  (updateReduce_TCC3-1 nil 3699107903
   ("" (skeep* :preds? t)
    (("" (expand every)
      (("" (expand get)
        (("" (inst -10 "stack`length - 1 - index(target(expr))")
          (("1" (grind) nil nil)
           ("2" (inst -2 "index(target(expr))") (("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_TCC4 0
  (updateReduce_TCC4-1 nil 3699107903
   ("" (skeep* :preds? t)
    (("" (inst -4 "index(lhs(expr))") (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_TCC5 0
  (updateReduce_TCC5-1 nil 3699107903
   ("" (skeep* :preds? t)
    (("" (expand every)
      (("" (inst -12 "stack`length - 1 - index(lhs(expr))")
        (("1" (grind) nil nil)
         ("2" (inst -4 "index(lhs(expr))") (("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_TCC6 0
  (updateReduce_TCC6-1 nil 3699107903
   ("" (skeep* :preds? t)
    (("" (inst -6 "index(rhs(expr))") (("" (grind) nil nil)) nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (updateReduce_TCC7 0
  (updateReduce_TCC7-1 nil 3699107903
   ("" (skeep* :preds? t)
    (("" (expand every)
      (("" (inst -14 "stack`length - 1 - index(rhs(expr))")
        (("1" (grind) nil nil)
         ("2" (inst -6 "index(rhs(expr))") (("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_TCC8 0
  (updateReduce_TCC8-1 nil 3699107903
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refs def-decl "bool" IL nil) (get const-decl "(value?)" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (updateRedex? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_TCC9 0
  (updateReduce_TCC9-1 nil 3699107903
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refs def-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (get const-decl "(value?)" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (updateRedex? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_TCC10 0
  (updateReduce_TCC10-1 nil 3699107903 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (updateReduce_TCC11 0
  (updateReduce_TCC11-1 nil 3699107903 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (updateReduce_TCC12 0
  (updateReduce_TCC12-1 nil 3699107903 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (updateReduce_TCC13 0
  (updateReduce_TCC13-1 nil 3699107903 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (updateReduce_TCC14 0
  (updateReduce_TCC14-1 nil 3699107903 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (updateReduce_TCC15 0
  (updateReduce_TCC15-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC16 0
  (updateReduce_TCC16-1 nil 3699107903 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (updateReduce_TCC17 0
  (updateReduce_TCC17-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC18 0
  (updateReduce_TCC18-1 nil 3699107903 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC19 0
  (updateReduce_TCC19-1 nil 3699276705 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil))
   nil))
 (updateReduce_TCC20 0
  (updateReduce_TCC20-1 nil 3699276705 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC21 0
  (updateReduce_TCC21-1 nil 3699276705 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC22 0
  (updateReduce_TCC22-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC23 0
  (updateReduce_TCC23-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC24 0
  (updateReduce_TCC24-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC25 0
  (updateReduce_TCC25-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC26 0
  (updateReduce_TCC26-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC27 0
  (updateReduce_TCC27-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC28 0
  (updateReduce_TCC28-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC29 0
  (updateReduce_TCC29-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC30 0
  (updateReduce_TCC30-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC31 0
  (updateReduce_TCC31-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC32 0
  (updateReduce_TCC32-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC33 0
  (updateReduce_TCC33-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC34 0
  (updateReduce_TCC34-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC35 0
  (updateReduce_TCC35-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC36 0
  (updateReduce_TCC36-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC37 0
  (updateReduce_TCC37-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC38 0
  (updateReduce_TCC38-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC39 0
  (updateReduce_TCC39-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC40 0
  (updateReduce_TCC40-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC41 0
  (updateReduce_TCC41-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC42 0
  (updateReduce_TCC42-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC43 0
  (updateReduce_TCC43-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC44 0
  (updateReduce_TCC44-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC45 0
  (updateReduce_TCC45-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC46 0
  (updateReduce_TCC46-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC47 0
  (updateReduce_TCC47-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC48 0
  (updateReduce_TCC48-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC49 0
  (updateReduce_TCC49-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC50 0
  (updateReduce_TCC50-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil))
 (updateReduce_TCC51 0
  (updateReduce_TCC51-1 nil 3699370743 ("" (subtype-tcc) nil nil) nil
   nil)))

