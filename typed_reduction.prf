(typed_reduction
 (typeinfo_fill_TCC1 0
  (typeinfo_fill_TCC1-1 nil 3701693785 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[typeinfo_ctx])"
     typed_reduction nil))
   nil))
 (typeinfo_fill_TCC2 0
  (typeinfo_fill_TCC2-1 nil 3701693785 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[typeinfo_ctx])"
     typed_reduction nil))
   nil))
 (expr_type_TCC1 0
  (expr_type_TCC1-1 nil 3701611420 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[typeinfo])" typeinfo_adt
     nil))
   nil))
 (expr_type_TCC2 0
  (expr_type_TCC2-1 nil 3701611420 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[typeinfo])" typeinfo_adt
     nil))
   nil))
 (expr_type_TCC3 0
  (expr_type_TCC3-1 nil 3701611420 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[typeinfo])" typeinfo_adt
     nil))
   nil))
 (expr_type_TCC4 0
  (expr_type_TCC4-1 nil 3701611420 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[typeinfo])" typeinfo_adt
     nil))
   nil))
 (tvars_TCC1 0
  (tvars_TCC1-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (tvars_TCC2 0
  (tvars_TCC2-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (tvars_TCC3 0
  (tvars_TCC3-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (tvars_TCC4 0
  (tvars_TCC4-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (tvars_TCC5 0
  (tvars_TCC5-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (tvars_TCC6 0
  (tvars_TCC6-1 nil 3701615503 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (tvars_TCC7 0
  (tvars_TCC7-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (popn_TCC1 0
  (popn_TCC1-1 nil 3701626353 ("" (subtype-tcc) nil nil) nil nil))
 (popn_TCC2 0
  (popn_TCC2-1 nil 3701626353 ("" (subtype-tcc) nil nil) nil nil))
 (popn_popn_TCC1 0
  (popn_popn_TCC1-1 nil 3701697545 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (popn_popn_TCC2 0
  (popn_popn_TCC2-1 nil 3701697545 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil))
 (popn_popn 0
  (popn_popn-1 nil 3701697545 ("" (grind) nil nil)
   ((popn const-decl "finseq[nat]" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (popn_zero_TCC1 0
  (popn_zero_TCC1-1 nil 3701790265 ("" (subtype-tcc) nil nil) nil nil))
 (popn_zero 0
  (popn_zero-1 nil 3701790265 ("" (grind-with-ext) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   shostak))
 (is_well_typed_TCC1 0
  (is_well_typed_TCC1-1 nil 3701611553
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC2 0
  (is_well_typed_TCC2-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst -4 i) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   nil))
 (is_well_typed_TCC3 0
  (is_well_typed_TCC3-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (lemma pure_contextPure)
      (("" (inst -1 body) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (contextPure? def-decl "bool" IL nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IExpression type-decl nil IExpression_adt nil))
   nil))
 (is_well_typed_TCC4 0
  (is_well_typed_TCC4-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (lemma pure_contextPure)
      (("" (split)
        (("1" (rewrite purePopDepth)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("2" (skeep)
          (("2" (inst -5 "i-1")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil))
   nil))
 (is_well_typed_TCC5 0
  (is_well_typed_TCC5-1 nil 3701611553
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC6 0
  (is_well_typed_TCC6-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep :preds? t)
        (("2" (inst -5 "i-1+popDepth(letrhs(A))")
          (("1" (grind) (("1" (rewrite cvars_pure) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (cvars_pure formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (is_well_typed_TCC7 0
  (is_well_typed_TCC7-1 nil 3701611553
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC8 0
  (is_well_typed_TCC8-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst -4 "i+1") (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC9 0
  (is_well_typed_TCC9-1 nil 3701611553 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (is_well_typed_TCC10 0
  (is_well_typed_TCC10-1 nil 3701611553 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (is_well_typed_TCC11 0
  (is_well_typed_TCC11-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil) ("2" (skeep) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC12 0
  (is_well_typed_TCC12-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil) ("2" (skeep) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (is_well_typed_TCC13 0
  (is_well_typed_TCC13-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst -4 i) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC14 0
  (is_well_typed_TCC14-1 nil 3701611553 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (singleton const-decl "(singleton?)" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (is_well_typed_TCC15 0
  (is_well_typed_TCC15-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (inst -3 index) (("" (grind) nil nil)) nil)) nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC16 0
  (is_well_typed_TCC16-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (contextPure? def-decl "bool" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil))
   nil))
 (is_well_typed_TCC17 0
  (is_well_typed_TCC17-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC18 0
  (is_well_typed_TCC18-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (lemma pure_contextPure (A texpr)) (("" (grind) nil nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC19 0
  (is_well_typed_TCC19-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (is_well_typed_TCC20 0
  (is_well_typed_TCC20-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((purePopDepth formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (pure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC21 0
  (is_well_typed_TCC21-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (lemma pure_contextPure (A eexpr)) (("" (grind) nil nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC22 0
  (is_well_typed_TCC22-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (is_well_typed_TCC23 0
  (is_well_typed_TCC23-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((purePopDepth formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (pure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC24 0
  (is_well_typed_TCC24-1 nil 3701611553
   ("" (skeep* :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC25 0
  (is_well_typed_TCC25-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil))
   nil))
 (is_well_typed_TCC26 0
  (is_well_typed_TCC26-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC27 0
  (is_well_typed_TCC27-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_TCC28 0
  (is_well_typed_TCC28-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (is_well_typed_TCC29 0
  (is_well_typed_TCC29-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (is_well_typed_TCC30 0
  (is_well_typed_TCC30-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_TCC31 0
  (is_well_typed_TCC31-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (is_well_typed_TCC32 0
  (is_well_typed_TCC32-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC33 0
  (is_well_typed_TCC33-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_TCC34 0
  (is_well_typed_TCC34-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (is_well_typed_TCC35 0
  (is_well_typed_TCC35-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC36 0
  (is_well_typed_TCC36-1 nil 3701611553 ("" (termination-tcc) nil nil)
   ((contextPure? def-decl "bool" IL nil)) nil))
 (is_well_typed_TCC37 0
  (is_well_typed_TCC37-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_TCC38 0
  (is_well_typed_TCC38-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (is_well_typed_TCC39 0
  (is_well_typed_TCC39-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC40 0
  (is_well_typed_TCC40-1 nil 3701611553 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil))
 (is_well_typed_TCC41 0
  (is_well_typed_TCC41-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (inst -5 "index(nth(args, i))")
            (("2" (grind)
              (("2" (rewrite some_nth) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_TCC42 0
  (is_well_typed_TCC42-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (skeep)
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (replace -10)
            (("2" (inst -4 "i_1")
              (("2" (split -4)
                (("1" (propax) nil nil)
                 ("2" (expand cvars)
                  (("2" (expand vars)
                    (("2" (expand in_varlist)
                      (("2" (rewrite some_nth) (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (contextPure? def-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil))
   nil))
 (is_well_typed_TCC43 0
  (is_well_typed_TCC43-1 nil 3701626353
   ("" (skeep :preds? t)
    (("" (skeep)
      (("" (replace -9)
        (("" (expand <<)
          (("" (rewrite some_nth) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (some_nth formula-decl nil finseq_theorems nil))
   nil))
 (is_well_typed_ctx_TCC1 0
  (is_well_typed_ctx_TCC1-1 nil 3701633858
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (cpure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_ctx_TCC2 0
  (is_well_typed_ctx_TCC2-1 nil 3701633858
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil) ("2" (skeep) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((cpure? def-decl "bool" IL nil) (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (is_well_typed_ctx_TCC3 0
  (is_well_typed_ctx_TCC3-1 nil 3701633858
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IContext])" IL nil))
   nil))
 (is_well_typed_ctx_TCC4 0
  (is_well_typed_ctx_TCC4-1 nil 3701633858
   ("" (skeep :preds? t)
    (("" (use pure_contextPure) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil) (cpure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_ctx_TCC5 0
  (is_well_typed_ctx_TCC5-1 nil 3701633858 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_ctx_TCC6 0
  (is_well_typed_ctx_TCC6-1 nil 3701633858 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_ctx_TCC7 0
  (is_well_typed_ctx_TCC7-1 nil 3701633858
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (inst -4 "i - 1 + popDepth(letcrhs(K))")
          (("1" (grind) (("1" (rewrite cvars_pure) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (cpure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (letcrhs adt-accessor-decl "[(letc?) -> IContext]" IL nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (IContext type-decl nil IL nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (cvars_pure formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (is_well_typed_ctx_TCC8 0
  (is_well_typed_ctx_TCC8-1 nil 3701633858 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (is_well_typed_ctx_TCC9 0
  (is_well_typed_ctx_TCC9-1 nil 3701633858
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cpure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_ctx_TCC10 0
  (is_well_typed_ctx_TCC10-1 nil 3701633858
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (<< adt-def-decl "(strict_well_founded?[IContext])" IL nil))
   nil))
 (value_of_type_TCC1 0
  (value_of_type_TCC1-1 nil 3701781238 ("" (cases-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil))
   nil))
 (value_well_typed_TCC1 0
  (value_well_typed_TCC1-1 nil 3701795278 ("" (subtype-tcc) nil nil)
   nil nil))
 (value_well_typed_TCC2 0
  (value_well_typed_TCC2-1 nil 3701795278 ("" (subtype-tcc) nil nil)
   nil nil))
 (value_well_typed 0
  (value_well_typed-1 nil 3701795278
   ("" (skeep* :preds? t) (("" (grind-with-ext) nil nil)) nil)
   ((is_well_typed def-decl "bool" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (typeinfo_leaft_extensionality formula-decl nil typeinfo_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil))
   shostak))
 (typed_state_TCC1 0
  (typed_state_TCC1-1 nil 3701630090
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (typepred "state`redex")
          (("2" (inst -2 "i - popDepth(state`redex)")
            (("1" (split -2)
              (("1" (grind) nil nil)
               ("2" (rewrite cvars_vars) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (typed_state_TCC2 0
  (typed_state_TCC2-1 nil 3701631485
   ("" (with-labels (skeep* :preds? t) ((dmt sttl sttv obj)))
    (("" (split obj)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2"
        (with-labels (typepred "state`redex")
         ((href hvar hcvar hsl hcp)))
        (("2" (skeep)
          (("2" (inst hvar "i-popDepth(state`redex)")
            (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_state_TCC3 0
  (typed_state_TCC3-1 nil 3701631485
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (typepred "state`redex")
          (("2" (inst -3 "i - popDepth(state`context)")
            (("1" (split -3)
              (("1" (grind) nil nil)
               ("2" (rewrite cvars_vars_ctx) (("2" (grind) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_state_TCC4 0
  (typed_state_TCC4-1 nil 3701781238
   ("" (with-labels (skeep* :preds? t) ((dmt sttl sttv obj)))
    (("" (split obj)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2"
          (with-labels (typepred "state`redex")
           ((href hvar hcvar hsl hcp)))
          (("2" (inst hcvar "i-popDepth(state`context)")
            (("1" (rewrite cvars_vars_ctx)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popn const-decl "finseq[nat]" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (cvars_vars_ctx formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (fill_type 0
  (fill_type-1 nil 3701697451
   ("" (induct tK)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil))
    nil)
   ((typeinfo_ctx_induction formula-decl nil typed_reduction nil)
    (ctx_type def-decl "nat" typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (typeinfo_ctx type-decl nil typed_reduction nil))
   shostak))
 (fill_well_typed_TCC1 0
  (fill_well_typed_TCC1-1 nil 3701694762 ("" (subtype-tcc) nil nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (fill_well_typed_TCC2 0
  (fill_well_typed_TCC2-1 nil 3701694762 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (fill_well_typed_TCC3 0
  (fill_well_typed_TCC3-1 nil 3701694762
   ("" (skeep)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst -3 i) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (fill_well_typed_TCC4 0
  (fill_well_typed_TCC4-1 nil 3701694762
   ("" (skeep)
    (("" (rewrite contextPurefill) (("" (grind) nil nil)) nil)) nil)
   ((contextPurefill formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IContext type-decl nil IL nil))
   nil))
 (fill_well_typed_TCC5 0
  (fill_well_typed_TCC5-1 nil 3701694762
   ("" (skeep)
    (("" (split)
      (("1" (rewrite popdepth_fill) nil nil)
       ("2" (skeep)
        (("2" (rewrite cvars_fill)
          (("2" (split)
            (("1" (inst -6 "i-popDepth(A)")
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (inst -5 i) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (popdepth_fill formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (cvars_fill formula-decl nil preprocess nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (fill_well_typed 0
  (fill_well_typed-1 nil 3701695580
   ("" (induct K)
    (("1" (skeep*)
      (("1" (case-replace "tK = holet")
        (("1" (grind) nil nil)
         ("2" (expand is_well_typed_ctx) (("2" (grind) nil nil)) nil))
        nil))
      nil)
     ("2"
      (with-labels (skeep*)
       ((hrec acp kcp sl hvar hcvar hwt hwtc obj)))
      (("2" (expand is_well_typed_ctx hwtc)
        (("2" (with-labels (flatten) ((tklc hwtc ctxt hwt2)))
          (("2" (apply-eta "tK" "(letct?)")
            (("2" (replace -1 :dir RL)
              (("2" (simplify)
                (("2" (expand fill obj)
                  (("2" (expand typeinfo_fill obj)
                    (("2" (expand is_well_typed obj)
                      (("2" (split)
                        (("1" (inst?)
                          (("1" (split hrec)
                            (("1" (propax) nil nil)
                             ("2" (propax) nil nil)
                             ("3" (grind) nil nil)
                             ("4" (grind) nil nil)
                             ("5" (propax) nil nil)
                             ("6" (grind) nil nil)
                             ("7" (propax) nil nil)
                             ("8" (propax) nil nil))
                            nil))
                          nil)
                         ("2" (rewrite fill_type) nil nil)
                         ("3" (rewrite popn_popn)
                          (("1" (rewrite popdepth_fill) nil nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3"
      (with-labels (skeep*)
       ((hrec acp kcp sl hvar hcvar hwl hwlc obj)))
      (("3" (expand is_well_typed_ctx hwlc)
        (("3" (with-labels (flatten) ((kpc hwlc)))
          (("3" (apply-eta "tK" "(popct?)")
            (("3" (replace -1 :dir RL)
              (("3" (simplify)
                (("3" (expand fill obj)
                  (("3" (expand typeinfo_fill obj)
                    (("3" (expand is_well_typed obj)
                      (("3" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (delete 2)
      (("4" (lemma fill_well_typed_TCC5)
        (("4" (skeep) (("4" (inst?) (("4" (prop) nil nil)) nil)) nil))
        nil))
      nil)
     ("5" (lemma fill_well_typed_TCC4)
      (("5" (skeep*) (("5" (inst?) (("5" (prop) nil nil)) nil)) nil))
      nil)
     ("6" (lemma fill_well_typed_TCC3)
      (("6" (skeep*)
        (("6" (inst?) (("6" (inst?) (("6" (prop) nil nil)) nil)) nil))
        nil))
      nil)
     ("7" (lemma fill_well_typed_TCC2)
      (("7" (skeep*)
        (("7" (inst?) (("7" (inst?) (("7" (prop) nil nil)) nil)) nil))
        nil))
      nil)
     ("8" (lemma fill_well_typed_TCC1)
      (("8" (skeep*) (("8" (inst?) (("8" (prop) nil nil)) nil)) nil))
      nil))
    nil)
   ((fill_well_typed_TCC1 subtype-tcc nil typed_reduction nil)
    (fill_well_typed_TCC2 subtype-tcc nil typed_reduction nil)
    (fill_well_typed_TCC3 subtype-tcc nil typed_reduction nil)
    (fill_well_typed_TCC4 subtype-tcc nil typed_reduction nil)
    (fill_well_typed_TCC5 subtype-tcc nil typed_reduction nil)
    (pctbody adt-accessor-decl "[(popct?) -> typeinfo_ctx]"
     typed_reduction nil)
    (popct? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (typeinfo_ctx_popct_eta formula-decl nil typed_reduction nil)
    (popn_popn formula-decl nil typed_reduction nil)
    (popdepth_fill formula-decl nil IL nil)
    (fill_type formula-decl nil typed_reduction nil)
    (lcrhs adt-accessor-decl "[(letct?) -> typeinfo_ctx]"
     typed_reduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (letct? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (typeinfo_ctx_letct_eta formula-decl nil typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (holet? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (holet adt-constructor-decl "(holet?)" typed_reduction nil)
    (IContext_induction formula-decl nil IL nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (fill def-decl "IExpression" IL nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil) (cpure? def-decl "bool" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (typed_to_topstate_TCC1 0
  (typed_to_topstate_TCC1-1 nil 3701694762
   ("" (skeep* :preds? t)
    (("" (typepred "tS`dom_types") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (typed_to_topstate_TCC2 0
  (typed_to_topstate_TCC2-1 nil 3701694762
   ("" (skeep)
    (("" (typepred "tS`stack_types")
      (("" (expand to_topstate)
        (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (to_topstate const-decl "topstate" reduction nil))
   nil))
 (typed_to_topstate_TCC3 0
  (typed_to_topstate_TCC3-1 nil 3701694762
   ("" (with-labels (skeep) ((obj)))
    (("" (expand to_topstate)
      ((""
        (with-labels (typepred "tS`state`redex")
         ((href hvar hcvar hsl hcp)))
        (("" (use fill_well_typed)
          (("" (split -1)
            (("1" (propax) nil nil) ("2" (propax) nil nil)
             ("3" (typepred "tS`state`context")
              (("3" (propax) nil nil)) nil)
             ("4" (typepred "tS`stack_types") (("4" (grind) nil nil))
              nil)
             ("5" (typepred "tS`stack_types")
              (("5" (skeep)
                (("5" (inst hvar "i-popDepth(tS`state`redex)")
                  (("1" (rewrite cvars_vars) (("1" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("6" (typepred "tS`stack_types")
              (("6" (skeep)
                (("6" (inst hcvar "i-popDepth(tS`state`context)")
                  (("1" (rewrite cvars_vars_ctx)
                    (("1" (grind) nil nil)) nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("7" (typepred "tS`redex_type") (("7" (propax) nil nil))
              nil)
             ("8" (typepred "tS`context_type") (("8" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((to_topstate const-decl "topstate" reduction nil)
    (fill_well_typed formula-decl nil typed_reduction nil)
    (cvars_vars_ctx formula-decl nil preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_to_topstate_TCC4 0
  (typed_to_topstate_TCC4-1 nil 3701694762
   ("" (skeep :preds? t)
    (("" (expand to_topstate) (("" (grind) nil nil)) nil)) nil)
   ((to_topstate const-decl "topstate" reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (buildRedexType_TCC1 0
  (buildRedexType_TCC1-1 nil 3701699428 ("" (grind) nil nil)
   ((value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil))
   nil))
 (buildRedexType_TCC2 0
  (buildRedexType_TCC2-1 nil 3701699428
   ("" (skeep :preds? t)
    (("" (skeep)
      (("" (typepred "v(B, lrhs(tA))")
        (("" (grind) (("" (grind-with-ext) nil nil)) nil)) nil))
      nil))
    nil)
   ((atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (typeinfo_lett_extensionality formula-decl nil typeinfo_adt nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lett adt-constructor-decl "[[nat, typeinfo, typeinfo] -> (lett?)]"
     typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil))
   nil))
 (buildRedexType_TCC3 0
  (buildRedexType_TCC3-1 nil 3701699428 ("" (grind) nil nil)
   ((value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil))
   nil))
 (buildRedexType_TCC4 0
  (buildRedexType_TCC4-1 nil 3701699428
   ("" (skeep :preds? t)
    (("" (skeep)
      (("" (typepred "v(B, ptbody(tA))")
        (("" (grind) (("" (grind-with-ext) nil nil)) nil)) nil))
      nil))
    nil)
   ((atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (typeinfo_popt_extensionality formula-decl nil typeinfo_adt nil)
    (popt adt-constructor-decl "[typeinfo -> (popt?)]" typeinfo_adt
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt
     nil))
   nil))
 (buildRedexType_TCC5 0
  (buildRedexType_TCC5-1 nil 3701699428 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil))
   nil))
 (buildRedexType_TCC6 0
  (buildRedexType_TCC6-1 nil 3701699428 ("" (grind) nil nil)
   ((typeinfo_fill def-decl "typeinfo" typed_reduction nil)) nil))
 (buildRedexType_args_correct_TCC1 0
  (buildRedexType_args_correct_TCC1-1 nil 3701702657
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (buildRedexType_args_correct 0
  (buildRedexType_args_correct-1 nil 3701701286
   ("" (simplify :let-reduce? t)
    (("" (skeep)
      (("" (typepred "buildRedex(A)")
        (("" (replace -1 - :dir RL)
          (("" (rewrite contextPurefill)
            (("" (rewrite popdepth_fill)
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (split)
                      (("1" (skeep)
                        (("1" (inst - i)
                          (("1" (rewrite cvars_fill)
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (inst - "i+popDepth(buildRedex(A)`2)")
                          (("2" (rewrite cvars_fill)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popdepth_fill formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (cvars_fill formula-decl nil preprocess nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPurefill formula-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil))
   shostak))
 (buildRedexType_correct_TCC1 0
  (buildRedexType_correct_TCC1-1 nil 3701699904
   ("" (subtype-tcc) nil nil) nil nil))
 (buildRedexType_correct_TCC2 0
  (buildRedexType_correct_TCC2-1 nil 3701699904
   ("" (skeep*)
    (("" (use buildRedexType_args_correct) (("" (grind) nil nil)) nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (buildRedexType_correct_TCC3 0
  (buildRedexType_correct_TCC3-1 nil 3701699904
   ("" (skeep*)
    (("" (use buildRedexType_args_correct) (("" (grind) nil nil)) nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil))
 (buildRedexType_correct_TCC4 0
  (buildRedexType_correct_TCC4-1 nil 3701699904
   ("" (skeep*)
    (("" (use buildRedexType_args_correct) (("" (grind) nil nil)) nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (buildRedexType_correct_TCC5 0
  (buildRedexType_correct_TCC5-1 nil 3701701059
   ("" (skeep*)
    (("" (use buildRedexType_args_correct) (("" (grind) nil nil)) nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (buildRedexType_correct_TCC6 0
  (buildRedexType_correct_TCC6-1 nil 3701701059
   ("" (skeep*)
    (("" (use buildRedexType_args_correct)
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (simplify :let-reduce? t)
            (("2" (split)
              (("1" (flatten)
                (("1" (inst -5 i) (("1" (grind) nil nil)) nil)) nil)
               ("2" (propax) nil nil) ("3" (propax) nil nil)
               ("4" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil))
 (buildRedexType_correct 0
  (buildRedexType_correct-1 nil 3701700006
   ("" (simplify :let-reduce? t)
    (("" (induct A)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (with-labels (skeep*) ((hrec1 hrec2 cp sl hvar iwt obj)))
        (("5" (expand is_well_typed iwt)
          (("5" (with-labels (flatten) ((letta iwt1 et iwt2)))
            (("5" (case "atom?(letexpr1_var)")
              (("1" (expand buildRedex obj)
                (("1" (expand buildRedexType obj)
                  (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
                nil)
               ("2" (expand buildRedex obj)
                (("2" (expand buildRedexType obj)
                  (("2" (assert)
                    (("2" (split obj)
                      (("1" (grind) nil nil)
                       ("2" (expand is_well_typed_ctx obj)
                        (("2" (split obj)
                          (("1" (grind) nil nil)
                           ("2"
                            (typepred
                             "buildRedexType(letexpr1_var, lrhs(tA))")
                            (("2" (replace -1 et :dir RL)
                              (("2" (rewrite fill_type) nil nil)) nil))
                            nil)
                           ("3" (typepred "buildRedex(letexpr1_var)")
                            (("3" (replace -1 iwt2 :dir RL)
                              (("3"
                                (rewrite popdepth_fill)
                                (("3"
                                  (rewrite popn_popn)
                                  (("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("6" (grind) nil nil) ("7" (grind) nil nil)
       ("8" (grind) nil nil) ("9" (grind) nil nil)
       ("10" (grind) nil nil)
       ("11" (with-labels (skeep*) ((hrec cp sl hvar iwt obj)))
        (("11" (expand is_well_typed iwt)
          (("11" (with-labels (flatten) ((popta iwt)))
            (("11" (case "atom?(pop1_var)")
              (("1" (expand buildRedex obj)
                (("1" (expand buildRedexType obj)
                  (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
                nil)
               ("2" (expand buildRedex obj)
                (("2" (expand buildRedexType obj)
                  (("2" (assert)
                    (("2" (split obj)
                      (("1" (grind) nil nil)
                       ("2" (expand is_well_typed_ctx obj)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("12" (grind) nil nil) ("13" (grind) nil nil)
       ("14" (delete 2)
        (("14" (skeep)
          (("14" (use buildRedexType_args_correct)
            (("14" (grind) nil nil)) nil))
          nil))
        nil)
       ("15" (delete 2)
        (("15" (skeep)
          (("15" (use buildRedexType_args_correct)
            (("15" (grind) nil nil)) nil))
          nil))
        nil)
       ("16" (delete 2)
        (("16" (skeep)
          (("16" (use buildRedexType_args_correct)
            (("16" (grind) nil nil)) nil))
          nil))
        nil)
       ("17" (delete 2)
        (("17" (skeep)
          (("17" (use buildRedexType_args_correct)
            (("17" (grind) nil nil)) nil))
          nil))
        nil)
       ("18" (delete 2)
        (("18" (skeep)
          (("18" (use buildRedexType_args_correct)
            (("18" (grind) nil nil)) nil))
          nil))
        nil)
       ("19" (delete 2)
        (("19" (skeep)
          (("19" (use buildRedexType_args_correct)
            (("19" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (cpure? def-decl "bool" IL nil)
    (buildRedexType def-decl "{tK, tB | typeinfo_fill(tK, tB) = tA}"
     typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton const-decl "(singleton?)" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (emptyset const-decl "set" sets nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (value? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (fill_type formula-decl nil typed_reduction nil)
    (popn_popn formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (popdepth_fill formula-decl nil IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (buildRedexType_args_correct formula-decl nil typed_reduction nil))
   shostak))
 (make_redex_typed_TCC1 0
  (make_redex_typed_TCC1-1 nil 3701707876 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC2 0
  (make_redex_typed_TCC2-1 nil 3701707876
   ("" (skeep)
    (("" (typepred "tS`dom_types")
      (("" (skeep*)
        (("" (inst?)
          (("1" (inst -1 j)
            (("1" (grind) nil nil)
             ("2" (typepred j) (("2" (grind) nil nil)) nil))
            nil)
           ("2" (typepred r) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((atom? const-decl "bool" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC3 0
  (make_redex_typed_TCC3-1 nil 3701707876
   ("" (skeep* :preds? t)
    (("" (expand make_redex_e)
      (("" (typepred "tS`stack_types") (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (atom? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC4 0
  (make_redex_typed_TCC4-1 nil 3701707876
   ("" (skeep* :preds? t)
    (("" (expand make_redex_e)
      (("" (lemma buildRedexType_correct)
        (("" (simplify :let-reduce? t)
          ((""
            (inst -1 "tS`state`redex" "tS`def_types" "tS`dom_types"
             "tS`stack_types" "tS`redex_type")
            (("" (split -1)
              (("1" (assert) nil nil)
               ("2" (typepred "tS`state`redex")
                (("2" (propax) nil nil)) nil)
               ("3" (typepred "tS`state`redex")
                (("3" (typepred "tS`stack_types")
                  (("3" (grind) nil nil)) nil))
                nil)
               ("4" (typepred "tS`stack_types")
                (("4"
                  (with-labels (typepred "tS`state`redex")
                   ((href hvar hcvar hsl hcp)))
                  (("4" (skeep)
                    (("4" (inst hvar "i-popDepth(tS`state`redex)")
                      (("1" (rewrite cvars_vars)
                        (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("5" (typepred "tS`redex_type") (("5" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_vars formula-decl nil preprocess nil)
    (atom? const-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexType_correct formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC5 0
  (make_redex_typed_TCC5-1 nil 3701707876
   ("" (skeep* :preds? t)
    (("" (expand make_redex_e)
      (("" (lemma buildRedexType_correct)
        (("" (simplify :let-reduce? t)
          ((""
            (inst -1 "tS`state`redex" "tS`def_types" "tS`dom_types"
             "tS`stack_types" "tS`redex_type")
            (("" (split -1)
              (("1" (assert) nil nil)
               ("2" (typepred "tS`state`redex")
                (("2" (propax) nil nil)) nil)
               ("3" (typepred "tS`state`redex")
                (("3" (typepred "tS`stack_types")
                  (("3" (grind) nil nil)) nil))
                nil)
               ("4" (typepred "tS`stack_types")
                (("4"
                  (with-labels (typepred "tS`state`redex")
                   ((href hvar hcvar hsl hcp)))
                  (("4" (skeep)
                    (("4" (inst hvar "i-popDepth(tS`state`redex)")
                      (("1" (rewrite cvars_vars)
                        (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("5" (typepred "tS`redex_type") (("5" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_vars formula-decl nil preprocess nil)
    (atom? const-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexType_correct formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (defs_well_typed_TCC1 0
  (defs_well_typed_TCC1-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (defs_well_typed_TCC2 0
  (defs_well_typed_TCC2-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "D`seq(i)`body")
      (("" (use pure_contextPure) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure_contextPure formula-decl nil IL nil))
   nil))
 (defs_well_typed_TCC3 0
  (defs_well_typed_TCC3-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (typepred "D`seq(i)`body")
          (("2" (rewrite cvars_pure)
            (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_pure formula-decl nil preprocess nil))
   nil))
 (typed_reduce_TCC1 0
  (typed_reduce_TCC1-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (typed_reduce_TCC2 0
  (typed_reduce_TCC2-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (typed_reduce_TCC3 0
  (typed_reduce_TCC3-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`dom_types")
      (("" (expand letReduce) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (letReduce const-decl "estate" reduction nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil))
   nil))
 (typed_reduce_TCC4 0
  (typed_reduce_TCC4-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (apply-eta "nS`state`redex" "(letexpr?)")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil))
   nil))
 (typed_reduce_TCC5 0
  (typed_reduce_TCC5-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "nS`stack_types")
        (("1" (expand letReduce) (("1" (grind) nil nil)) nil)) nil)
       ("2" (skeep :preds? t)
        (("2" (with-labels (typepred "nS`stack_types") ((sll slv)))
          (("2" (case-replace "i = nS`stack_types`length")
            (("1" (expand add)
              (("1" (expand letReduce)
                (("1" (replace sll +)
                  (("1" (expand push)
                    (("1" (expand add)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten)
                            (("1"
                              (inst slv
                               "nS`stack_types`length - 1 - index(letrhs(nS`state`redex))")
                              (("1"
                                (typepred "nS`redex_type")
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (with-labels
                                 (typepred "nS`state`redex")
                                 ((href hvar hcvar hsl hcp)))
                                (("2"
                                  (inst
                                   hvar
                                   "index(letrhs(nS`state`redex))")
                                  (("2"
                                    (split hvar)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (apply-eta
                                       "nS`state`redex"
                                       "(letexpr?)")
                                      (("2"
                                        (replace -1 :dir RL)
                                        (("2"
                                          (expand vars)
                                          (("2"
                                            (expand union)
                                            (("2"
                                              (expand member)
                                              (("2"
                                                (simplify)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2"
                              (case "value?(letrhs(nS`state`redex))")
                              (("1"
                                (typepred "nS`redex_type")
                                (("1"
                                  (apply-eta
                                   "nS`state`redex"
                                   "(letexpr?)")
                                  (("1"
                                    (replace -1 :dir RL)
                                    (("1"
                                      (simplify)
                                      (("1"
                                        (expand is_well_typed)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (rewrite value_well_typed)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand add)
              (("2" (lift-if)
                (("2" (assert)
                  (("2" (expand letReduce)
                    (("2" (lift-if)
                      (("2" (expand push)
                        (("2" (expand add) (("2" (inst slv i) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (seq type-eq-decl nil more_finseq nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (refs def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (member const-decl "bool" sets nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (get const-decl "(value?)" IL nil) (push const-decl "Stack" IL nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (letReduce const-decl "estate" reduction nil))
   nil))
 (typed_reduce_TCC6 0
  (typed_reduce_TCC6-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (expand is_well_typed)
        (("" (typepred "nS`redex_type")
          (("" (apply-eta "nS`state`redex" "(letexpr?)")
            (("" (replace -1 :dir RL)
              (("" (assert)
                (("" (expand is_well_typed -)
                  ((""
                    (case-replace
                     "popn(nS`stack_types, popDepth(letrhs(nS`state`redex))) = nS`stack_types")
                    (("1" (assert) nil nil)
                     ("2"
                      (case-replace
                       "popDepth(letrhs(nS`state`redex)) = 0")
                      (("1" (use popn_zero) nil nil)
                       ("2" (expand pureLetRedex?)
                        (("2" (expand letRedex?)
                          (("2" (flatten) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (letRedex? const-decl "bool" IL nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (letReduce const-decl "estate" reduction nil))
   nil))
 (typed_reduce_TCC7 0
  (typed_reduce_TCC7-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (expand popDepth)
        (("" (rewrite purePopDepth)
          (("1" (assert)
            (("1"
              (case-replace
               "popn(add(lettype(nS`redex_type), nS`stack_types), 1) = nS`stack_types")
              (("1" (typepred "nS`context_type")
                (("1" (case-replace "popDepth(nS`state`redex) = 0")
                  (("1" (expand expr_type +)
                    (("1" (case "lett?(nS`redex_type)")
                      (("1" (grind) nil nil)
                       ("2" (typepred "nS`redex_type")
                        (("2" (apply-eta "nS`state`redex" "(letexpr?)")
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (apply-eta "nS`state`redex" "(letexpr?)")
                    (("1" (case "atom?(letrhs(nS`state`redex))")
                      (("1" (replace -2 :dir RL)
                        (("1" (expand popDepth)
                          (("1" (simplify) (("1" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (expand add)
                (("2" (expand popn)
                  (("2" (decompose-equality)
                    (("2" (decompose-equality) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "estate" reduction nil)
    (purePopDepth formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (popDepth def-decl "nat" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC8 0
  (typed_reduce_TCC8-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (typed_reduce_TCC9 0
  (typed_reduce_TCC9-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((applyReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC10 0
  (typed_reduce_TCC10-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (assert)
        (("" (typepred "nS`stack_types") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (applyReduce const-decl "estate" reduction nil))
   nil))
 (typed_reduce_TCC11 0
  (typed_reduce_TCC11-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (case "fun(nS`state`redex) < D`length")
        (("1" (assert)
          (("1"
            (case "length(args(nS`state`redex)) = D`seq(fun(nS`state`redex))`arity")
            (("1" (assert) (("1" (postpone) nil nil)) nil)
             ("2" (assert) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil) ("3" (grind) nil nil))
        nil))
      nil))
    nil)
   nil nil))
 (typed_reduce_TCC12 0
  (typed_reduce_TCC12-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (case-replace "popDepth(applyReduce(D)(nS`state)`redex) = 0")
      (("1" (expand applyReduce)
        (("1" (assert)
          (("1" (typepred "nS`context_type")
            (("1" (assert)
              (("1" (case-replace "popDepth(nS`state`redex) = 0")
                (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand applyReduce 1)
        (("2" (lift-if)
          (("2" (ground)
            (("1" (rewrite popdepth_letApply)
              (("1" (lift-if)
                (("1" (ground)
                  (("1" (rewrite purePopDepth) nil nil)
                   ("2" (typepred "args(nS`state`redex)")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil) ("3" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (applyReduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (popdepth_letApply formula-decl nil reduction nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (length def-decl "nat" list_props nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (pure_letApply rec-application-judgement "(pure?)" reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC13 0
  (typed_reduce_TCC13-1 nil 3701716715 ("" (grind) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC14 0
  (typed_reduce_TCC14-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (case-replace "reduce(D)(tS`state) = ifReduce(D)(nS`state)")
      (("1" (typepred "nS`dom_types") (("1" (grind) nil nil)) nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (popReduce const-decl "estate" reduction nil)
    (pop const-decl "Stack" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefReduce const-decl "estate" reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintReduce const-decl "estate" reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupReduce const-decl "estate" reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateReduce const-decl "estate" reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyReduce const-decl "estate" reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (letReduce const-decl "estate" reduction nil)
    (push const-decl "Stack" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (get const-decl "(value?)" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (ifReduce const-decl "estate" reduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (reduce const-decl "estate" reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Defs type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil reduction nil)
    (pure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (typed_reduce_TCC15 0
  (typed_reduce_TCC15-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (typepred "nS`stack_types") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((ifReduce const-decl "estate" reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC16 0
  (typed_reduce_TCC16-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (typed_reduce_TCC17 0
  (typed_reduce_TCC17-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (with-labels (typepred "nS`state`redex")
       ((href hvar hcvar hsl hcp)))
      (("" (inst hvar "index(condition(nS`state`redex))")
        (("" (split hvar)
          (("1" (grind) nil nil)
           ("2" (apply-eta "nS`state`redex" "(ift?)")
            (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (popDepth def-decl "nat" IL nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC18 0
  (typed_reduce_TCC18-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (apply-eta "nS`state`redex" "(ift?)")
      (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC19 0
  (typed_reduce_TCC19-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (apply-eta "nS`state`redex" "(ift?)")
      (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC20 0
  (typed_reduce_TCC20-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (lift-if)
        (("" (typepred "nS`redex_type")
          (("" (apply-eta "nS`state`redex" "(ift?)")
            (("1" (replace -1 :dir RL)
              (("1" (simplify)
                (("1" (expand is_well_typed -) (("1" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC21 0
  (typed_reduce_TCC21-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (typepred "nS`context_type")
            (("" (apply-eta "nS`state`redex" "(ift?)")
              (("1" (replace -1 :dir RL)
                (("1" (simplify)
                  (("1" (expand is_well_typed -)
                    (("1"
                      (case-replace
                       "expr_type(nS`redex_type) = expr_type(tthen(nS`redex_type))")
                      (("1" (expand popDepth -)
                        (("1"
                          (case-replace
                           "popDepth(elseexpr(nS`state`redex)) = 0")
                          (("1"
                            (case-replace
                             "popDepth(thenexpr(nS`state`redex)) = 0")
                            (("1" (assert) (("1" (grind) nil nil)) nil)
                             ("2" (use purePopDepth)
                              (("2" (grind) nil nil)) nil))
                            nil)
                           ("2" (use purePopDepth)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC22 0
  (typed_reduce_TCC22-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (typed_reduce_TCC23 0
  (typed_reduce_TCC23-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (expand updateRedex?) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (updateRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC24 0
  (typed_reduce_TCC24-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (lift-if) (("" (postpone) nil nil)) nil)) nil)
   nil nil))
 (typed_reduce_TCC25 0
  (typed_reduce_TCC25-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC26 0
  (typed_reduce_TCC26-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC27 0
  (typed_reduce_TCC27-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC28 0
  (typed_reduce_TCC28-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (typed_reduce_TCC29 0
  (typed_reduce_TCC29-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC30 0
  (typed_reduce_TCC30-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand lookupReduce)
      (("" (assert)
        (("" (typepred "nS`stack_types") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((lookupReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC31 0
  (typed_reduce_TCC31-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand lookupReduce)
      (("" (lift-if)
        (("" (ground)
          (("" (typepred "nS`dom_types")
            (("" (rewrite value_well_typed) (("" (postpone) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (typed_reduce_TCC32 0
  (typed_reduce_TCC32-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC33 0
  (typed_reduce_TCC33-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC34 0
  (typed_reduce_TCC34-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC35 0
  (typed_reduce_TCC35-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC36 0
  (typed_reduce_TCC36-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (reduce const-decl "estate" reduction nil)
    (newrefReduce const-decl "estate" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (newintReduce const-decl "estate" reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC37 0
  (typed_reduce_TCC37-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC38 0
  (typed_reduce_TCC38-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC39 0
  (typed_reduce_TCC39-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC40 0
  (typed_reduce_TCC40-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC41 0
  (typed_reduce_TCC41-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC42 0
  (typed_reduce_TCC42-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (reduce const-decl "estate" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil) (pop const-decl "Stack" IL nil)
    (popReduce const-decl "estate" reduction nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC43 0
  (typed_reduce_TCC43-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC44 0
  (typed_reduce_TCC44-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC45 0
  (typed_reduce_TCC45-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC46 0
  (typed_reduce_TCC46-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC47 0
  (typed_reduce_TCC47-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC48 0
  (typed_reduce_TCC48-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC49 0
  (typed_reduce_TCC49-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC50 0
  (typed_reduce_TCC50-1 nil 3701716715 ("" (subtype-tcc) nil nil) nil
   nil))
 (typed_reduce_TCC51 0
  (typed_reduce_TCC51-1 nil 3701780462 ("" (subtype-tcc) nil nil) nil
   nil)))

