rreduction      : THEORY

  BEGIN

    IMPORTING IExpression, IL, finite_set_theorems, finseq_theorems, preprocess, reduction

    A, B, C: VAR IExpression
    K, K1, K2: VAR IContext
  
    a, b, c: VAR (atom?)
    u, v, w: VAR (value?)
    x, y, z: VAR (variable?)
    i, j, k: VAR nat
    F: VAR finite_set[nat]

    S, S1, S2: VAR Stack
    nS: VAR neStack

    dom, dom1: VAR finite_set[nat]

    %i < j if j points to i in the store R
    store_order(dom, (R: Store(dom)))(i, j: (dom)):  bool =
      (EXISTS (k: below(R(j)`length)): ref?(R(j)`seq(k)) AND refindex(R(j)`seq(k)) = i)

    wfStore(dom): TYPE = {R: Store(dom) | well_founded?(store_order(dom, R))}


    Definition: TYPE = [# arity: nat, body: {A |  pure?(A) AND FORALL i: vars(A)(i) IMPLIES i < arity} #]

    Defs: TYPE = finseq[Definition]

    D: VAR Defs

    V: VAR finseq[(value?)]

    refcountArray(V)(i): nat = count((LAMBDA u: ref?(u) AND refindex(u) = i), V)

    IMPORTING reduction

    allcount(domain: finite_set[nat])(count: [(domain) -> nat]): nat =
       Sigma(domain, (LAMBDA j: IF domain(j) THEN count(j) ELSE 0 ENDIF))

    refcountStore(dom, (R: Store(dom)))(i: (dom)): nat =
      allcount(dom)(LAMBDA (j: (dom)): refcountArray(R(j))(i))

    refcountStack(S)(i): nat = count((LAMBDA u: ref?(u) AND refindex(u) = i), S)

    refcountExpr(A)(i): nat = (IF refs(A)(i) THEN 1 ELSE 0 ENDIF)

    refcount(dom, (R: Store(dom)), S, A)(i: (dom)): nat =
      refcountStore(dom, R)(i) +
      refcountStack(S)(i) +
      refcountExpr(A)(i)

    refcountExpr_popit: LEMMA
      refcountExpr(popit(j)(A))(i) = refcountExpr(A)(i)


%   Count(domain: finite_set[nat]): TYPE = [(domain)->nat]

    % finite_enumeration_inverse:  LEMMA
    %  (FORALL (i: (dom)):
    %   finite_enumeration(dom)(inverse(finite_enumeration(dom))(i)) = i)
    


    rstate: TYPE = [# error: bool,
                      domain: finite_set[nat],
                      store: Store(domain),
                      stack: {S : Stack | every(domainValue?(domain))(S)},
                      context: {K | cpure?(K) AND markc(emptyset)(K) = K},
                      redex: {A | (FORALL i: refs(A)(i)  IMPLIES domain(i))
                                  AND (FORALL i: vars(A)(i) IMPLIES i + popDepth(A) < stack`length)
                                  AND (FORALL i: vars(context)(i) IMPLIES i + popDepth(context) + popDepth(A) < stack`length)
                                  AND popDepth(A) + popDepth(context) <= stack`length
                                  AND contextPure?(A)
                                  AND mark(cvars(context))(A) = A
                              },
                      count: [i:(domain) -> {j | j = refcount(domain, store, stack, redex)(i)}]
                   #]

    rS, rS1, rS2: VAR rstate

    noDanglingRefs?(rS): bool =
      FORALL (i: below(rS`stack`length)):
        ref?(rS`stack`seq(rS`stack`length - i - 1)) IMPLIES
          cvars(rS`redex)(i) OR bumpn(cvars(rS`context), popDepth(rS`redex))(i)

    rtopstate: TYPE = {rS | rS`context = hole}
    to_topstate(rS) : rtopstate =
      rS WITH [`context := hole, `redex := fill(rS`context, rS`redex)]

    to_topstate_dangling: JUDGEMENT
      to_topstate(rS | noDanglingRefs?(rS)) HAS_TYPE (noDanglingRefs?)

    refcountStore_ref: LEMMA
      FORALL (r, i: (rS`domain)), (j : below(rS`store(r)`length)): 
        rS`store(r)`seq(j) = ref(i) => refcountStore(rS`domain, rS`store)(i) > 0

    refcountArray_update: LEMMA
      FORALL  (j: below(V`length)): 
        ref?(V`seq(j)) AND refindex(V`seq(j)) = i => 
          refcountArray(V WITH [`seq(j) := nil])(i) = refcountArray(V)(i) - 1

    store_update: LEMMA
      FORALL (r,  k : (rS`domain)), (j : below(rS`store(r)`length)):
        rS`store WITH [(r)`seq(j) := nil](k) = 
          IF r = k THEN
            rS`store(k) WITH [`seq(j) := nil]
          ELSE
            rS`store(k)
          ENDIF

    refcountStore_update: LEMMA
      FORALL (r, i: (rS`domain)), (j : below(rS`store(r)`length)):
        rS`store(r)`seq(j) = ref(i) => 
          refcountStore(rS`domain, rS`store WITH [(r)`seq(j) := nil])(i) =
            refcountStore(rS`domain, rS`store)(i) - 1

    refcountStore_set: LEMMA
      FORALL (R : Store(dom), r, i: (dom), j : below(R(r)`length), nv : (domainValue?(dom))):
        refcountStore(dom, R WITH [(r)`seq(j) := nv])(i) =
          refcountStore(dom, R)(i) - IF refs(R(r)`seq(j))(i) THEN 1 ELSE 0 ENDIF + IF refs(nv)(i) THEN 1 ELSE 0 ENDIF

    refcount_stack_outside_domain: LEMMA
      FORALL i: NOT member(i, rS`domain) IMPLIES refcountStack(rS`stack)(i) = 0

    refcount_new: LEMMA
      FORALL (store: Store(dom), store1: Store(dom1)):
        NOT member(i, dom) AND dom1 = add(i, dom) AND (FORALL (r : (dom)): store(r) = store1(r)) IMPLIES
          refcountStore(dom1, store1)(i) = refcountArray(store1(i))(i)

    allcountStore(rS): nat = allcount(rS`domain)(rS`count)

    allcountStore_update: LEMMA
      FORALL (r, i: (rS`domain)), (j : below(rS`store(r)`length)):
        rS`store(r)`seq(j) = ref(i) IMPLIES
          allcountStore(rS WITH [`store(r)`seq(j) := nil, `count(i) := rS`count(i) - 1]) =
            allcountStore(rS) - 1

    allcountStore_decrease: LEMMA
      FORALL (s: (rS`domain)):
        rS1`domain = rS`domain AND
        (FORALL (r : (rS`domain)) : IF r = s THEN rS1`count(r) < rS`count(r) ELSE rS1`count(r) = rS`count(r) ENDIF) =>
          allcountStore(rS1) < allcountStore(rS)

%decref is a critical operation that (recursively decrements the reference count while releasing
%references.  It's tricky to define since the invariant on count has to be preserved.
     decref(rS: (noDanglingRefs?), (r: (rS`domain)), (i: upto(rS`store(r)`length))):
     RECURSIVE {rS1 | allcountStore(rS1) <= allcountStore(rS) AND rS1`domain = rS`domain AND (FORALL (s : (rS`domain)): rS1`store(s)`length = rS`store(s)`length
          AND rS1`count(s) <= rS`count(s)
          AND (rS1`count(s) = 0 or rS1`store(s) = rS`store(s)))
          AND noDanglingRefs?(rS1)
          } =
      (IF rS`count(r) = 0
        THEN (IF i = 0 THEN rS
        ELSE
         (LET subref = rS`store(r)`seq(i-1),
              newrS = (IF ref?(subref)
                      THEN
                         (LET subrefindex: (rS`domain) = refindex(subref),
                              newsubrefcount = rS`count(subrefindex) - 1,
                              newrS = rS WITH [`store(r)`seq(i-1) := nil,
                                     `count(subrefindex) := newsubrefcount]
                           IN 
                       decref(newrS, subrefindex, rS`store(subrefindex)`length))
                      ELSE rS ENDIF)
          IN                
          decref(newrS, r, i - 1))
          ENDIF)
          ELSE rS ENDIF)
        MEASURE
        lex2(allcountStore(rS), i)

    % rstate2estate(rS): estate =
    %   (# error := rS`error,
    %      domain := rS`domain,
    %      store := rS`store,
    %      stack := rS`stack,
    %      redex := rS`redex #)

    goodrstate: TYPE = {rS | NOT rS`error}
    grS: VAR goodrstate

    d, d1 :VAR Definition
    L, J: VAR list[(variable?)]
    X : VAR finite_set[nat]

    letApply(arity: nat, (args: list[(variable?)] | length(args) = arity), A): RECURSIVE IExpression =
      IF arity = 0 THEN
        A
      ELSE
        LET arg1 = car(args),
            % marg1 = IF in_varlist(cdr(args))(arg1) OR X(arg1) OR vars(A)(arg1 + arity) THEN
            %           variable(arg1, FALSE)
            %         ELSE
            %           variable(arg1, TRUE)
            %         ENDIF,
            B = letApply(arity - 1, map(LAMBDA x: x WITH [`index := index(x) + 1])(cdr(args)), A)
        IN
        IF NOT vars(B)(0) THEN
          letexpr(arg1, release(variable(0, TRUE), B))
        ELSE
          letexpr(arg1, B)
        ENDIF
      ENDIF
    MEASURE arity

    pure_letApply: RECURSIVE JUDGEMENT
       letApply(i, (args: list[(variable?)] | length(args) = i), (A : IExpression | pure?(A))) HAS_TYPE
       (pure?)

    bump_varlist: LEMMA
      in_varlist(map(lambda y: y WITH [`index := index(y) + 1])(L)) = bump(in_varlist(L))

    vars_letApply: LEMMA
      (FORALL i, (args: list[(variable?)] | length(args) = i), A: 
       vars(letApply(i, args, A))(j) = (in_varlist(args)(j) OR vars(A)(j + i)))

    popdepth_letApply: LEMMA
    (FORALL i, (args: list[(variable?)] | length(args) = i), A: 
       popDepth(letApply(i, args, A)) = (IF i = 0 THEN popDepth(A) ELSE popDepth(car(args)) ENDIF))

    mark_letApply_cons: LEMMA
      mark(X)(letApply(1 + length(L), cons(x, L), A)) =
        LET ix = index(x) IN
        LET arg1 = IF in_varlist(L)(ix) OR X(ix) OR vars(A)(ix + length(L) + 1) THEN
                     variable(ix, FALSE)
                   ELSE
                     variable(ix, TRUE)
                   ENDIF
        IN
        LET B = mark(bump(X))(letApply(length(L), map(LAMBDA y: y WITH [`index := index(y) + 1])(L), A))
        IN
        IF NOT vars(B)(0) THEN
          letexpr(arg1, release(variable(0, TRUE), B))
        ELSE
          letexpr(arg1, B)
        ENDIF

    mark_letApply: LEMMA
%      (FORALL i: vars(A)(i) => i < length(L)) =>
      (FORALL i, j: vars(A)(i) AND in_varlist(L)(j) => i < length(L) + j) AND (FORALL i: vars(A)(i + length(L)) IMPLIES NOT X(i)) =>
           mark(X)(letApply(length(L), L, mark(emptyset)(A))) =
           letApply(length(L), markvars(X)(L), mark(emptyset)(A))

    mark_letApply_weak: LEMMA
      (FORALL i: vars(A)(i) => i < length(L)) =>
           mark(X)(letApply(length(L), L, mark(emptyset)(A))) =
           letApply(length(L), markvars(X)(L), mark(emptyset)(A))

    % check_marked(rS)(x : {x | index(x) < rS`stack`length}): rstate =
    %   IF marked(x) THEN
    %     LET stack = rS`stack IN
    %     LET vx = get(stack)(x) IN
    %     IF ref?(vx) THEN
    %       decref(rS WITH [`stack`seq(stack`length - index(x) - 1) := nil,
    %                       `count(refindex(vx)) := rS`count(refindex(vx)) - 1],
    %              refindex(vx), rS`store(refindex(vx))`length)
    %     ELSE
    %       rS
    %     ENDIF
    %   ELSE
    %     rS
    %   ENDIF

    release_marked(rS)(x | index(x) + popDepth(rS`redex) < rS`stack`length AND (marked(x) IMPLIES NOT member(index(x), vars(rS`redex)) AND NOT member(index(x), cvars(rS`context)))): rstate =
      IF marked(x) THEN rS WITH [`redex := release(x, rS`redex)] ELSE rS ENDIF

    applyReduce(D)(grS | applyRedex?(grS`redex)): rstate =
      LET stack = grS`stack,
          store = grS`store,
          domain = grS`domain,
          count = grS`count,
          expr = grS`redex,
          fun = fun(expr),
          args: list[(variable?)] = args(expr),
          lenargs = length(args)
      IN
      IF fun < D`length THEN
        LET def = D`seq(fun),
            arity = def`arity,
            body = def`body
        IN
        IF lenargs = arity THEN
          grS WITH [`redex := letApply(arity, args, mark(emptyset)(body))]
        ELSE
          grS WITH [`error := TRUE]
        ENDIF
      ELSE
        grS WITH [`error := TRUE]
      ENDIF

     ifReduce(D)(grS | pureIftRedex?(grS`redex)): rstate =
       LET stack = grS`stack,
           store = grS`store,
           expr = grS`redex,
           condition = condition(expr),
           thenexpr = thenexpr(expr),
           elseexpr = elseexpr(expr)
       IN
       release_marked(
         IF get(stack)(condition) = constant(0) THEN
           grS WITH [`redex := elseexpr]
         ELSE
           grS WITH [`redex := thenexpr]
         ENDIF)(condition)

     setRedex(rS | pure?(rS`redex), vv : (domainValue?(rS`domain))): rstate =
       IF ref?(vv) THEN
         rS WITH [`redex := vv, `count(refindex(vv)) := rS`count(refindex(vv)) + 1]
       ELSE
         rS WITH [`redex := vv]
       ENDIF

     lookupReduce(D)(grS | lookupRedex?(grS`redex)): rstate =
     (LET stack = grS`stack,
          domain = grS`domain,
          store = grS`store,
          expr = grS`redex,
          avar = arrayvalue(expr),
          pos = position(expr),
          aval = get(stack)(avar),
          pval = get(stack)(pos)
       IN IF (ref?(aval) AND domain(refindex(aval))
               AND constant?(pval) AND 0 <= value(pval) AND value(pval) < store(refindex(aval))`length)
          THEN
            LET rval = store(refindex(aval))`seq(value(pval)) IN
            release_marked(setRedex(grS, rval))(avar)
          ELSE
            grS WITH [`error := TRUE]
          ENDIF)

      newintReduce(D)(grS | newintRedex?(grS`redex)): rstate =
      (LET stack = grS`stack,
           domain = grS`domain,
           store = grS`store,
           expr = grS`redex,
           size = size(expr),
           newrefredex = least_out(domain),
           newdomain = add(newrefredex, domain)
       IN
       grS WITH [`redex := ref(newrefredex),
                 `domain := newdomain,
                 `store := store WITH [(newrefredex) |-> (# length := size, seq := (LAMBDA (i: below(size)): constant(0)) #)],
                 `count := grS`count WITH [(newrefredex) |-> 1]
                ])

      newrefReduce(D)(grS | newrefRedex?(grS`redex)): rstate =
      (LET stack = grS`stack,
           domain = grS`domain,
           store = grS`store,
           expr = grS`redex,
           size = size(expr),
           newrefredex = least_out(domain),
           newdomain = add(newrefredex, domain)
       IN
       grS WITH [`redex := ref(newrefredex),
                 `domain := newdomain,
                 `store := store WITH [(newrefredex) |-> (# length := size, seq := (LAMBDA (i: below(size)): nil) #)],
                 `count := grS`count WITH [(newrefredex) |-> 1]
                ])

     popReduce(D)(grS | popRedex?(grS`redex) AND noDanglingRefs?(grS)): rstate =
      (LET stack = grS`stack,
           store = grS`store,
           expr = grS`redex,
           body = pbody(expr)
       IN
       IF value?(body) THEN
         grS WITH [`redex := body,
                   `stack := pop(stack)]
       ELSE
         LET value : (domainValue?(grS`domain)) = get(stack)(body) IN
         IF marked(body) AND ref?(value) THEN
           grS WITH [`redex := value,
                     `stack := pop(grS`stack WITH [`seq(stack`length - index(body) - 1) := nil])]
         ELSIF ref?(value) THEN
           grS WITH [`redex := value,
                     `stack := pop(grS`stack),
                     `count(refindex(value)) := grS`count(refindex(value)) + IF index(body) = 0 THEN 0 ELSE 1 ENDIF]
         ELSE
           grS WITH [`redex := value,
                     `stack := pop(grS`stack)]
         ENDIF
       ENDIF)

     releaseReduce(D)(grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)): rstate =
       LET stack = grS`stack,
           x = rvar(grS`redex),
           vx : (domainValue?(grS`domain)) = get(stack)(x) IN
       IF ref?(vx) THEN
         decref(grS WITH [`stack`seq(stack`length - index(x) - 1) := nil,
                          `count(refindex(vx)) := grS`count(refindex(vx)) - 1,
                          `redex := rexpr(grS`redex)
                         ],
                refindex(vx), grS`store(refindex(vx))`length)
       ELSE
         grS WITH [`redex := rexpr(grS`redex)]
       ENDIF

    letReduce(D)(grS | pureLetRedex?(grS`redex)): rstate =
     (LET stack = grS`stack,
          store = grS`store,
          expr = grS`redex
      IN
      IF variable?(letrhs(expr)) THEN
        LET value : (domainValue?(grS`domain)) = get(stack)(letrhs(expr)) IN
        LET nredex =
          IF marked(letrhs(expr)) THEN
            pop(release(variable(index(letrhs(expr)) + 1, TRUE), body(expr)))
          ELSE
            pop(body(expr))
          ENDIF
        IN        
        grS WITH [`redex := nredex,
                  `stack := push(value, stack),
                  `count := IF ref?(value) THEN
                              grS`count WITH [(refindex(value)) |-> grS`count(refindex(value)) + 1]
                            ELSE
                              grS`count
                            ENDIF
                 ]
      ELSE
        grS WITH [`redex := pop(body(expr)),
                  `stack := push(letrhs(expr), stack)
                 ]
      ENDIF
     )

    count_copy(dom, (cnt : [(dom) -> nat]), (V: finseq[(domainValue?(dom))]), (i: upto(V`length))): RECURSIVE [(dom) -> nat] =
      IF i = 0 THEN
        cnt
      ELSE
        LET r = V(i - 1) IN
        LET ncnt =
          IF ref?(r) THEN
            cnt WITH [(refindex(r)) := cnt(refindex(r)) + 1]
          ELSE
            cnt
          ENDIF
        IN
        count_copy(dom, ncnt, V, i - 1)
      ENDIF
    MEASURE i

    count_copy_def: LEMMA
      FORALL (cnt: [(dom) -> nat], i: (dom), (V: finseq[(domainValue?(dom))])):
        count_copy(dom, cnt, V, V`length)(i) = cnt(i) + refcountArray(V)(i)

    updateReduce(D)(grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)): (noDanglingRefs?) =
      (LET stack = grS`stack,
           domain = grS`domain,
           store = grS`store,
           expr : { A | index(target(A)) < stack`length
                       AND index(lhs(A)) < stack`length
                       AND index(rhs(A)) < stack`length
                  } = grS`redex,
           aval : (domainValue?(domain)) = get(stack)(target(expr)),
           lval : (domainValue?(domain)) = get(stack)(lhs(expr)),
           rval : (domainValue?(domain)) = get(stack)(rhs(expr)) 
       IN
       IF (ref?(aval) AND constant?(lval) AND value(lval) >= 0
                      AND value(lval) < store(refindex(aval))`length) THEN
         LET nstack : { S : Stack | every(domainValue?(domain))(S) AND S`length = stack`length } =
           IF ref?(rval) AND marked(rhs(expr)) THEN
             stack WITH [`seq(stack`length - index(rhs(expr)) - 1) := nil]
           ELSE
             stack
           ENDIF
         IN
         LET ncount : [i:(domain) -> {j | j = refcount(domain, store, nstack, expr)(i)}] =
           IF ref?(rval) AND marked(rhs(expr)) THEN
             grS`count WITH [(refindex(rval)) := grS`count(refindex(rval)) - 1]
           ELSE
             grS`count
           ENDIF
         IN
         % If rval = aval, we have to copy and update because this is needed to match
         % the semantics defined in reduction.pvs. Of course, in a properly-typed
         % program, this can't happen (PVS doesn't allow circular references, which
         % is why refcounting will always garbage-collect everything), but we're not
         % able to prove that here.
         IF ncount(refindex(aval)) > 1 OR NOT marked(target(expr)) OR rval = aval THEN
           % Copy and update
           LET oldref = refindex(aval),
               newref = least_out(domain),
               newdomain = add(newref, domain),
               nnstack : { S : Stack | every(domainValue?(newdomain))(S) AND S`length = stack`length } =
                 IF marked(target(expr)) THEN
                   nstack WITH [`seq(stack`length - index(target(expr)) - 1) := nil]
                 ELSE
                   nstack
                 ENDIF,
               nncount = ncount WITH
                 [(newref) |-> 1,
                  (oldref) |-> ncount(oldref) - IF marked(target(expr)) THEN 1 ELSE 0 ENDIF],
               copied : finseq[(domainValue?(newdomain))] = store(oldref),
               nstore = store WITH [(newref) |-> copied],
               nnncount : [i:(newdomain) -> {j | j = refcount(newdomain, nstore, nnstack, ref(newref))(i)}] = count_copy(newdomain, nncount, copied, copied`length),
               nnstore = nstore WITH [(newref)`seq(value(lval)) := rval],
               oldvalue = copied`seq(value(lval)),
               nnnncount : [(newdomain) -> nat] =
                 IF ref?(oldvalue) THEN
                   nnncount WITH [(refindex(oldvalue)) := nnncount(refindex(oldvalue)) - 1]
                 ELSE
                   nnncount
                 ENDIF,
               nnnnncount : [i:(newdomain) -> {j | j = refcount(newdomain, nnstore, nnstack, ref(newref))(i)}] =
                 IF ref?(rval) THEN
                   nnnncount WITH [(refindex(rval)) := nnnncount(refindex(rval)) + 1]
                 ELSE
                   nnnncount
                 ENDIF
           IN
           grS WITH [`redex := ref(newref),
                     `domain := newdomain,
                     `store := nnstore,
                     `count := nnnnncount,
                     `stack := nnstack
                    ]
         ELSE
           % Update in-place
           LET oldref = refindex(aval),
               newstore = store WITH [(oldref)`seq(value(lval)) := rval],
               oldvalue = store(oldref)`seq(value(lval)),
               nnstack : { S : Stack | every(domainValue?(domain))(S) AND S`length = stack`length } =
                 nstack WITH [`seq(stack`length - 1 - index(target(expr))) := nil],
               nncount : [(domain) -> nat] =
                 IF ref?(rval) THEN
                   ncount WITH [(refindex(rval)) := ncount(refindex(rval)) + 1]
                 ELSE
                   ncount
                 ENDIF
           IN
           IF ref?(oldvalue) THEN
             LET orf = refindex(oldvalue) IN
             decref(grS WITH [
               `redex := aval,
               `store := newstore,
               `stack := nnstack,
               `count := nncount WITH [(orf) := nncount(orf) - 1]
             ], orf, newstore(orf)`length)
           ELSE
             grS WITH [
               `redex := aval,
               `store := newstore,
               `stack := nnstack,
               `count := nncount
             ]
           ENDIF
         ENDIF
       ELSE
         grS WITH [error := TRUE]
       ENDIF)

    letReduce_ndr: JUDGEMENT
      letReduce(D)(grS | noDanglingRefs?(grS) AND pureLetRedex?(grS`redex))
        HAS_TYPE (noDanglingRefs?)
    applyReduce_ndr: JUDGEMENT
      applyReduce(D)(grS | noDanglingRefs?(grS) AND applyRedex?(grS`redex))
        HAS_TYPE (noDanglingRefs?)
    ifReduce_ndr: JUDGEMENT
      ifReduce(D)(grS | noDanglingRefs?(grS) AND pureIftRedex?(grS`redex))
        HAS_TYPE (noDanglingRefs?)
    lookupReduce_ndr: JUDGEMENT
      lookupReduce(D)(grS | noDanglingRefs?(grS) AND lookupRedex?(grS`redex))
        HAS_TYPE (noDanglingRefs?)
    newintReduce_ndr: JUDGEMENT
      newintReduce(D)(grS | noDanglingRefs?(grS) AND newintRedex?(grS`redex))
        HAS_TYPE (noDanglingRefs?)
    newrefReduce_ndr: JUDGEMENT
      newrefReduce(D)(grS | noDanglingRefs?(grS) AND newrefRedex?(grS`redex))
        HAS_TYPE (noDanglingRefs?)
    popReduce_ndr: JUDGEMENT
      popReduce(D)(grS | noDanglingRefs?(grS) AND popRedex?(grS`redex))
        HAS_TYPE (noDanglingRefs?)
    releaseReduce_ndr: JUDGEMENT
      releaseReduce(D)(grS | noDanglingRefs?(grS) AND pureReleaseRedex?(grS`redex))
        HAS_TYPE (noDanglingRefs?)

    reduce(D)(grS | noDanglingRefs?(grS)): rstate =
      LET t = to_topstate(grS) IN
      IF atom?(t`redex) THEN
        t
      ELSE
        LET (ctx, redex) = buildRedex(t`redex),
            nS : (noDanglingRefs?) = t WITH [`context := ctx, `redex := redex]
        IN
        IF pureLetRedex?(redex) THEN
          letReduce(D)(nS)
        ELSIF applyRedex?(redex) THEN
          applyReduce(D)(nS)
        ELSIF pureIftRedex?(redex) THEN
          ifReduce(D)(nS)
        ELSIF updateRedex?(redex) THEN
          updateReduce(D)(nS)
        ELSIF lookupRedex?(redex) THEN
          lookupReduce(D)(nS)
        ELSIF newintRedex?(redex) THEN
          newintReduce(D)(nS)
        ELSIF newrefRedex?(redex) THEN
          newrefReduce(D)(nS)
        ELSIF popRedex?(redex) THEN
          popReduce(D)(nS)
        ELSE
          releaseReduce(D)(nS)
        ENDIF
      ENDIF



  END rreduction
